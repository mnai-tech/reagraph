{"version":3,"file":"index.umd.cjs","sources":["../src/utils/animation.ts","../src/utils/arrow.ts","../src/utils/layout.ts","../src/utils/cluster.ts","../src/utils/dom.ts","../src/utils/geometry.ts","../src/sizing/attribute.ts","../src/sizing/centrality.ts","../src/sizing/pageRank.ts","../src/sizing/nodeSizeProvider.ts","../src/utils/visibility.ts","../src/utils/graph.ts","../src/utils/paths.ts","../src/utils/position.ts","../src/utils/textMeasurement.ts","../src/store.ts","../src/CameraControls/useCameraControls.ts","../src/CameraControls/CameraControls.tsx","../src/CameraControls/utils.ts","../src/collapse/utils.ts","../src/collapse/useCollapse.ts","../src/CameraControls/useCenterGraph.ts","../src/symbols/Arrow.tsx","../src/utils/useDrag.ts","../src/utils/useHoverIntent.ts","../src/symbols/clusters/Ring.tsx","../src/symbols/Label.tsx","../src/symbols/Cluster.tsx","../src/symbols/edges/SelfLoop.tsx","../src/symbols/Line.tsx","../src/symbols/Edge.tsx","../src/symbols/edges/Edge.tsx","../src/symbols/edges/useEdgeAnimations.ts","../src/symbols/edges/useEdgeEvents.ts","../src/symbols/edges/useEdgeGeometry.ts","../src/symbols/edges/Edges.tsx","../src/symbols/nodes/Badge.tsx","../src/symbols/nodes/Icon.tsx","../src/symbols/Ring.tsx","../src/symbols/nodes/Sphere.tsx","../src/symbols/nodes/SphereWithIcon.tsx","../src/symbols/nodes/Svg.tsx","../src/symbols/nodes/SphereWithSvg.tsx","../src/symbols/Node.tsx","../src/layout/layoutUtils.ts","../src/layout/circular2d.ts","../src/layout/concentric2d.ts","../src/layout/custom.ts","../src/layout/depthUtils.ts","../src/layout/forceatlas2.ts","../src/layout/forceInABox.ts","../src/layout/forceUtils.ts","../src/layout/forceDirected.ts","../src/layout/hierarchical.ts","../src/layout/concentric3d.ts","../src/layout/nooverlap.ts","../src/layout/layoutProvider.ts","../src/layout/recommender.ts","../src/useGraph.ts","../src/utils/aggregateEdges.ts","../src/GraphScene.tsx","../src/selection/utils.ts","../src/selection/Lasso.tsx","../src/themes/darkTheme.ts","../src/themes/lightTheme.ts","../src/GraphCanvas/GraphCanvas.tsx","../src/RadialMenu/RadialSlice.tsx","../src/RadialMenu/utils.ts","../src/RadialMenu/RadialMenu.tsx","../src/selection/useSelection.ts"],"sourcesContent":["export const animationConfig = {\n  mass: 10,\n  tension: 1000,\n  friction: 300,\n  // Decreasing precision to improve performance from 0.00001\n  precision: 0.1\n};\n","import type { Curve, Vector3 } from 'three';\r\n\r\nimport type { EdgeArrowPosition } from '../symbols/Arrow';\r\n\r\n// Calculate the correct position for an arrow along a curve,\r\n// as well as the tangent to the curve at that point.\r\nexport function getArrowVectors(\r\n  placement: EdgeArrowPosition,\r\n  curve: Curve<Vector3>,\r\n  arrowLength: number\r\n): [Vector3, Vector3] {\r\n  const curveLength = curve.getLength();\r\n  const absSize = placement === 'end' ? curveLength : curveLength / 2;\r\n  const offset = placement === 'end' ? arrowLength / 2 : 0;\r\n  const u = (absSize - offset) / curveLength;\r\n\r\n  const position = curve.getPointAt(u);\r\n  const rotation = curve.getTangentAt(u);\r\n\r\n  return [position, rotation];\r\n}\r\n\r\nexport function getArrowSize(size: number): [number, number] {\r\n  return [size + 6, 2 + size / 1.5];\r\n}\r\n","import type { InternalGraphNode } from '../types';\r\n\r\nexport interface CenterPositionVector {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  minX: number;\r\n  maxX: number;\r\n  minY: number;\r\n  maxY: number;\r\n  minZ: number;\r\n  maxZ: number;\r\n  height: number;\r\n  width: number;\r\n}\r\n\r\n/**\r\n * Given a collection of nodes, get the center point.\r\n */\r\nexport function getLayoutCenter(\r\n  nodes: InternalGraphNode[]\r\n): CenterPositionVector {\r\n  let minX = Number.POSITIVE_INFINITY;\r\n  let maxX = Number.NEGATIVE_INFINITY;\r\n  let minY = Number.POSITIVE_INFINITY;\r\n  let maxY = Number.NEGATIVE_INFINITY;\r\n  let minZ = Number.POSITIVE_INFINITY;\r\n  let maxZ = Number.NEGATIVE_INFINITY;\r\n\r\n  for (const node of nodes) {\r\n    minX = Math.min(minX, node.position.x);\r\n    maxX = Math.max(maxX, node.position.x);\r\n    minY = Math.min(minY, node.position.y);\r\n    maxY = Math.max(maxY, node.position.y);\r\n    minZ = Math.min(minZ, node.position.z);\r\n    maxZ = Math.max(maxZ, node.position.z);\r\n  }\r\n\r\n  return {\r\n    height: maxY - minY,\r\n    width: maxX - minX,\r\n    minX,\r\n    maxX,\r\n    minY,\r\n    maxY,\r\n    minZ,\r\n    maxZ,\r\n    x: (maxX + minX) / 2,\r\n    y: (maxY + minY) / 2,\r\n    z: (maxZ + minZ) / 2\r\n  };\r\n}\r\n","import type { InternalGraphNode } from '../types';\r\nimport type { CenterPositionVector } from './layout';\r\nimport { getLayoutCenter } from './layout';\r\n\r\n/**\r\n * Given nodes and a attribute, find all the cluster groups.\r\n */\r\nexport function buildClusterGroups(\r\n  nodes: InternalGraphNode[],\r\n  clusterAttribute?: string\r\n) {\r\n  if (!clusterAttribute) {\r\n    return new Map();\r\n  }\r\n\r\n  return nodes.reduce((entryMap, e) => {\r\n    const val = e.data[clusterAttribute];\r\n    if (val) {\r\n      entryMap.set(val, [...(entryMap.get(val) || []), e]);\r\n    }\r\n    return entryMap;\r\n  }, new Map());\r\n}\r\n\r\nexport interface CalculateClustersInput {\r\n  /**\r\n   * The nodes to calculate clusters for.\r\n   */\r\n  nodes: InternalGraphNode[];\r\n  /**\r\n   * The attribute to use for clustering.\r\n   */\r\n  clusterAttribute?: string;\r\n}\r\n\r\nexport interface ClusterGroup {\r\n  /**\r\n   * Nodes in the cluster.\r\n   */\r\n  nodes: InternalGraphNode[];\r\n\r\n  /**\r\n   * Center position of the cluster.\r\n   */\r\n  position: CenterPositionVector;\r\n\r\n  /**\r\n   * Label of the cluster.\r\n   */\r\n  label: string;\r\n}\r\n\r\n/**\r\n * Builds the cluster map.\r\n *\r\n * This function:\r\n *  - Builds the cluster groups\r\n *  - Calculates the center position of each cluster group\r\n *  - Creates a cluster object for each group\r\n */\r\nexport function calculateClusters({\r\n  nodes,\r\n  clusterAttribute\r\n}: CalculateClustersInput) {\r\n  const result = new Map<string, ClusterGroup>();\r\n\r\n  if (clusterAttribute) {\r\n    const groups = buildClusterGroups(nodes, clusterAttribute);\r\n    for (const [key, nodes] of groups) {\r\n      const position = getLayoutCenter(nodes);\r\n      result.set(key, {\r\n        label: key,\r\n        nodes,\r\n        position\r\n      });\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","/**\r\n * Check if an element is not editable (input, select, textarea, contentEditable).\r\n * @param element - The element to check\r\n * @returns True if the element is not editable, false otherwise\r\n */\r\nexport const isNotEditableElement = (element: HTMLElement) => {\r\n  return (\r\n    element.tagName !== 'INPUT' &&\r\n    element.tagName !== 'SELECT' &&\r\n    element.tagName !== 'TEXTAREA' &&\r\n    !element.isContentEditable\r\n  );\r\n};\r\n","import type { Color, Curve, Vector3 } from 'three';\r\nimport {\r\n  BoxGeometry,\r\n  BufferGeometry,\r\n  CatmullRomCurve3,\r\n  Float32BufferAttribute,\r\n  TubeGeometry\r\n} from 'three';\r\nimport { mergeBufferGeometries } from 'three-stdlib';\r\n\r\n/**\r\n * Create a null geometry with consistent attributes\r\n * @returns A BufferGeometry with a null appearance\r\n */\r\nexport const createNullGeometry = (): BufferGeometry => {\r\n  const nullGeom = new BoxGeometry(0, 0, 0);\r\n  // Add color attribute to match other geometries\r\n  const vertexCount = nullGeom.attributes.position.count;\r\n  const colorArray = new Float32Array(vertexCount * 3);\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    colorArray[i * 3] = 1; // white\r\n    colorArray[i * 3 + 1] = 1;\r\n    colorArray[i * 3 + 2] = 1;\r\n  }\r\n  nullGeom.setAttribute('color', new Float32BufferAttribute(colorArray, 3));\r\n\r\n  return nullGeom;\r\n};\r\n\r\n/**\r\n * Add a color attribute to a geometry\r\n * @param geometry - The geometry to add the color attribute to\r\n * @param color - The color to add to the geometry\r\n */\r\nexport const addColorAttribute = (\r\n  geometry: BufferGeometry,\r\n  color: Color\r\n): void => {\r\n  const vertexCount = geometry.attributes.position.count;\r\n  const colorArray = new Float32Array(vertexCount * 3);\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    colorArray[i * 3] = color.r;\r\n    colorArray[i * 3 + 1] = color.g;\r\n    colorArray[i * 3 + 2] = color.b;\r\n  }\r\n  geometry.setAttribute('color', new Float32BufferAttribute(colorArray, 3));\r\n};\r\n\r\n/**\r\n * Create actual dashed geometry with gaps by making multiple small tube segments\r\n * @param curve - The curve to create a dashed geometry from\r\n * @param radius - The radius of the tube\r\n * @param color - The color of the tube\r\n * @param dashArray - The dash array [dashSize, gapSize]\r\n * @returns A BufferGeometry with a dashed appearance\r\n */\r\nexport const createDashedGeometry = (\r\n  curve: Curve<Vector3>,\r\n  radius: number,\r\n  color: Color,\r\n  dashArray: [number, number] = [3, 1]\r\n): BufferGeometry => {\r\n  const [dashSize, gapSize] = dashArray;\r\n  const totalSize = dashSize + gapSize;\r\n  const curveLength = curve.getLength();\r\n\r\n  // Calculate number of dashes based on curve length\r\n  const numDashes = Math.max(3, Math.floor(curveLength / totalSize));\r\n  const segments: BufferGeometry[] = [];\r\n\r\n  for (let i = 0; i < numDashes; i++) {\r\n    const startT = i / numDashes;\r\n    const endT = startT + dashSize / totalSize / numDashes;\r\n\r\n    if (endT > startT && startT < 1) {\r\n      // Create points for this dash segment\r\n      const points = [];\r\n      const segmentSteps = Math.max(3, Math.floor(8 * (endT - startT))); // More points for longer segments\r\n\r\n      for (let j = 0; j <= segmentSteps; j++) {\r\n        const t = startT + (endT - startT) * (j / segmentSteps);\r\n        if (t <= 1) {\r\n          points.push(curve.getPointAt(t));\r\n        }\r\n      }\r\n\r\n      if (points.length >= 2) {\r\n        // Create a curve from these points\r\n        const segmentCurve = new CatmullRomCurve3(points);\r\n        const segmentGeometry = new TubeGeometry(\r\n          segmentCurve,\r\n          Math.max(2, points.length - 1),\r\n          radius,\r\n          5,\r\n          false\r\n        );\r\n\r\n        // Add color to this segment\r\n        addColorAttribute(segmentGeometry, color);\r\n        segments.push(segmentGeometry);\r\n      }\r\n    }\r\n  }\r\n\r\n  return segments.length > 0\r\n    ? mergeBufferGeometries(segments)\r\n    : new BufferGeometry();\r\n};\r\n","import type { SizingStrategy, SizingStrategyInputs } from './types';\r\n\r\nexport function attributeSizing({\r\n  graph,\r\n  attribute,\r\n  defaultSize\r\n}: SizingStrategyInputs): SizingStrategy {\r\n  const map = new Map();\r\n\r\n  if (attribute) {\r\n    graph.forEachNode((id, node) => {\r\n      const size = node.data?.[attribute];\r\n      if (isNaN(size)) {\r\n        console.warn(`Attribute ${size} is not a number for node ${node.id}`);\r\n      }\r\n\r\n      map.set(id, size || 0);\r\n    });\r\n  } else {\r\n    console.warn('Attribute sizing configured but no attribute provided');\r\n  }\r\n\r\n  return {\r\n    getSizeForNode: (nodeId: string) => {\r\n      if (!attribute || !map) {\r\n        return defaultSize;\r\n      }\r\n\r\n      return map.get(nodeId);\r\n    }\r\n  };\r\n}\r\n","import { degreeCentrality } from 'graphology-metrics/centrality/degree.js';\r\n\r\nimport type { SizingStrategy, SizingStrategyInputs } from './types';\r\n\r\nexport function centralitySizing({\r\n  graph\r\n}: SizingStrategyInputs): SizingStrategy {\r\n  const ranks = degreeCentrality(graph);\r\n\r\n  return {\r\n    ranks,\r\n    getSizeForNode: (nodeID: string) => ranks[nodeID] * 20\r\n  };\r\n}\r\n","import pagerank from 'graphology-metrics/centrality/pagerank.js';\r\n\r\nimport type { SizingStrategy, SizingStrategyInputs } from './types';\r\n\r\nexport function pageRankSizing({\r\n  graph\r\n}: SizingStrategyInputs): SizingStrategy {\r\n  const ranks = pagerank(graph);\r\n\r\n  return {\r\n    ranks,\r\n    getSizeForNode: (nodeID: string) => ranks[nodeID] * 80\r\n  };\r\n}\r\n","import { scaleLinear } from 'd3-scale';\r\n\r\nimport { attributeSizing } from './attribute';\r\nimport { centralitySizing } from './centrality';\r\nimport { pageRankSizing } from './pageRank';\r\nimport type { SizingStrategyInputs } from './types';\r\n\r\nexport type SizingType =\r\n  | 'none'\r\n  | 'pagerank'\r\n  | 'centrality'\r\n  | 'attribute'\r\n  | 'default';\r\n\r\nexport interface NodeSizeProviderInputs extends SizingStrategyInputs {\r\n  /**\r\n   * The sizing strategy to use.\r\n   */\r\n  type: SizingType;\r\n}\r\n\r\nconst providers = {\r\n  pagerank: pageRankSizing,\r\n  centrality: centralitySizing,\r\n  attribute: attributeSizing,\r\n  none: ({ defaultSize }: SizingStrategyInputs) => ({\r\n    getSizeForNode: (_id: string) => defaultSize\r\n  })\r\n};\r\n\r\nexport function nodeSizeProvider({ type, ...rest }: NodeSizeProviderInputs) {\r\n  const provider = providers[type]?.(rest);\r\n  if (!provider && type !== 'default') {\r\n    throw new Error(`Unknown sizing strategy: ${type}`);\r\n  }\r\n\r\n  const { graph, minSize, maxSize } = rest;\r\n  const sizes = new Map();\r\n  let min;\r\n  let max;\r\n\r\n  graph.forEachNode((id, node) => {\r\n    let size;\r\n    if (type === 'default') {\r\n      size = node.size || rest.defaultSize;\r\n    } else {\r\n      size = provider.getSizeForNode(id);\r\n    }\r\n\r\n    if (min === undefined || size < min) {\r\n      min = size;\r\n    }\r\n\r\n    if (max === undefined || size > max) {\r\n      max = size;\r\n    }\r\n\r\n    sizes.set(id, size);\r\n  });\r\n\r\n  // Relatively scale the sizes\r\n  if (type !== 'none') {\r\n    const scale = scaleLinear()\r\n      .domain([min, max])\r\n      .rangeRound([minSize, maxSize]);\r\n\r\n    for (const [nodeId, size] of sizes) {\r\n      sizes.set(nodeId, scale(size));\r\n    }\r\n  }\r\n\r\n  return sizes;\r\n}\r\n","import type { PerspectiveCamera } from 'three';\r\n\r\nimport type { EdgeLabelPosition } from '../symbols';\r\n\r\nexport type LabelVisibilityType = 'all' | 'auto' | 'none' | 'nodes' | 'edges';\r\n\r\ninterface CalcLabelVisibilityArgs {\r\n  nodeCount: number;\r\n  nodePosition?: { x: number; y: number; z: number };\r\n  labelType: LabelVisibilityType;\r\n  camera?: PerspectiveCamera;\r\n}\r\n\r\nexport function calcLabelVisibility({\r\n  nodePosition,\r\n  labelType,\r\n  camera\r\n}: CalcLabelVisibilityArgs) {\r\n  return (shape: 'node' | 'edge', size: number) => {\r\n    const isAlwaysVisible =\r\n      labelType === 'all' ||\r\n      (labelType === 'nodes' && shape === 'node') ||\r\n      (labelType === 'edges' && shape === 'edge');\r\n\r\n    if (\r\n      !isAlwaysVisible &&\r\n      camera &&\r\n      nodePosition &&\r\n      camera?.position?.z / camera?.zoom - nodePosition?.z > 6000\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (isAlwaysVisible) {\r\n      return true;\r\n    } else if (labelType === 'auto' && shape === 'node') {\r\n      if (size > 7) {\r\n        return true;\r\n      } else if (\r\n        camera &&\r\n        nodePosition &&\r\n        camera.position.z / camera.zoom - nodePosition.z < 3000\r\n      ) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n}\r\n\r\nexport function getLabelOffsetByType(\r\n  offset: number,\r\n  position: EdgeLabelPosition\r\n): number {\r\n  switch (position) {\r\n    case 'above':\r\n      return offset;\r\n    case 'below':\r\n      return -offset;\r\n    case 'inline':\r\n    case 'natural':\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\nexport const isServerRender = typeof window === 'undefined';\r\n","import type Graph from 'graphology';\r\n\r\nimport type { LayoutStrategy } from '../layout';\r\nimport type { SizingType } from '../sizing';\r\nimport { nodeSizeProvider } from '../sizing';\r\nimport type {\r\n  GraphEdge,\r\n  GraphNode,\r\n  InternalGraphEdge,\r\n  InternalGraphNode\r\n} from '../types';\r\nimport type { LabelVisibilityType } from './visibility';\r\nimport { calcLabelVisibility } from './visibility';\r\n\r\n/**\r\n * Initialize the graph with the nodes/edges.\r\n */\r\nexport function buildGraph(\r\n  graph: Graph,\r\n  nodes: GraphNode[],\r\n  edges: GraphEdge[]\r\n) {\r\n  // TODO: We probably want to make this\r\n  // smarter and only add/remove nodes\r\n  graph.clear();\r\n\r\n  const addedNodes = new Set<string>();\r\n\r\n  for (const node of nodes) {\r\n    try {\r\n      if (!addedNodes.has(node.id)) {\r\n        graph.addNode(node.id, node);\r\n        addedNodes.add(node.id);\r\n      }\r\n    } catch (e) {\r\n      console.error(`[Graph] Error adding node '${node.id}`, e);\r\n    }\r\n  }\r\n\r\n  for (const edge of edges) {\r\n    if (!addedNodes.has(edge.source) || !addedNodes.has(edge.target)) {\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      graph.addEdge(edge.source, edge.target, edge);\r\n    } catch (e) {\r\n      console.error(\r\n        `[Graph] Error adding edge '${edge.source} -> ${edge.target}`,\r\n        e\r\n      );\r\n    }\r\n  }\r\n\r\n  return graph;\r\n}\r\n\r\ninterface TransformGraphInput {\r\n  graph: Graph;\r\n  layout: LayoutStrategy;\r\n  sizingType?: SizingType;\r\n  labelType?: LabelVisibilityType;\r\n  sizingAttribute?: string;\r\n  minNodeSize?: number;\r\n  maxNodeSize?: number;\r\n  defaultNodeSize?: number;\r\n  clusterAttribute?: string;\r\n}\r\n\r\n/**\r\n * Transform the graph into a format that is easier to work with.\r\n */\r\nexport function transformGraph({\r\n  graph,\r\n  layout,\r\n  sizingType,\r\n  labelType,\r\n  sizingAttribute,\r\n  defaultNodeSize,\r\n  minNodeSize,\r\n  maxNodeSize,\r\n  clusterAttribute\r\n}: TransformGraphInput) {\r\n  const nodes: InternalGraphNode[] = [];\r\n  const edges: InternalGraphEdge[] = [];\r\n  const map = new Map<string, InternalGraphNode>();\r\n\r\n  const sizes = nodeSizeProvider({\r\n    graph,\r\n    type: sizingType,\r\n    attribute: sizingAttribute,\r\n    minSize: minNodeSize,\r\n    maxSize: maxNodeSize,\r\n    defaultSize: defaultNodeSize\r\n  });\r\n\r\n  const nodeCount = graph.nodes().length;\r\n  const checkVisibility = calcLabelVisibility({ nodeCount, labelType });\r\n\r\n  graph.forEachNode((id, node) => {\r\n    const position = layout.getNodePosition(id);\r\n    const { data, fill, icon, label, size, ...rest } = node;\r\n    const nodeSize = sizes.get(node.id);\r\n    const labelVisible = checkVisibility('node', nodeSize);\r\n\r\n    const nodeLinks = graph.inboundNeighbors(node.id) || [];\r\n    const parents = nodeLinks.map(n => graph.getNodeAttributes(n));\r\n\r\n    const n: InternalGraphNode = {\r\n      ...(node as any),\r\n      size: nodeSize,\r\n      labelVisible,\r\n      label,\r\n      icon,\r\n      fill,\r\n      cluster: clusterAttribute ? data[clusterAttribute] : undefined,\r\n      parents,\r\n      data: {\r\n        ...rest,\r\n        ...(data ?? {})\r\n      },\r\n      position: {\r\n        ...position,\r\n        x: position.x || 0,\r\n        y: position.y || 0,\r\n        z: position.z || 1\r\n      }\r\n    };\r\n\r\n    map.set(node.id, n);\r\n    nodes.push(n);\r\n  });\r\n\r\n  graph.forEachEdge((_id, link) => {\r\n    const from = map.get(link.source);\r\n    const to = map.get(link.target);\r\n\r\n    if (from && to) {\r\n      const { data, id, label, size, ...rest } = link;\r\n      const labelVisible = checkVisibility('edge', size);\r\n\r\n      // TODO: Fix type\r\n      edges.push({\r\n        ...link,\r\n        id,\r\n        label,\r\n        labelVisible,\r\n        size,\r\n        data: {\r\n          ...rest,\r\n          id,\r\n          ...(data || {})\r\n        }\r\n      } as any);\r\n    }\r\n  });\r\n\r\n  return {\r\n    nodes,\r\n    edges\r\n  };\r\n}\r\n","import type Graph from 'graphology';\r\nimport { bidirectional } from 'graphology-shortest-path';\r\n\r\nexport function findPath(graph: Graph, source: string, target: string) {\r\n  return bidirectional(graph, source, target);\r\n}\r\n","import type { EdgeSubLabelPosition } from 'symbols/Edge';\r\nimport type { Curve } from 'three';\r\nimport {\r\n  CatmullRomCurve3,\r\n  LineCurve3,\r\n  QuadraticBezierCurve3,\r\n  Vector3\r\n} from 'three';\r\n\r\nimport type { InternalGraphNode, InternalVector3 } from '../types';\r\n\r\nconst MULTI_EDGE_OFFSET_FACTOR = 0.7;\r\n\r\n/**\r\n * Get the midpoint given two points.\r\n */\r\nexport function getMidPoint(\r\n  from: InternalVector3,\r\n  to: InternalVector3,\r\n  offset = 0\r\n) {\r\n  const fromVector = new Vector3(from.x, from.y || 0, from.z || 0);\r\n  const toVector = new Vector3(to.x, to.y || 0, to.z || 0);\r\n  const midVector = new Vector3()\r\n    .addVectors(fromVector, toVector)\r\n    .divideScalar(2);\r\n\r\n  return midVector.setLength(midVector.length() + offset);\r\n}\r\n\r\n/**\r\n * Calculate the center for a quadratic bezier curve.\r\n *\r\n * 1) Find the point halfway between the start and end points of the desired curve\r\n * 2) Find the vector pependicular to that point\r\n * 3) Find the point 1/4 the distance between start and end along that vector.\r\n */\r\nexport function getCurvePoints(\r\n  from: Vector3,\r\n  to: Vector3,\r\n  offset = -1\r\n): [Vector3, Vector3, Vector3] {\r\n  const fromVector = from.clone();\r\n  const toVector = to.clone();\r\n  const v = new Vector3().subVectors(toVector, fromVector);\r\n  const vlen = v.length();\r\n  const vn = v.clone().normalize();\r\n  const vv = new Vector3().subVectors(toVector, fromVector).divideScalar(2);\r\n  const k = Math.abs(vn.x) % 1;\r\n  const b = new Vector3(-vn.y, vn.x - k * vn.z, k * vn.y).normalize();\r\n  const vm = new Vector3()\r\n    .add(fromVector)\r\n    .add(vv)\r\n    .add(b.multiplyScalar(vlen / 4).multiplyScalar(offset));\r\n\r\n  return [from, vm, to];\r\n}\r\n\r\n/**\r\n * Get the curve given two points.\r\n */\r\nexport function getCurve(\r\n  from: Vector3,\r\n  fromOffset: number,\r\n  to: Vector3,\r\n  toOffset: number,\r\n  curved: boolean,\r\n  curveOffset?: number\r\n): Curve<Vector3> {\r\n  const offsetFrom = getPointBetween(from, to, fromOffset);\r\n  const offsetTo = getPointBetween(to, from, toOffset);\r\n  return curved\r\n    ? new QuadraticBezierCurve3(\r\n        ...getCurvePoints(offsetFrom, offsetTo, curveOffset)\r\n      )\r\n    : new LineCurve3(offsetFrom, offsetTo);\r\n}\r\n\r\n/**\r\n * Get the curve for a self-loop.\r\n */\r\nexport function getSelfLoopCurve(from: InternalGraphNode) {\r\n  const nodePosition = getVector(from);\r\n  const loopRadius = from.size;\r\n  const angle = Math.PI / 2; // 90 degrees on top of the node\r\n\r\n  const loopCenter = nodePosition\r\n    .clone()\r\n    .add(\r\n      new Vector3(\r\n        loopRadius * Math.cos(angle),\r\n        loopRadius * 1.3 * Math.sin(angle),\r\n        0\r\n      )\r\n    );\r\n\r\n  // Create selfLoopCurve\r\n  const numPoints = 10; // Use more points for smoother curve\r\n  const points: Vector3[] = [];\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    const theta = (i / numPoints) * 2 * Math.PI;\r\n    points.push(\r\n      loopCenter\r\n        .clone()\r\n        .add(\r\n          new Vector3(\r\n            loopRadius * Math.cos(theta),\r\n            loopRadius * Math.sin(theta),\r\n            0\r\n          )\r\n        )\r\n    );\r\n  }\r\n  const selfLoopCurve = new CatmullRomCurve3(points, true);\r\n\r\n  return selfLoopCurve;\r\n}\r\n\r\n/**\r\n * Create a threejs vector for a node.\r\n */\r\nexport function getVector(node: InternalGraphNode): Vector3 {\r\n  return new Vector3(node.position.x, node.position.y, node.position.z || 0);\r\n}\r\n\r\n/**\r\n * Get the point between two vectors.\r\n */\r\nfunction getPointBetween(from: Vector3, to: Vector3, offset: number): Vector3 {\r\n  const distance = from.distanceTo(to);\r\n  return from.clone().add(\r\n    to\r\n      .clone()\r\n      .sub(from)\r\n      .multiplyScalar(offset / distance)\r\n  );\r\n}\r\n\r\n/**\r\n * Given a node and a new vector set, update the node model.\r\n */\r\nexport function updateNodePosition(node: InternalGraphNode, offset: Vector3) {\r\n  return {\r\n    ...node,\r\n    position: {\r\n      ...node.position,\r\n      x: node.position.x + offset.x,\r\n      y: node.position.y + offset.y,\r\n      z: node.position.z + offset.z\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate the curve offset for an edge.\r\n * This is used to offset edges that are parallel to each other (same source and same target).\r\n * This will return a curveOffset of null if the edge is not parallel to any other edges.\r\n */\r\nexport function calculateEdgeCurveOffset({ edge, edges, curved }) {\r\n  let updatedCurved = curved;\r\n  let curveOffset: number;\r\n\r\n  const parallelEdges = edges\r\n    .filter(e => e.target === edge.target && e.source === edge.source)\r\n    .map(e => e.id);\r\n\r\n  if (parallelEdges.length > 1) {\r\n    updatedCurved = true;\r\n    const edgeIndex = parallelEdges.indexOf(edge.id);\r\n\r\n    // Progressive distribution with unique magnitude for each edge\r\n    // This prevents overlapping by ensuring each edge has sufficient separation\r\n    const offsetMultiplier = edgeIndex === 0 ? 1 : 1 + edgeIndex * 0.8;\r\n    const side = edgeIndex % 2 === 0 ? 1 : -1;\r\n    const magnitude = MULTI_EDGE_OFFSET_FACTOR * offsetMultiplier;\r\n    curveOffset = side * magnitude;\r\n  }\r\n\r\n  if (edge.data?.isAggregated && edges.length > 1) {\r\n    const edgeIndex = parallelEdges.indexOf(edge.id);\r\n    return {\r\n      curved: true,\r\n      curveOffset:\r\n        edgeIndex === 0 ? MULTI_EDGE_OFFSET_FACTOR : -MULTI_EDGE_OFFSET_FACTOR\r\n    };\r\n  }\r\n\r\n  return { curved: updatedCurved, curveOffset };\r\n}\r\n\r\n/**\r\n * Calculate the offset position for a subLabel based on edge orientation and placement preference\r\n *\r\n * @param fromPosition - Position of the source node\r\n * @param toPosition - Position of the target node\r\n * @param subLabelPlacement - Whether to place the subLabel 'above' or 'below' the edge\r\n * @returns Object with x, y offset values for positioning the subLabel perpendicular to the edge\r\n *\r\n * The function calculates a perpendicular offset from the edge line, with the direction\r\n * determined by both the subLabelPlacement ('above' or 'below') and the edge direction.\r\n * The perpendicular angle is calculated differently based on whether the edge is going\r\n * left-to-right or right-to-left to maintain consistent 'above'/'below' positioning.\r\n */\r\nexport function calculateSubLabelOffset(\r\n  fromPosition: { x: number; y: number },\r\n  toPosition: { x: number; y: number },\r\n  subLabelPlacement?: EdgeSubLabelPosition\r\n): { x: number; y: number; z: number } {\r\n  // Calculate direction vector between nodes\r\n  const dx = toPosition.x - fromPosition.x;\r\n  const dy = toPosition.y - fromPosition.y;\r\n\r\n  // Get angle of the edge\r\n  const angle = Math.atan2(dy, dx);\r\n\r\n  // Calculate perpendicular angle based on edge direction and subLabelPlacement\r\n  const perpAngle =\r\n    subLabelPlacement === 'above'\r\n      ? dx >= 0\r\n        ? angle + Math.PI / 2\r\n        : angle - Math.PI / 2\r\n      : dx >= 0\r\n        ? angle - Math.PI / 2\r\n        : angle + Math.PI / 2;\r\n\r\n  // Offset distance for subLabel\r\n  const offsetDistance = 7;\r\n\r\n  // Calculate offset using perpendicular angle\r\n  const offsetX = Math.cos(perpAngle) * offsetDistance;\r\n  const offsetY = Math.sin(perpAngle) * offsetDistance;\r\n\r\n  return { x: offsetX, y: offsetY, z: 0 };\r\n}\r\n","export interface TextDimensions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface TextMeasurementOptions {\r\n  text: string;\r\n  fontSize: number;\r\n  fontWeight?: number;\r\n  fontFamily?: string;\r\n}\r\n\r\n// Cache to avoid repeated measurements\r\nconst measurementCache = new Map<string, TextDimensions>();\r\n\r\n// Reusable canvas context for measurements\r\nlet canvasContext: CanvasRenderingContext2D | null = null;\r\n\r\n/**\r\n * Get or create a canvas context for text measurements.\r\n */\r\nfunction getCanvasContext(): CanvasRenderingContext2D {\r\n  if (!canvasContext) {\r\n    const canvas = document.createElement('canvas');\r\n    canvasContext = canvas.getContext('2d');\r\n\r\n    if (!canvasContext) {\r\n      throw new Error('Failed to create canvas context for text measurement');\r\n    }\r\n  }\r\n\r\n  return canvasContext;\r\n}\r\n\r\n/**\r\n * Generate a cache key from measurement options.\r\n */\r\nfunction getCacheKey(options: TextMeasurementOptions): string {\r\n  const {\r\n    text,\r\n    fontSize,\r\n    fontWeight = 400,\r\n    fontFamily = 'sans-serif'\r\n  } = options;\r\n  return `${text}|${fontSize}|${fontWeight}|${fontFamily}`;\r\n}\r\n\r\n/**\r\n * Measure text dimensions using Canvas API.\r\n * Results are cached for performance.\r\n *\r\n * @param options - Text measurement options\r\n * @returns Text dimensions (width and height)\r\n */\r\nexport function measureText(options: TextMeasurementOptions): TextDimensions {\r\n  const cacheKey = getCacheKey(options);\r\n\r\n  // Return cached result if available\r\n  const cached = measurementCache.get(cacheKey);\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const {\r\n    text,\r\n    fontSize,\r\n    fontWeight = 400,\r\n    fontFamily = 'sans-serif'\r\n  } = options;\r\n\r\n  try {\r\n    const context = getCanvasContext();\r\n\r\n    // Set font properties\r\n    context.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\r\n\r\n    // Measure text\r\n    const metrics = context.measureText(text);\r\n\r\n    // Calculate dimensions\r\n    const dimensions: TextDimensions = {\r\n      width: metrics.width,\r\n      // Use actual bounding box height if available, otherwise estimate from font size\r\n      height:\r\n        metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent ||\r\n        fontSize * 1.2\r\n    };\r\n\r\n    // Cache the result\r\n    measurementCache.set(cacheKey, dimensions);\r\n\r\n    return dimensions;\r\n  } catch (error) {\r\n    console.warn('Failed to measure text, falling back to estimation:', error);\r\n\r\n    // Fallback to estimation if measurement fails\r\n    const fallback: TextDimensions = {\r\n      width: text.length * fontSize * 0.6,\r\n      height: fontSize * 1.2\r\n    };\r\n\r\n    return fallback;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear the measurement cache.\r\n * Useful for testing or memory management.\r\n */\r\nexport function clearMeasurementCache(): void {\r\n  measurementCache.clear();\r\n}\r\n\r\n/**\r\n * Get the current cache size.\r\n */\r\nexport function getMeasurementCacheSize(): number {\r\n  return measurementCache.size;\r\n}\r\n","import Graph from 'graphology';\r\nimport type { FC, ReactNode } from 'react';\r\nimport { createContext, useContext } from 'react';\r\nimport React from 'react';\r\nimport type { BufferGeometry, Mesh } from 'three';\r\nimport { Vector3 } from 'three';\r\nimport type { StoreApi } from 'zustand';\r\nimport { create, useStore as useZustandStore } from 'zustand';\r\nimport { useShallow } from 'zustand/shallow';\r\n\r\nimport type { Theme } from './themes';\r\nimport type {\r\n  InternalGraphEdge,\r\n  InternalGraphNode,\r\n  InternalGraphPosition\r\n} from './types';\r\nimport type { CenterPositionVector, ClusterGroup } from './utils';\r\nimport { getLayoutCenter, getVector, updateNodePosition } from './utils';\r\nimport { isServerRender } from './utils/visibility';\r\n\r\nexport type DragReferences = {\r\n  [key: string]: InternalGraphNode;\r\n};\r\n\r\nexport interface GraphState {\r\n  nodes: InternalGraphNode[];\r\n  edges: InternalGraphEdge[];\r\n  graph: Graph;\r\n  clusters: Map<string, ClusterGroup>;\r\n  collapsedNodeIds?: string[];\r\n  centerPosition?: CenterPositionVector;\r\n  actives?: string[];\r\n  selections?: string[];\r\n  // The node that is currently hovered, used to disable cluster dragging\r\n  hoveredNodeId?: string;\r\n  // The edges that are currently hovered over, required for cases when animation is disabled\r\n  hoveredEdgeIds?: string[];\r\n  edgeContextMenus?: Set<string>;\r\n  setEdgeContextMenus: (edges: Set<string>) => void;\r\n  edgeMeshes: Array<Mesh<BufferGeometry>>;\r\n  setEdgeMeshes: (edgeMeshes: Array<Mesh<BufferGeometry>>) => void;\r\n  draggingIds?: string[];\r\n  drags?: DragReferences;\r\n  panning?: boolean;\r\n  theme: Theme;\r\n  setTheme: (theme: Theme) => void;\r\n  setClusters: (clusters: Map<string, ClusterGroup>) => void;\r\n  setPanning: (panning: boolean) => void;\r\n  setDrags: (drags: DragReferences) => void;\r\n  addDraggingId: (id: string) => void;\r\n  removeDraggingId: (id: string) => void;\r\n  setActives: (actives: string[]) => void;\r\n  setSelections: (selections: string[]) => void;\r\n  setHoveredNodeId: (hoveredNodeId: string | null) => void;\r\n  setHoveredEdgeIds: (hoveredEdgeIds: string[] | null) => void;\r\n  setNodes: (nodes: InternalGraphNode[]) => void;\r\n  setEdges: (edges: InternalGraphEdge[]) => void;\r\n  setNodePosition: (id: string, position: InternalGraphPosition) => void;\r\n  setCollapsedNodeIds: (nodeIds: string[]) => void;\r\n  canvasRef: HTMLCanvasElement | null;\r\n  setClusterPosition: (id: string, position: CenterPositionVector) => void;\r\n}\r\n\r\n// Create a store factory function\r\nexport const createStore = ({\r\n  actives = [],\r\n  selections = [],\r\n  collapsedNodeIds = [],\r\n  theme,\r\n  canvasRef = null\r\n}: Partial<GraphState>) =>\r\n  create<GraphState>(set => ({\r\n    theme: {\r\n      ...theme,\r\n      edge: {\r\n        ...theme?.edge,\r\n        label: {\r\n          ...theme?.edge?.label,\r\n          fontSize: theme?.edge?.label?.fontSize ?? 6\r\n        }\r\n      }\r\n    },\r\n    edges: [],\r\n    nodes: [],\r\n    collapsedNodeIds,\r\n    clusters: new Map(),\r\n    panning: false,\r\n    draggingIds: [],\r\n    actives,\r\n    hoveredEdgeIds: [],\r\n    edgeContextMenus: new Set(),\r\n    edgeMeshes: [],\r\n    selections,\r\n    hoveredNodeId: null,\r\n    drags: {},\r\n    graph: new Graph({ multi: true }),\r\n    setTheme: theme => set(state => ({ ...state, theme })),\r\n    setClusters: clusters => set(state => ({ ...state, clusters })),\r\n    setEdgeContextMenus: edgeContextMenus =>\r\n      set(state => ({\r\n        ...state,\r\n        edgeContextMenus\r\n      })),\r\n    setEdgeMeshes: edgeMeshes => set(state => ({ ...state, edgeMeshes })),\r\n    setPanning: panning => set(state => ({ ...state, panning })),\r\n    setDrags: drags => set(state => ({ ...state, drags })),\r\n    addDraggingId: id =>\r\n      set(state => ({ ...state, draggingIds: [...state.draggingIds, id] })),\r\n    removeDraggingId: id =>\r\n      set(state => ({\r\n        ...state,\r\n        draggingIds: state.draggingIds.filter(drag => drag !== id)\r\n      })),\r\n    setActives: actives => set(state => ({ ...state, actives })),\r\n    setSelections: selections => set(state => ({ ...state, selections })),\r\n    setHoveredNodeId: hoveredNodeId =>\r\n      set(state => ({ ...state, hoveredNodeId })),\r\n    setHoveredEdgeIds: hoveredEdgeIds =>\r\n      set(state => ({ ...state, hoveredEdgeIds })),\r\n    setNodes: nodes =>\r\n      set(state => ({\r\n        ...state,\r\n        nodes,\r\n        centerPosition: getLayoutCenter(nodes)\r\n      })),\r\n    setEdges: edges => set(state => ({ ...state, edges })),\r\n    setNodePosition: (id, position) =>\r\n      set(state => {\r\n        const node = state.nodes.find(n => n.id === id);\r\n        const originalVector = getVector(node);\r\n        const newVector = new Vector3(position.x, position.y, position.z);\r\n        const offset = newVector.sub(originalVector);\r\n        const nodes = [...state.nodes];\r\n\r\n        if (state.selections?.includes(id)) {\r\n          state.selections?.forEach(id => {\r\n            const node = state.nodes.find(n => n.id === id);\r\n            // Selections can contain edges:\r\n            if (node) {\r\n              const nodeIndex = state.nodes.indexOf(node);\r\n              nodes[nodeIndex] = updateNodePosition(node, offset);\r\n            }\r\n          });\r\n        } else {\r\n          const nodeIndex = state.nodes.indexOf(node);\r\n          nodes[nodeIndex] = updateNodePosition(node, offset);\r\n        }\r\n\r\n        return {\r\n          ...state,\r\n          drags: {\r\n            ...state.drags,\r\n            [id]: node\r\n          },\r\n          nodes\r\n        };\r\n      }),\r\n    setCollapsedNodeIds: (nodeIds = []) =>\r\n      set(state => ({ ...state, collapsedNodeIds: nodeIds })),\r\n    canvasRef,\r\n    // Update the position of a cluster with nodes inside it\r\n    setClusterPosition: (id, position) =>\r\n      set(state => {\r\n        const clusters = new Map<string, any>(state.clusters);\r\n        const cluster = clusters.get(id);\r\n\r\n        if (cluster) {\r\n          // Calculate the offset between old and new position\r\n          const oldPos = cluster.position;\r\n          const offset = new Vector3(\r\n            position.x - oldPos.x,\r\n            position.y - oldPos.y,\r\n            position.z - (oldPos.z ?? 0)\r\n          );\r\n\r\n          // Update all nodes in the cluster\r\n          const nodes: InternalGraphNode[] = [...state.nodes];\r\n          const drags: DragReferences = { ...state.drags };\r\n          nodes.forEach((node, index) => {\r\n            if (node.cluster === id) {\r\n              nodes[index] = {\r\n                ...node,\r\n                position: {\r\n                  ...node.position,\r\n                  x: node.position.x + offset.x,\r\n                  y: node.position.y + offset.y,\r\n                  z: node.position.z + (offset.z ?? 0)\r\n                } as InternalGraphPosition\r\n              };\r\n              // Update node in drag reference\r\n              drags[node.id] = node;\r\n            }\r\n          });\r\n\r\n          const clusterNodes: InternalGraphNode[] = nodes.filter(\r\n            node => node.cluster === id\r\n          );\r\n          const newClusterPosition = getLayoutCenter(clusterNodes);\r\n          // Update cluster position\r\n          clusters.set(id, {\r\n            ...cluster,\r\n            position: newClusterPosition\r\n          });\r\n\r\n          return {\r\n            ...state,\r\n            drags: {\r\n              ...drags,\r\n              [id]: cluster\r\n            },\r\n            clusters,\r\n            nodes\r\n          };\r\n        }\r\n\r\n        return state;\r\n      })\r\n  }));\r\n\r\nconst defaultStore = createStore({});\r\nconst StoreContext = isServerRender\r\n  ? null\r\n  : createContext<StoreApi<GraphState>>(defaultStore);\r\n\r\nexport const Provider: FC<{\r\n  children: ReactNode;\r\n  store?: StoreApi<GraphState>;\r\n}> = ({ children, store = defaultStore }) => {\r\n  if (isServerRender) {\r\n    return children;\r\n  }\r\n\r\n  return React.createElement(StoreContext.Provider, { value: store }, children);\r\n};\r\n\r\nexport const useStore = <T>(selector: (state: GraphState) => T): T => {\r\n  const store = useContext(StoreContext);\r\n  // use the useShallow hook, which will return a stable reference (https://zustand.docs.pmnd.rs/migrations/migrating-to-v5)\r\n  return useZustandStore(store, useShallow(selector));\r\n};\r\n","import type CameraControls from 'camera-controls';\r\nimport { createContext, useContext } from 'react';\r\n\r\nexport interface CameraControlsContextProps {\r\n  /**\r\n   * The camera controls object.\r\n   */\r\n  controls: CameraControls | null;\r\n\r\n  /**\r\n   * A function that resets the camera controls.\r\n   * If the optional `animated` argument is true, the reset is animated.\r\n   */\r\n  resetControls: (animated?: boolean) => void;\r\n\r\n  /**\r\n   * A function that zooms in the camera.\r\n   */\r\n  zoomIn: () => void;\r\n\r\n  /**\r\n   * A function that zooms out the camera.\r\n   */\r\n  zoomOut: () => void;\r\n\r\n  /**\r\n   * A function that dollies in the camera.\r\n   */\r\n  dollyIn: (distance?: number) => void;\r\n\r\n  /**\r\n   * A function that dollies out the camera.\r\n   */\r\n  dollyOut: (distance?: number) => void;\r\n\r\n  /**\r\n   * A function that pans the camera to the left.\r\n   */\r\n  panLeft: () => void;\r\n\r\n  /**\r\n   * A function that pans the camera to the right.\r\n   */\r\n  panRight: () => void;\r\n\r\n  /**\r\n   * A function that pans the camera upwards.\r\n   */\r\n  panUp: () => void;\r\n\r\n  /**\r\n   * A function that pans the camera downwards.\r\n   */\r\n  panDown: () => void;\r\n\r\n  /**\r\n   * A function that freezes the camera.\r\n   */\r\n  freeze: () => void;\r\n\r\n  /**\r\n   * A function that unfreezes the camera.\r\n   */\r\n  unFreeze: () => void;\r\n}\r\n\r\nexport const CameraControlsContext = createContext<CameraControlsContextProps>({\r\n  controls: null,\r\n  resetControls: () => undefined,\r\n  zoomIn: () => undefined,\r\n  zoomOut: () => undefined,\r\n  dollyIn: () => undefined,\r\n  dollyOut: () => undefined,\r\n  panLeft: () => undefined,\r\n  panRight: () => undefined,\r\n  panUp: () => undefined,\r\n  panDown: () => undefined,\r\n  freeze: () => undefined,\r\n  unFreeze: () => undefined\r\n});\r\n\r\nexport const useCameraControls = () => {\r\n  const context = useContext(CameraControlsContext);\r\n\r\n  if (context === undefined) {\r\n    throw new Error(\r\n      '`useCameraControls` hook must be used within a `ControlsProvider` component'\r\n    );\r\n  }\r\n\r\n  return context;\r\n};\r\n","import { extend, useFrame, useThree } from '@react-three/fiber';\r\nimport ThreeCameraControls from 'camera-controls';\r\nimport * as holdEvent from 'hold-event';\r\nimport type { ReactNode, Ref } from 'react';\r\nimport React, {\r\n  forwardRef,\r\n  useCallback,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useMemo,\r\n  useRef,\r\n  useState\r\n} from 'react';\r\nimport {\r\n  Box3,\r\n  MathUtils,\r\n  Matrix4,\r\n  MOUSE,\r\n  Quaternion,\r\n  Raycaster,\r\n  Sphere,\r\n  Spherical,\r\n  Vector2,\r\n  Vector3,\r\n  Vector4\r\n} from 'three';\r\n\r\nimport { useStore } from '../store';\r\nimport { isServerRender } from '../utils/visibility';\r\nimport type { CameraControlsContextProps } from './useCameraControls';\r\nimport { CameraControlsContext } from './useCameraControls';\r\n\r\n// Install the camera controls\r\n// Use a subset for better three shaking\r\nThreeCameraControls.install({\r\n  THREE: {\r\n    MOUSE: MOUSE,\r\n    Vector2: Vector2,\r\n    Vector3: Vector3,\r\n    Vector4: Vector4,\r\n    Quaternion: Quaternion,\r\n    Matrix4: Matrix4,\r\n    Spherical: Spherical,\r\n    Box3: Box3,\r\n    Sphere: Sphere,\r\n    Raycaster: Raycaster,\r\n    MathUtils: {\r\n      DEG2RAD: MathUtils?.DEG2RAD,\r\n      clamp: MathUtils?.clamp\r\n    }\r\n  }\r\n});\r\n\r\n// Extend r3f with the new controls\r\nextend({ ThreeCameraControls });\r\n\r\nexport type CameraMode = 'pan' | 'rotate' | 'orbit' | 'orthographic';\r\n\r\nexport interface CameraControlsProps {\r\n  /**\r\n   * Mode of the camera.\r\n   */\r\n  mode?: CameraMode;\r\n\r\n  /**\r\n   * Children symbols.\r\n   */\r\n  children?: ReactNode;\r\n\r\n  /**\r\n   * Animate transitions to centering.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Whether the controls are enabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The maximum distance for the camera (perspective mode).\r\n   */\r\n  maxDistance?: number;\r\n\r\n  /**\r\n   * The minimum distance for the camera (perspective mode).\r\n   */\r\n  minDistance?: number;\r\n\r\n  /**\r\n   * The maximum zoom level for orthographic cameras.\r\n   */\r\n  maxZoom?: number;\r\n\r\n  /**\r\n   * The minimum zoom level for orthographic cameras.\r\n   */\r\n  minZoom?: number;\r\n}\r\n\r\nexport type CameraControlsRef = CameraControlsContextProps;\r\n\r\nexport const CameraControls = forwardRef<\r\n  CameraControlsRef,\r\n  CameraControlsProps\r\n>(\r\n  (\r\n    {\r\n      mode = 'rotate',\r\n      children,\r\n      animated,\r\n      disabled,\r\n      minDistance = 1000,\r\n      maxDistance = 50000,\r\n      minZoom = 1,\r\n      maxZoom = 100\r\n    },\r\n    ref: Ref<CameraControlsRef>\r\n  ) => {\r\n    const cameraRef = useRef<ThreeCameraControls | null>(null);\r\n    const camera = useThree(state => state.camera);\r\n    const gl = useThree(state => state.gl);\r\n    const isOrbiting = mode === 'orbit';\r\n    const setPanning = useStore(state => state.setPanning);\r\n    const isDragging = useStore(state => state.draggingIds.length > 0);\r\n    const cameraSpeedRef = useRef(0);\r\n    const [controlMounted, setControlMounted] = useState<boolean>(false);\r\n\r\n    useFrame((_state, delta) => {\r\n      if (cameraRef.current?.enabled) {\r\n        cameraRef.current?.update(delta);\r\n      }\r\n\r\n      if (isOrbiting) {\r\n        cameraRef.current.azimuthAngle += 20 * delta * MathUtils.DEG2RAD;\r\n      }\r\n    }, -1);\r\n\r\n    useEffect(() => () => cameraRef.current?.dispose(), []);\r\n\r\n    const zoomIn = useCallback(() => {\r\n      cameraRef.current?.zoom(camera.zoom / 2, animated);\r\n    }, [animated, camera.zoom]);\r\n\r\n    const zoomOut = useCallback(() => {\r\n      cameraRef.current?.zoom(-camera.zoom / 2, animated);\r\n    }, [animated, camera.zoom]);\r\n\r\n    const dollyIn = useCallback(\r\n      distance => {\r\n        cameraRef.current?.dolly(distance, animated);\r\n      },\r\n      [animated]\r\n    );\r\n\r\n    const dollyOut = useCallback(\r\n      distance => {\r\n        cameraRef.current?.dolly(distance, animated);\r\n      },\r\n      [animated]\r\n    );\r\n\r\n    const panRight = useCallback(\r\n      event => {\r\n        if (!isOrbiting) {\r\n          cameraRef.current?.truck(-0.03 * event.deltaTime, 0, animated);\r\n        }\r\n      },\r\n      [animated, isOrbiting]\r\n    );\r\n\r\n    const panLeft = useCallback(\r\n      event => {\r\n        if (!isOrbiting) {\r\n          cameraRef.current?.truck(0.03 * event.deltaTime, 0, animated);\r\n        }\r\n      },\r\n      [animated, isOrbiting]\r\n    );\r\n\r\n    const panUp = useCallback(\r\n      event => {\r\n        if (!isOrbiting) {\r\n          cameraRef.current?.truck(0, 0.03 * event.deltaTime, animated);\r\n        }\r\n      },\r\n      [animated, isOrbiting]\r\n    );\r\n\r\n    const panDown = useCallback(\r\n      event => {\r\n        if (!isOrbiting) {\r\n          cameraRef.current?.truck(0, -0.03 * event.deltaTime, animated);\r\n        }\r\n      },\r\n      [animated, isOrbiting]\r\n    );\r\n\r\n    const onKeyDown = useCallback(\r\n      event => {\r\n        if (event.code === 'Space') {\r\n          if (mode === 'rotate') {\r\n            cameraRef.current.mouseButtons.left =\r\n              ThreeCameraControls.ACTION.TRUCK;\r\n          } else {\r\n            cameraRef.current.mouseButtons.left =\r\n              ThreeCameraControls.ACTION.ROTATE;\r\n          }\r\n        }\r\n      },\r\n      [mode]\r\n    );\r\n\r\n    const onKeyUp = useCallback(\r\n      event => {\r\n        if (event.code === 'Space') {\r\n          if (mode === 'rotate') {\r\n            cameraRef.current.mouseButtons.left =\r\n              ThreeCameraControls.ACTION.ROTATE;\r\n          } else {\r\n            cameraRef.current.mouseButtons.left =\r\n              ThreeCameraControls.ACTION.TRUCK;\r\n          }\r\n        }\r\n      },\r\n      [mode]\r\n    );\r\n\r\n    const [keyControls, setKeyControls] = useState<{\r\n      leftKey: holdEvent.KeyboardKeyHold;\r\n      rightKey: holdEvent.KeyboardKeyHold;\r\n      upKey: holdEvent.KeyboardKeyHold;\r\n      downKey: holdEvent.KeyboardKeyHold;\r\n    } | null>(null);\r\n\r\n    useEffect(() => {\r\n      // Only initialize on client side\r\n      if (!isServerRender) {\r\n        setKeyControls({\r\n          leftKey: new holdEvent.KeyboardKeyHold('ArrowLeft', 100),\r\n          rightKey: new holdEvent.KeyboardKeyHold('ArrowRight', 100),\r\n          upKey: new holdEvent.KeyboardKeyHold('ArrowUp', 100),\r\n          downKey: new holdEvent.KeyboardKeyHold('ArrowDown', 100)\r\n        });\r\n      }\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n      if (!disabled && keyControls) {\r\n        keyControls.leftKey.addEventListener('holding', panLeft);\r\n        keyControls.rightKey.addEventListener('holding', panRight);\r\n        keyControls.upKey.addEventListener('holding', panUp);\r\n        keyControls.downKey.addEventListener('holding', panDown);\r\n\r\n        window.addEventListener('keydown', onKeyDown);\r\n        window.addEventListener('keyup', onKeyUp);\r\n      }\r\n\r\n      return () => {\r\n        if (keyControls) {\r\n          keyControls.leftKey.removeEventListener('holding', panLeft);\r\n          keyControls.rightKey.removeEventListener('holding', panRight);\r\n          keyControls.upKey.removeEventListener('holding', panUp);\r\n          keyControls.downKey.removeEventListener('holding', panDown);\r\n\r\n          window.removeEventListener('keydown', onKeyDown);\r\n          window.removeEventListener('keyup', onKeyUp);\r\n        }\r\n      };\r\n    }, [\r\n      disabled,\r\n      onKeyDown,\r\n      onKeyUp,\r\n      panDown,\r\n      panLeft,\r\n      panRight,\r\n      panUp,\r\n      keyControls\r\n    ]);\r\n\r\n    useEffect(() => {\r\n      const isOrthographic = mode === 'orthographic';\r\n\r\n      if (disabled) {\r\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.NONE;\r\n        cameraRef.current.mouseButtons.middle = ThreeCameraControls.ACTION.NONE;\r\n        cameraRef.current.mouseButtons.wheel = ThreeCameraControls.ACTION.NONE;\r\n      } else {\r\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.TRUCK;\r\n        cameraRef.current.mouseButtons.middle =\r\n          ThreeCameraControls.ACTION.TRUCK;\r\n        cameraRef.current.mouseButtons.wheel = isOrthographic\r\n          ? ThreeCameraControls.ACTION.ZOOM\r\n          : ThreeCameraControls.ACTION.DOLLY;\r\n      }\r\n\r\n      // For orthographic cameras, use dedicated zoom props\r\n      if (isOrthographic && cameraRef.current) {\r\n        cameraRef.current.maxZoom = maxZoom;\r\n        cameraRef.current.minZoom = minZoom;\r\n      }\r\n    }, [disabled, mode, minZoom, maxZoom]);\r\n\r\n    useEffect(() => {\r\n      const onControl = () => setPanning(true);\r\n      const onControlEnd = () => setPanning(false);\r\n\r\n      const ref = cameraRef.current;\r\n      if (ref) {\r\n        ref.addEventListener('control', onControl);\r\n        ref.addEventListener('controlend', onControlEnd);\r\n      }\r\n\r\n      return () => {\r\n        if (ref) {\r\n          ref.removeEventListener('control', onControl);\r\n          ref.removeEventListener('controlend', onControlEnd);\r\n        }\r\n      };\r\n    }, [cameraRef, setPanning]);\r\n\r\n    useEffect(() => {\r\n      // If a node is being dragged, disable the camera controls\r\n      if (isDragging) {\r\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.NONE;\r\n        cameraRef.current.touches.one = ThreeCameraControls.ACTION.NONE;\r\n      } else {\r\n        if (mode === 'rotate') {\r\n          cameraRef.current.mouseButtons.left =\r\n            ThreeCameraControls.ACTION.ROTATE;\r\n          cameraRef.current.touches.one =\r\n            ThreeCameraControls.ACTION.TOUCH_ROTATE;\r\n        } else {\r\n          cameraRef.current.touches.one =\r\n            ThreeCameraControls.ACTION.TOUCH_TRUCK;\r\n          cameraRef.current.mouseButtons.left =\r\n            ThreeCameraControls.ACTION.TRUCK;\r\n        }\r\n      }\r\n    }, [isDragging, mode]);\r\n\r\n    const values = useMemo(\r\n      () => ({\r\n        controls: cameraRef.current,\r\n        zoomIn: () => zoomIn(),\r\n        zoomOut: () => zoomOut(),\r\n        dollyIn: (distance = 1000) => dollyIn(distance),\r\n        dollyOut: (distance = -1000) => dollyOut(distance),\r\n        panLeft: (deltaTime = 100) => panLeft({ deltaTime }),\r\n        panRight: (deltaTime = 100) => panRight({ deltaTime }),\r\n        panDown: (deltaTime = 100) => panDown({ deltaTime }),\r\n        panUp: (deltaTime = 100) => panUp({ deltaTime }),\r\n        resetControls: (animated?: boolean) =>\r\n          cameraRef.current?.normalizeRotations().reset(animated),\r\n        freeze: () => {\r\n          // Save the current speed\r\n          if (cameraRef.current.truckSpeed) {\r\n            cameraSpeedRef.current = cameraRef.current.truckSpeed;\r\n          }\r\n          cameraRef.current.truckSpeed = 0;\r\n        },\r\n        unFreeze: () => (cameraRef.current.truckSpeed = cameraSpeedRef.current)\r\n      }),\r\n      // eslint-disable-next-line\r\n      [zoomIn, zoomOut, panLeft, panRight, panDown, panUp, cameraRef.current]\r\n    );\r\n\r\n    useImperativeHandle(ref, () => values);\r\n\r\n    return (\r\n      <CameraControlsContext.Provider value={values}>\r\n        <threeCameraControls\r\n          ref={controls => {\r\n            cameraRef.current = controls;\r\n            if (!controlMounted) {\r\n              // Update the state when the controls are mounted to notify about it component that using that controls\r\n              setControlMounted(true);\r\n            }\r\n          }}\r\n          args={[camera, gl.domElement]}\r\n          smoothTime={0.1}\r\n          minDistance={minDistance}\r\n          dollyToCursor\r\n          maxDistance={maxDistance}\r\n        />\r\n        {children}\r\n      </CameraControlsContext.Provider>\r\n    );\r\n  }\r\n);\r\n","import type { PerspectiveCamera } from 'three';\r\n\r\nimport type { InternalGraphPosition } from '../types';\r\n\r\n/**\r\n * Get the visible height at the z depth.\r\n * Ref: https://discourse.threejs.org/t/functions-to-calculate-the-visible-width-height-at-a-given-z-depth-from-a-perspective-camera/269\r\n */\r\nfunction visibleHeightAtZDepth(depth: number, camera: PerspectiveCamera) {\r\n  // compensate for cameras not positioned at z=0\r\n  const cameraOffset = camera.position.z;\r\n  if (depth < cameraOffset) depth -= cameraOffset;\r\n  else depth += cameraOffset;\r\n\r\n  // vertical fov in radians\r\n  const vFOV = ((camera.fov / camera.zoom) * Math.PI) / 180;\r\n\r\n  // Math.abs to ensure the result is always positive\r\n  return 2 * Math.tan(vFOV / 2) * Math.abs(depth);\r\n}\r\n\r\n/**\r\n * Get the visible width at the z depth.\r\n */\r\nfunction visibleWidthAtZDepth(depth: number, camera: PerspectiveCamera) {\r\n  const height = visibleHeightAtZDepth(depth, camera);\r\n  return height * camera.aspect;\r\n}\r\n\r\n/**\r\n * Returns whether the node is in view of the camera.\r\n */\r\nexport function isNodeInView(\r\n  camera: PerspectiveCamera,\r\n  nodePosition: InternalGraphPosition\r\n): boolean {\r\n  const visibleWidth = visibleWidthAtZDepth(1, camera);\r\n  const visibleHeight = visibleHeightAtZDepth(1, camera);\r\n\r\n  // The boundary coordinates of the area visible to the camera relative to the scene\r\n  const visibleArea = {\r\n    x0: camera?.position?.x - visibleWidth / 2,\r\n    x1: camera?.position?.x + visibleWidth / 2,\r\n    y0: camera?.position?.y - visibleHeight / 2,\r\n    y1: camera?.position?.y + visibleHeight / 2\r\n  };\r\n\r\n  return (\r\n    nodePosition?.x > visibleArea.x0 &&\r\n    nodePosition?.x < visibleArea.x1 &&\r\n    nodePosition?.y > visibleArea.y0 &&\r\n    nodePosition?.y < visibleArea.y1\r\n  );\r\n}\r\n\r\n/**\r\n * Get the closest axis to a given angle.\r\n */\r\nexport function getClosestAxis(angle: number, axes: number[]) {\r\n  return axes.reduce((prev, curr) =>\r\n    Math.abs(curr - (angle % Math.PI)) < Math.abs(prev - (angle % Math.PI))\r\n      ? curr\r\n      : prev\r\n  );\r\n}\r\n\r\n/**\r\n * Get how far an angle is from the closest 2D axis in radians.\r\n */\r\nexport function getDegreesToClosest2dAxis(\r\n  horizontalAngle: number,\r\n  verticalAngle: number\r\n) {\r\n  const closestHorizontalAxis = getClosestAxis(horizontalAngle, [0, Math.PI]);\r\n  const closestVerticalAxis = getClosestAxis(verticalAngle, [\r\n    Math.PI / 2,\r\n    (3 * Math.PI) / 2\r\n  ]);\r\n\r\n  return {\r\n    horizontalRotation: closestHorizontalAxis - (horizontalAngle % Math.PI),\r\n    verticalRotation: closestVerticalAxis - (verticalAngle % Math.PI)\r\n  };\r\n}\r\n","import type { GraphEdge, GraphNode } from '../types';\r\n\r\ninterface GetHiddenChildrenInput {\r\n  nodeId: string;\r\n  nodes: GraphNode[];\r\n  edges: GraphEdge[];\r\n  currentHiddenNodes: GraphNode[];\r\n  currentHiddenEdges: GraphEdge[];\r\n}\r\n\r\ninterface GetVisibleIdsInput {\r\n  collapsedIds: string[];\r\n  nodes: GraphNode[];\r\n  edges: GraphEdge[];\r\n}\r\n\r\ninterface GetExpandPathInput {\r\n  nodeId: string;\r\n  edges: GraphEdge[];\r\n  visibleEdgeIds: string[];\r\n}\r\n\r\n/**\r\n * Get the children of a node id that is hidden.\r\n */\r\nfunction getHiddenChildren({\r\n  nodeId,\r\n  nodes,\r\n  edges,\r\n  currentHiddenNodes,\r\n  currentHiddenEdges\r\n}: GetHiddenChildrenInput) {\r\n  const hiddenNodes: GraphNode[] = [];\r\n  const hiddenEdges: GraphEdge[] = [];\r\n  const curHiddenNodeIds = currentHiddenNodes.map(n => n.id);\r\n  const curHiddenEdgeIds = currentHiddenEdges.map(e => e.id);\r\n\r\n  const outboundEdges = edges.filter(l => l.source === nodeId);\r\n  const outboundEdgeNodeIds = outboundEdges.map(l => l.target);\r\n\r\n  hiddenEdges.push(...outboundEdges);\r\n  for (const outboundEdgeNodeId of outboundEdgeNodeIds) {\r\n    const incomingEdges = edges.filter(\r\n      l => l.target === outboundEdgeNodeId && l.source !== nodeId\r\n    );\r\n    let hideNode = false;\r\n\r\n    // Check to see if any other edge is coming into this node\r\n    if (incomingEdges.length === 0) {\r\n      hideNode = true;\r\n    } else if (\r\n      incomingEdges.length > 0 &&\r\n      !curHiddenNodeIds.includes(outboundEdgeNodeId)\r\n    ) {\r\n      // If all inbound links are hidden, hide this node as well\r\n      const inboundNodeLinkIds = incomingEdges.map(l => l.id);\r\n      if (inboundNodeLinkIds.every(i => curHiddenEdgeIds.includes(i))) {\r\n        hideNode = true;\r\n      }\r\n    }\r\n    if (hideNode) {\r\n      // Need to hide this node and any children of this node\r\n      const node = nodes.find(n => n.id === outboundEdgeNodeId);\r\n      if (node) {\r\n        hiddenNodes.push(node);\r\n      }\r\n      const nested = getHiddenChildren({\r\n        nodeId: outboundEdgeNodeId,\r\n        nodes,\r\n        edges,\r\n        currentHiddenEdges: hiddenEdges,\r\n        currentHiddenNodes: hiddenNodes\r\n      });\r\n      hiddenEdges.push(...nested.hiddenEdges);\r\n      hiddenNodes.push(...nested.hiddenNodes);\r\n    }\r\n  }\r\n\r\n  const uniqueEdges: GraphEdge[] = Object.values(\r\n    hiddenEdges.reduce(\r\n      (acc, next) => ({\r\n        ...acc,\r\n        [next.id]: next\r\n      }),\r\n      {}\r\n    )\r\n  );\r\n\r\n  const uniqueNodes: GraphNode[] = Object.values(\r\n    hiddenNodes.reduce(\r\n      (acc, next) => ({\r\n        ...acc,\r\n        [next.id]: next\r\n      }),\r\n      {}\r\n    )\r\n  );\r\n\r\n  return {\r\n    hiddenEdges: uniqueEdges,\r\n    hiddenNodes: uniqueNodes\r\n  };\r\n}\r\n\r\n/**\r\n * Get the visible nodes and edges given a collapsed set of ids.\r\n */\r\nexport const getVisibleEntities = ({\r\n  collapsedIds,\r\n  nodes,\r\n  edges\r\n}: GetVisibleIdsInput) => {\r\n  const curHiddenNodes = [];\r\n  const curHiddenEdges = [];\r\n\r\n  for (const collapsedId of collapsedIds) {\r\n    const { hiddenEdges, hiddenNodes } = getHiddenChildren({\r\n      nodeId: collapsedId,\r\n      nodes,\r\n      edges,\r\n      currentHiddenEdges: curHiddenEdges,\r\n      currentHiddenNodes: curHiddenNodes\r\n    });\r\n\r\n    curHiddenNodes.push(...hiddenNodes);\r\n    curHiddenEdges.push(...hiddenEdges);\r\n  }\r\n\r\n  const hiddenNodeIds = curHiddenNodes.map(n => n.id);\r\n  const hiddenEdgeIds = curHiddenEdges.map(e => e.id);\r\n  const visibleNodes = nodes.filter(n => !hiddenNodeIds.includes(n.id));\r\n  const visibleEdges = edges.filter(e => !hiddenEdgeIds.includes(e.id));\r\n\r\n  return {\r\n    visibleNodes,\r\n    visibleEdges\r\n  };\r\n};\r\n\r\n/**\r\n * Get the path to expand a node.\r\n */\r\nexport const getExpandPath = ({\r\n  nodeId,\r\n  edges,\r\n  visibleEdgeIds\r\n}: GetExpandPathInput) => {\r\n  const parentIds = [];\r\n  const inboundEdges = edges.filter(l => l.target === nodeId);\r\n  const inboundEdgeIds = inboundEdges.map(e => e.id);\r\n  const hasVisibleInboundEdge = inboundEdgeIds.some(id =>\r\n    visibleEdgeIds.includes(id)\r\n  );\r\n\r\n  if (hasVisibleInboundEdge) {\r\n    // If there is a visible edge to this node, that means the node is\r\n    // visible so no parents need to be expanded\r\n    return parentIds;\r\n  }\r\n\r\n  const inboundEdgeNodeIds = inboundEdges.map(l => l.source);\r\n  let addedParent = false;\r\n\r\n  for (const inboundNodeId of inboundEdgeNodeIds) {\r\n    if (!addedParent) {\r\n      // Only want to expand a single path to the node, so if there\r\n      // are multiple hidden incoming edges, only expand the first\r\n      // to reduce how many nodes are expanded to get to the node\r\n      parentIds.push(\r\n        ...[\r\n          inboundNodeId,\r\n          ...getExpandPath({ nodeId: inboundNodeId, edges, visibleEdgeIds })\r\n        ]\r\n      );\r\n      addedParent = true;\r\n    }\r\n  }\r\n\r\n  return parentIds;\r\n};\r\n","import { useCallback } from 'react';\r\n\r\nimport type { GraphEdge, GraphNode } from '../types';\r\nimport { getExpandPath, getVisibleEntities } from './utils';\r\n\r\nexport interface UseCollapseProps {\r\n  /**\r\n   * Current collapsed node ids.\r\n   */\r\n  collapsedNodeIds?: string[];\r\n\r\n  /**\r\n   * Node data.\r\n   */\r\n  nodes?: GraphNode[];\r\n\r\n  /**\r\n   * Edge data.\r\n   */\r\n  edges?: GraphEdge[];\r\n}\r\n\r\nexport interface CollpaseResult {\r\n  /**\r\n   * Determine if a node is currently collapsed\r\n   */\r\n  getIsCollapsed: (nodeId: string) => boolean;\r\n\r\n  /**\r\n   * Return a list of ids required to expand in order to view the provided node\r\n   */\r\n  getExpandPathIds: (nodeId: string) => string[];\r\n}\r\n\r\nexport const useCollapse = ({\r\n  collapsedNodeIds = [],\r\n  nodes = [],\r\n  edges = []\r\n}: UseCollapseProps): CollpaseResult => {\r\n  const getIsCollapsed = useCallback(\r\n    (nodeId: string) => {\r\n      const { visibleNodes } = getVisibleEntities({\r\n        nodes,\r\n        edges,\r\n        collapsedIds: collapsedNodeIds\r\n      });\r\n      const visibleNodeIds = visibleNodes.map(n => n.id);\r\n\r\n      return !visibleNodeIds.includes(nodeId);\r\n    },\r\n    [collapsedNodeIds, edges, nodes]\r\n  );\r\n\r\n  const getExpandPathIds = useCallback(\r\n    (nodeId: string) => {\r\n      const { visibleEdges } = getVisibleEntities({\r\n        nodes,\r\n        edges,\r\n        collapsedIds: collapsedNodeIds\r\n      });\r\n      const visibleEdgeIds = visibleEdges.map(e => e.id);\r\n\r\n      return getExpandPath({ nodeId, edges, visibleEdgeIds });\r\n    },\r\n    [collapsedNodeIds, edges, nodes]\r\n  );\r\n\r\n  return {\r\n    getIsCollapsed,\r\n    getExpandPathIds\r\n  };\r\n};\r\n","import { useThree } from '@react-three/fiber';\r\nimport { useCallback, useLayoutEffect, useRef, useState } from 'react';\r\nimport type { PerspectiveCamera } from 'three';\r\nimport { Box3, Vector3 } from 'three';\r\n\r\nimport { useCameraControls } from '../CameraControls/useCameraControls';\r\nimport {\r\n  getDegreesToClosest2dAxis,\r\n  isNodeInView\r\n} from '../CameraControls/utils';\r\nimport type { LayoutTypes } from '../layout/types';\r\nimport { useStore } from '../store';\r\nimport type { InternalGraphNode } from '../types';\r\nimport { getLayoutCenter } from '../utils/layout';\r\n\r\nconst PADDING = 50;\r\n\r\nexport interface CenterNodesParams {\r\n  animated?: boolean;\r\n  centerOnlyIfNodesNotInView?: boolean;\r\n}\r\n\r\nexport interface FitNodesParams {\r\n  animated?: boolean;\r\n  fitOnlyIfNodesNotInView?: boolean;\r\n}\r\n\r\nexport interface CenterGraphInput {\r\n  /**\r\n   * Whether the animate the transition or not.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Whether the center graph function is disabled or not.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The layout type of the graph used to determine rotation logic.\r\n   */\r\n  layoutType: LayoutTypes;\r\n}\r\n\r\nexport interface CenterGraphOutput {\r\n  /**\r\n   * Centers the graph on a specific node or list of nodes.\r\n   *\r\n   * @param nodes - An array of `InternalGraphNode` objects to center the graph on. If this parameter is omitted,\r\n   * the graph will be centered on all nodes.\r\n   *\r\n   * @param animated - A boolean flag that determines whether the centering action should be animated.\r\n   *\r\n   * @param centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\r\n   * only be centered if the nodes specified by `nodes` are not currently in view. If this\r\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\r\n   * specified by `nodes` are not currently visible in the viewport. If this parameter is\r\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\r\n   * are currently in view.\r\n   */\r\n  centerNodes: (nodes: InternalGraphNode[], opts: CenterNodesParams) => void;\r\n\r\n  /**\r\n   * Centers the graph on a specific node or list of nodes.\r\n   *\r\n   * @param nodeIds - An array of node IDs to center the graph on. If this parameter is omitted,\r\n   * the graph will be centered on all nodes.\r\n   *\r\n   * @param opts.centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\r\n   * only be centered if the nodes specified by `ids` are not currently in view. If this\r\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\r\n   * specified by `ids` are not currently in view. If this parameter is\r\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\r\n   * are currently in view.\r\n   */\r\n  centerNodesById: (nodeIds: string[], opts?: CenterNodesParams) => void;\r\n\r\n  /**\r\n   * Fit all the given nodes into view of the camera.\r\n   *\r\n   * @param nodeIds - An array of node IDs to fit the view on. If this parameter is omitted,\r\n   * the view will fit to all nodes.\r\n   *\r\n   * @param opts.fitOnlyIfNodesNotInView - A boolean flag that determines whether the view should\r\n   * only be fit if the nodes specified by `ids` are not currently in view. If this\r\n   * parameter is `true`, the view will only be fit if one or more of the nodes\r\n   * specified by `ids` are not currently visible in the viewport. If this parameter is\r\n   * `false` or omitted, the view will be fit regardless of whether the nodes\r\n   * are currently in view.\r\n   */\r\n  fitNodesInViewById: (nodeIds: string[], opts?: FitNodesParams) => void;\r\n\r\n  /**\r\n   * Whether the graph is centered or not.\r\n   */\r\n  isCentered?: boolean;\r\n}\r\n\r\nexport const useCenterGraph = ({\r\n  animated,\r\n  disabled,\r\n  layoutType\r\n}: CenterGraphInput): CenterGraphOutput => {\r\n  const nodes = useStore(state => state.nodes);\r\n  const [isCentered, setIsCentered] = useState<boolean>(false);\r\n  const invalidate = useThree(state => state.invalidate);\r\n  const { controls } = useCameraControls();\r\n  const camera = useThree(state => state.camera) as PerspectiveCamera;\r\n  const mounted = useRef<boolean>(false);\r\n\r\n  const centerNodes = useCallback(\r\n    async (nodes, opts?: CenterNodesParams) => {\r\n      const animated = opts?.animated !== undefined ? opts?.animated : true;\r\n      const centerOnlyIfNodesNotInView =\r\n        opts?.centerOnlyIfNodesNotInView !== undefined\r\n          ? opts?.centerOnlyIfNodesNotInView\r\n          : false;\r\n\r\n      if (\r\n        !mounted.current ||\r\n        !centerOnlyIfNodesNotInView ||\r\n        (centerOnlyIfNodesNotInView &&\r\n          nodes?.some(node => !isNodeInView(camera, node.position)))\r\n      ) {\r\n        // Centers the graph based on the central most node\r\n        const { x, y, z } = getLayoutCenter(nodes);\r\n\r\n        await controls.normalizeRotations().setTarget(x, y, z, animated);\r\n\r\n        if (!isCentered) {\r\n          setIsCentered(true);\r\n        }\r\n\r\n        invalidate();\r\n      }\r\n    },\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [invalidate, controls, nodes]\r\n  );\r\n\r\n  const fitNodesInView = useCallback(\r\n    async (\r\n      nodes,\r\n      opts: FitNodesParams = { animated: true, fitOnlyIfNodesNotInView: false }\r\n    ) => {\r\n      const { fitOnlyIfNodesNotInView } = opts;\r\n\r\n      if (\r\n        !fitOnlyIfNodesNotInView ||\r\n        (fitOnlyIfNodesNotInView &&\r\n          nodes?.some(node => !isNodeInView(camera, node.position)))\r\n      ) {\r\n        const { minX, maxX, minY, maxY, minZ, maxZ } = getLayoutCenter(nodes);\r\n\r\n        if (!layoutType.includes('3d')) {\r\n          // fitToBox will auto rotate to the closest axis including the z axis,\r\n          // which is not desired for 2D graphs\r\n          // So get the rotation to the closest flat axis for 2D graphs\r\n          const { horizontalRotation, verticalRotation } =\r\n            getDegreesToClosest2dAxis(\r\n              controls?.azimuthAngle,\r\n              controls?.polarAngle\r\n            );\r\n\r\n          void controls?.rotate(horizontalRotation, verticalRotation, true);\r\n        }\r\n\r\n        await controls?.zoomTo(1, opts?.animated);\r\n\r\n        await controls?.fitToBox(\r\n          new Box3(\r\n            new Vector3(minX, minY, minZ),\r\n            new Vector3(maxX, maxY, maxZ)\r\n          ),\r\n          opts?.animated,\r\n          {\r\n            cover: false,\r\n            paddingLeft: PADDING,\r\n            paddingRight: PADDING,\r\n            paddingBottom: PADDING,\r\n            paddingTop: PADDING\r\n          }\r\n        );\r\n      }\r\n    },\r\n    [camera, controls, layoutType]\r\n  );\r\n\r\n  const getNodesById = useCallback(\r\n    (nodeIds: string[]) => {\r\n      let mappedNodes: InternalGraphNode[] | null = null;\r\n\r\n      if (nodeIds?.length) {\r\n        // Map the node ids to the actual nodes\r\n        mappedNodes = nodeIds.reduce((acc, id) => {\r\n          const node = nodes.find(n => n.id === id);\r\n          if (node) {\r\n            acc.push(node);\r\n          } else {\r\n            throw new Error(\r\n              `Attempted to center ${id} but it was not found in the nodes`\r\n            );\r\n          }\r\n\r\n          return acc;\r\n        }, []);\r\n      }\r\n\r\n      return mappedNodes;\r\n    },\r\n    [nodes]\r\n  );\r\n\r\n  const centerNodesById = useCallback(\r\n    (nodeIds: string[], opts: CenterNodesParams) => {\r\n      const mappedNodes = getNodesById(nodeIds);\r\n\r\n      centerNodes(mappedNodes || nodes, {\r\n        animated,\r\n        centerOnlyIfNodesNotInView: opts?.centerOnlyIfNodesNotInView\r\n      });\r\n    },\r\n    [animated, centerNodes, getNodesById, nodes]\r\n  );\r\n\r\n  const fitNodesInViewById = useCallback(\r\n    async (nodeIds: string[], opts: FitNodesParams) => {\r\n      const mappedNodes = getNodesById(nodeIds);\r\n\r\n      await fitNodesInView(mappedNodes || nodes, { animated, ...opts });\r\n    },\r\n    [animated, fitNodesInView, getNodesById, nodes]\r\n  );\r\n\r\n  useLayoutEffect(() => {\r\n    async function load() {\r\n      // Once we've loaded controls and we have nodes, let's recenter\r\n      if (controls && nodes?.length) {\r\n        if (!mounted.current) {\r\n          // Center the graph once nodes are loaded on mount\r\n          await centerNodes(nodes, { animated: false });\r\n          await fitNodesInView(nodes, { animated: false });\r\n          mounted.current = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    load();\r\n  }, [controls, centerNodes, nodes, animated, camera, fitNodesInView]);\r\n\r\n  return { centerNodes, centerNodesById, fitNodesInViewById, isCentered };\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { FC } from 'react';\r\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\r\nimport type { ColorRepresentation, Mesh } from 'three';\r\nimport { Color, DoubleSide, Vector3 } from 'three';\r\n\r\nimport { useStore } from '../store';\r\nimport { animationConfig } from '../utils';\r\n\r\nexport type EdgeArrowPosition = 'none' | 'mid' | 'end';\r\n\r\nexport interface ArrowProps {\r\n  /**\r\n   * Whether the arrow should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * The color of the arrow.\r\n   */\r\n  color?: ColorRepresentation;\r\n\r\n  /**\r\n   * The length of the arrow.\r\n   */\r\n  length: number;\r\n\r\n  /**\r\n   * The opacity of the arrow.\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * The position of the arrow in 3D space.\r\n   */\r\n  position: Vector3;\r\n\r\n  /**\r\n   * The rotation of the arrow in 3D space.\r\n   */\r\n  rotation: Vector3;\r\n\r\n  /**\r\n   * The size of the arrow.\r\n   */\r\n  size: number;\r\n\r\n  /**\r\n   * A function that is called when the arrow is right-clicked.\r\n   */\r\n  onContextMenu?: () => void;\r\n\r\n  /**\r\n   * A function that is called when the arrow is selected or deselected.\r\n   */\r\n  onActive?: (state: boolean) => void;\r\n}\r\n\r\nexport const Arrow: FC<ArrowProps> = ({\r\n  animated,\r\n  color = '#D8E6EA',\r\n  length,\r\n  opacity = 0.5,\r\n  position,\r\n  rotation,\r\n  size = 1,\r\n  onActive,\r\n  onContextMenu\r\n}) => {\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n  const meshRef = useRef<Mesh | null>(null);\r\n  const isDragging = useStore(state => state.draggingIds.length > 0);\r\n  const center = useStore(state => state.centerPosition);\r\n\r\n  const [{ pos, arrowOpacity }] = useSpring(\r\n    () => ({\r\n      from: {\r\n        pos: center ? [center.x, center.y, center.z] : [0, 0, 0],\r\n        arrowOpacity: 0\r\n      },\r\n      to: {\r\n        pos: [position.x, position.y, position.z],\r\n        arrowOpacity: opacity\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated && !isDragging ? undefined : 0\r\n      }\r\n    }),\r\n    [animated, isDragging, opacity, position]\r\n  );\r\n\r\n  const setQuaternion = useCallback(() => {\r\n    const axis = new Vector3(0, 1, 0);\r\n    meshRef.current?.quaternion.setFromUnitVectors(axis, rotation);\r\n  }, [rotation, meshRef]);\r\n\r\n  useEffect(() => setQuaternion(), [setQuaternion]);\r\n\r\n  return (\r\n    <a.mesh\r\n      position={pos as any}\r\n      ref={meshRef}\r\n      scale={[1, 1, 1]}\r\n      onPointerOver={() => onActive(true)}\r\n      onPointerOut={() => onActive(false)}\r\n      // context menu controls\r\n      onPointerDown={event => {\r\n        if (event.nativeEvent.buttons === 2) {\r\n          event.stopPropagation();\r\n        }\r\n      }}\r\n      onContextMenu={event => {\r\n        event.nativeEvent.preventDefault();\r\n        event.stopPropagation();\r\n        onContextMenu();\r\n      }}\r\n    >\r\n      <cylinderGeometry\r\n        args={[0, size, length, 20, 1, true]}\r\n        attach=\"geometry\"\r\n      />\r\n      <a.meshBasicMaterial\r\n        attach=\"material\"\r\n        color={normalizedColor}\r\n        depthTest={false}\r\n        opacity={arrowOpacity}\r\n        transparent={true}\r\n        side={DoubleSide}\r\n        fog={true}\r\n      />\r\n    </a.mesh>\r\n  );\r\n};\r\n","import { useThree } from '@react-three/fiber';\r\nimport { useGesture } from '@use-gesture/react';\r\nimport { useMemo } from 'react';\r\nimport { Plane, Vector2, Vector3 } from 'three';\r\n\r\nimport type { InternalGraphPosition } from '../types';\r\nimport type { CenterPositionVector } from '../utils/layout';\r\n\r\ninterface DragParams {\r\n  draggable: boolean;\r\n  position: InternalGraphPosition;\r\n  bounds?: CenterPositionVector;\r\n  set: (position: Vector3) => void;\r\n  onDragStart: () => void;\r\n  onDragEnd: () => void;\r\n}\r\n\r\nexport const useDrag = ({\r\n  draggable,\r\n  set,\r\n  position,\r\n  bounds,\r\n  onDragStart,\r\n  onDragEnd\r\n}: DragParams) => {\r\n  const camera = useThree(state => state.camera);\r\n  const raycaster = useThree(state => state.raycaster);\r\n  const size = useThree(state => state.size);\r\n  const gl = useThree(state => state.gl);\r\n\r\n  // Reference: https://codesandbox.io/s/react-three-draggable-cxu37\r\n  const { mouse2D, mouse3D, offset, normal, plane } = useMemo(\r\n    () => ({\r\n      // Normalized 2D screen space mouse coords\r\n      mouse2D: new Vector2(),\r\n      // 3D world space mouse coords\r\n      mouse3D: new Vector3(),\r\n      // Drag point offset from object origin\r\n      offset: new Vector3(),\r\n      // Normal of the drag plane\r\n      normal: new Vector3(),\r\n      // Drag plane\r\n      plane: new Plane()\r\n    }),\r\n    []\r\n  );\r\n\r\n  const clientRect = useMemo(\r\n    () => gl.domElement.getBoundingClientRect(),\r\n    // Size dependency ensures the clientRect updates when container dimensions change.\r\n    // Without it, drag calculations would use stale positioning data from the previous container size.\r\n    [gl.domElement, size]\r\n  );\r\n\r\n  return useGesture(\r\n    {\r\n      onDragStart: ({ event }) => {\r\n        // @ts-ignore\r\n        const { eventObject, point } = event;\r\n\r\n        // Save the offset of click point from object origin\r\n        offset.setFromMatrixPosition(eventObject.matrixWorld).sub(point);\r\n\r\n        // Set initial 3D cursor position (needed for onDrag plane calculation)\r\n        mouse3D.copy(point);\r\n\r\n        // Run user callback\r\n        onDragStart();\r\n      },\r\n      onDrag: ({ xy, buttons, cancel }) => {\r\n        // If the left mouse button is not pressed, cancel the drag\r\n        if (buttons !== 1) {\r\n          cancel();\r\n          return;\r\n        }\r\n        // Compute normalized mouse coordinates (screen space)\r\n        const nx = ((xy[0] - (clientRect?.left ?? 0)) / size.width) * 2 - 1;\r\n        const ny = -((xy[1] - (clientRect?.top ?? 0)) / size.height) * 2 + 1;\r\n\r\n        // Unlike the mouse from useThree, this works offscreen\r\n        mouse2D.set(nx, ny);\r\n\r\n        // Update raycaster (otherwise it doesn't track offscreen)\r\n        raycaster.setFromCamera(mouse2D, camera);\r\n\r\n        // The drag plane is normal to the camera view\r\n        camera.getWorldDirection(normal).negate();\r\n\r\n        // Find the plane that's normal to the camera and contains our drag point\r\n        plane.setFromNormalAndCoplanarPoint(normal, mouse3D);\r\n\r\n        // Find the point of intersection\r\n        raycaster.ray.intersectPlane(plane, mouse3D);\r\n\r\n        // Update the object position with the original offset\r\n        const updated = new Vector3(position.x, position.y, position.z)\r\n          .copy(mouse3D)\r\n          .add(offset);\r\n\r\n        // If there's a cluster, clamp the position within its circular bounds\r\n        if (bounds) {\r\n          const center = new Vector3(\r\n            (bounds.minX + bounds.maxX) / 2,\r\n            (bounds.minY + bounds.maxY) / 2,\r\n            (bounds.minZ + bounds.maxZ) / 2\r\n          );\r\n          const radius = (bounds.maxX - bounds.minX) / 2;\r\n\r\n          // Calculate direction from center to updated position\r\n          const direction = updated.clone().sub(center);\r\n          const distance = direction.length();\r\n\r\n          // If outside the circle, clamp to the circle's edge\r\n          if (distance > radius) {\r\n            direction.normalize().multiplyScalar(radius);\r\n            updated.copy(center).add(direction);\r\n          }\r\n        }\r\n\r\n        return set(updated);\r\n      },\r\n      onDragEnd\r\n    },\r\n    { drag: { enabled: draggable, threshold: 10 } }\r\n  );\r\n};\r\n","import type { ThreeEvent } from '@react-three/fiber';\r\nimport { useCallback, useRef } from 'react';\r\n\r\nexport interface HoverIntentOptions {\r\n  interval?: number;\r\n  sensitivity?: number;\r\n  timeout?: number;\r\n  disabled?: boolean;\r\n  onPointerOver: (event: ThreeEvent<PointerEvent>) => void;\r\n  onPointerOut: (event: ThreeEvent<PointerEvent>) => void;\r\n}\r\n\r\nexport interface HoverIntentResult {\r\n  pointerOut: (event: ThreeEvent<PointerEvent>) => void;\r\n  pointerOver: (event: ThreeEvent<PointerEvent>) => void;\r\n}\r\n\r\n/**\r\n * Hover intent identifies if the user actually is\r\n * intending to over by measuring the position of the mouse\r\n * once a pointer enters and determining if in a duration if\r\n * the mouse moved inside a certain threshold and fires the events.\r\n */\r\nexport const useHoverIntent = ({\r\n  sensitivity = 7,\r\n  interval = 50,\r\n  timeout = 0,\r\n  disabled,\r\n  onPointerOver,\r\n  onPointerOut\r\n}: HoverIntentOptions | undefined): HoverIntentResult => {\r\n  const mouseOver = useRef<boolean>(false);\r\n  const timer = useRef<any | null>(null);\r\n  const state = useRef<number>(0);\r\n  const coords = useRef({\r\n    x: null,\r\n    y: null,\r\n    px: null,\r\n    py: null\r\n  });\r\n\r\n  const onMouseMove = useCallback((event: MouseEvent) => {\r\n    coords.current.x = event.clientX;\r\n    coords.current.y = event.clientY;\r\n  }, []);\r\n\r\n  const comparePosition = useCallback(\r\n    (event: ThreeEvent<PointerEvent>) => {\r\n      timer.current = clearTimeout(timer.current);\r\n      const { px, x, py, y } = coords.current;\r\n\r\n      if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\r\n        state.current = 1;\r\n        onPointerOver(event);\r\n      } else {\r\n        coords.current.px = x;\r\n        coords.current.py = y;\r\n        timer.current = setTimeout(() => comparePosition(event), interval);\r\n      }\r\n    },\r\n    [interval, onPointerOver, sensitivity]\r\n  );\r\n\r\n  const cleanup = useCallback(() => {\r\n    clearTimeout(timer.current);\r\n    if (typeof window !== 'undefined') {\r\n      document.removeEventListener('mousemove', onMouseMove, false);\r\n    }\r\n  }, [onMouseMove]);\r\n\r\n  const pointerOver = useCallback(\r\n    (event: ThreeEvent<PointerEvent>) => {\r\n      if (!disabled) {\r\n        mouseOver.current = true;\r\n        cleanup();\r\n\r\n        if (state.current !== 1) {\r\n          coords.current.px = event.pointer.x;\r\n          coords.current.py = event.pointer.y;\r\n\r\n          if (typeof window !== 'undefined') {\r\n            document.addEventListener('mousemove', onMouseMove, false);\r\n          }\r\n\r\n          timer.current = setTimeout(() => comparePosition(event), timeout);\r\n        }\r\n      }\r\n    },\r\n    [cleanup, comparePosition, disabled, onMouseMove, timeout]\r\n  );\r\n\r\n  const delay = useCallback(\r\n    (event: ThreeEvent<PointerEvent>) => {\r\n      timer.current = clearTimeout(timer.current);\r\n      state.current = 0;\r\n      onPointerOut(event);\r\n    },\r\n    [onPointerOut]\r\n  );\r\n\r\n  const pointerOut = useCallback(\r\n    (event: ThreeEvent<PointerEvent>) => {\r\n      mouseOver.current = false;\r\n      cleanup();\r\n\r\n      if (state.current === 1) {\r\n        timer.current = setTimeout(() => delay(event), timeout);\r\n      }\r\n    },\r\n    [cleanup, delay, timeout]\r\n  );\r\n\r\n  return {\r\n    pointerOver,\r\n    pointerOut\r\n  };\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { FC } from 'react';\r\nimport React from 'react';\r\nimport type { Color } from 'three';\r\nimport { DoubleSide } from 'three';\r\n\r\nimport type { Theme } from '../../themes';\r\nimport { animationConfig } from '../../utils';\r\n\r\nexport interface RingProps {\r\n  outerRadius: number;\r\n  innerRadius: number;\r\n  padding: number;\r\n  normalizedFill: Color;\r\n  normalizedStroke: Color;\r\n  opacity: number;\r\n  animated: boolean;\r\n  theme: Theme;\r\n}\r\n\r\nexport const Ring: FC<RingProps> = ({\r\n  outerRadius,\r\n  innerRadius,\r\n  padding,\r\n  normalizedFill,\r\n  normalizedStroke,\r\n  opacity,\r\n  animated,\r\n  theme\r\n}) => {\r\n  const { opacity: springOpacity } = useSpring({\r\n    from: { opacity: 0 },\r\n    to: { opacity },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <mesh>\r\n        <ringGeometry attach=\"geometry\" args={[outerRadius, 0, 128]} />\r\n        <a.meshBasicMaterial\r\n          attach=\"material\"\r\n          color={normalizedFill}\r\n          transparent={true}\r\n          depthTest={false}\r\n          opacity={theme.cluster?.fill ? springOpacity : 0}\r\n          side={DoubleSide}\r\n          fog={true}\r\n        />\r\n      </mesh>\r\n      <mesh>\r\n        <ringGeometry\r\n          attach=\"geometry\"\r\n          args={[outerRadius, innerRadius + padding, 128]}\r\n        />\r\n        <a.meshBasicMaterial\r\n          attach=\"material\"\r\n          color={normalizedStroke}\r\n          transparent={true}\r\n          depthTest={false}\r\n          opacity={springOpacity}\r\n          side={DoubleSide}\r\n          fog={true}\r\n        />\r\n      </mesh>\r\n    </>\r\n  );\r\n};\r\n","import { a } from '@react-spring/three';\r\nimport { Billboard, RoundedBox, Text } from '@react-three/drei';\r\nimport ellipsize from 'ellipsize';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport type { ColorRepresentation, Euler } from 'three';\r\nimport { Color } from 'three';\r\n\r\nconst calculateTextSize = (\r\n  text: string,\r\n  fontSize: number,\r\n  maxWidth: number,\r\n  ellipsis: number,\r\n  active: boolean\r\n) => {\r\n  const shortText = ellipsis && !active ? ellipsize(text, ellipsis) : text;\r\n  const lines = [];\r\n  let currentLine = '';\r\n  const words = shortText.split(' ');\r\n\r\n  words.forEach(word => {\r\n    const testLine = currentLine ? `${currentLine} ${word}` : word;\r\n    const testWidth = testLine.length * fontSize * 1;\r\n\r\n    if (testWidth > maxWidth) {\r\n      lines.push(currentLine);\r\n      currentLine = word;\r\n    } else {\r\n      currentLine = testLine;\r\n    }\r\n  });\r\n\r\n  if (currentLine) {\r\n    lines.push(currentLine);\r\n  }\r\n\r\n  const width =\r\n    Math.min(\r\n      maxWidth,\r\n      lines.reduce(\r\n        (max, line) => Math.max(max, line.length * fontSize * 0.4),\r\n        0\r\n      )\r\n    ) + 14;\r\n  const height = lines.length * fontSize + 6;\r\n\r\n  return { width, height, text: lines.join('\\n'), lineCount: lines.length };\r\n};\r\n\r\nexport interface LabelProps {\r\n  /**\r\n   * Text to render.\r\n   */\r\n  text: string;\r\n\r\n  /**\r\n   * Font URL.\r\n   * Reference: https://github.com/reaviz/reagraph/issues/23\r\n   */\r\n  fontUrl?: string;\r\n\r\n  /**\r\n   * Size of the font.\r\n   */\r\n  fontSize?: number;\r\n\r\n  /**\r\n   * Color of the text.\r\n   */\r\n  color?: ColorRepresentation;\r\n\r\n  /**\r\n   * Stroke of the text.\r\n   */\r\n  stroke?: ColorRepresentation;\r\n\r\n  /**\r\n   * Opacity for the label.\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * The lenth of which to start the ellipsis.\r\n   */\r\n  ellipsis?: number;\r\n\r\n  /**\r\n   * Whether the label is active ( dragging, hover, focus ).\r\n   */\r\n  active?: boolean;\r\n\r\n  /**\r\n   * Rotation of the label.\r\n   */\r\n  rotation?: Euler | [number, number, number];\r\n\r\n  /**\r\n   * Maximum width of the label.\r\n   */\r\n  maxWidth?: number;\r\n\r\n  /**\r\n   * Background color of the label.\r\n   */\r\n  backgroundColor?: ColorRepresentation;\r\n\r\n  /**\r\n   * Border radius of the label.\r\n   */\r\n  borderRadius?: number;\r\n\r\n  /**\r\n   * Type of the label.\r\n   */\r\n  type?: 'node' | 'edge';\r\n\r\n  /**\r\n   * label visible or not\r\n   */\r\n  labelVisible?: boolean;\r\n}\r\n\r\nexport const Label: FC<LabelProps> = ({\r\n  text,\r\n  fontSize = 4,\r\n  fontUrl,\r\n  color = '#2A6475',\r\n  opacity = 1,\r\n  stroke,\r\n  backgroundColor,\r\n  active,\r\n  rotation,\r\n  maxWidth = 100,\r\n  ellipsis = 100,\r\n  borderRadius\r\n}) => {\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n  const normalizedBackgroundColor = useMemo(\r\n    () => new Color(backgroundColor),\r\n    [backgroundColor]\r\n  );\r\n  const normalizedStroke = useMemo(\r\n    () => (stroke ? new Color(stroke) : undefined),\r\n    [stroke]\r\n  );\r\n\r\n  const {\r\n    width,\r\n    height,\r\n    text: processedText,\r\n    lineCount\r\n  } = useMemo(\r\n    () => calculateTextSize(text, fontSize, maxWidth, ellipsis, active),\r\n    [text, fontSize, maxWidth, ellipsis, active]\r\n  );\r\n\r\n  return (\r\n    <Billboard>\r\n      {backgroundColor ? (\r\n        <mesh>\r\n          <RoundedBox\r\n            position={[0, lineCount * -2, 10]}\r\n            args={[width, height, 0]} // Width, height, depth.\r\n            radius={borderRadius}\r\n            rotation={rotation}\r\n          >\r\n            <Text\r\n              font={fontUrl}\r\n              fontSize={fontSize}\r\n              color={normalizedColor}\r\n              fillOpacity={opacity}\r\n              textAlign=\"center\"\r\n              outlineWidth={stroke ? 1 : 0}\r\n              outlineColor={stroke ? normalizedStroke : null}\r\n              depthOffset={0}\r\n              maxWidth={maxWidth}\r\n              overflowWrap=\"break-word\"\r\n            >\r\n              {processedText}\r\n            </Text>\r\n            <a.meshBasicMaterial\r\n              attach=\"material\"\r\n              opacity={opacity}\r\n              depthTest={true}\r\n              color={normalizedBackgroundColor}\r\n            />\r\n          </RoundedBox>\r\n        </mesh>\r\n      ) : (\r\n        <Text\r\n          font={fontUrl}\r\n          fontSize={fontSize}\r\n          color={normalizedColor}\r\n          fillOpacity={opacity}\r\n          textAlign=\"center\"\r\n          outlineWidth={stroke ? 1 : 0}\r\n          outlineColor={normalizedStroke}\r\n          depthOffset={0}\r\n          maxWidth={maxWidth}\r\n          overflowWrap=\"break-word\"\r\n          rotation={rotation}\r\n        >\r\n          {processedText}\r\n        </Text>\r\n      )}\r\n    </Billboard>\r\n  );\r\n};\r\n\r\n// Label.defaultProps = {\r\n//   opacity: 1,\r\n//   fontSize: 4,\r\n//   color: '#2A6475',\r\n//   ellipsis: 100\r\n// };\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { useCursor } from '@react-three/drei';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo, useState } from 'react';\r\nimport type { Vector3 } from 'three';\r\nimport { Color } from 'three';\r\n\r\nimport { useCameraControls } from '../CameraControls/useCameraControls';\r\nimport { useStore } from '../store';\r\nimport type { ClusterRenderer } from '../types';\r\nimport type { ClusterGroup } from '../utils';\r\nimport { animationConfig } from '../utils';\r\nimport { useDrag } from '../utils/useDrag';\r\nimport { useHoverIntent } from '../utils/useHoverIntent';\r\nimport { Ring } from './clusters/Ring';\r\nimport { Label } from './Label';\r\n\r\nexport type ClusterEventArgs = Omit<ClusterGroup, 'position'>;\r\n\r\nexport interface ClusterProps extends ClusterGroup {\r\n  /**\r\n   * Whether the circle should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * The radius of the circle. Default 1.\r\n   */\r\n  radius?: number;\r\n\r\n  /**\r\n   * The padding of the circle. Default 20.\r\n   */\r\n  padding?: number;\r\n\r\n  /**\r\n   * The url for the label font.\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * Whether the node is disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * When the cluster was clicked.\r\n   */\r\n  onClick?: (cluster: ClusterEventArgs, event: ThreeEvent<MouseEvent>) => void;\r\n\r\n  /**\r\n   * When a cluster receives a pointer over event.\r\n   */\r\n  onPointerOver?: (\r\n    cluster: ClusterEventArgs,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When cluster receives a pointer leave event.\r\n   */\r\n  onPointerOut?: (\r\n    cluster: ClusterEventArgs,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * Whether the cluster is draggable\r\n   */\r\n  draggable?: boolean;\r\n\r\n  /**\r\n   * Triggered after a cluster was dragged\r\n   */\r\n  onDragged?: (cluster: ClusterEventArgs) => void;\r\n\r\n  /**\r\n   * Render a custom cluster label\r\n   */\r\n  onRender?: ClusterRenderer;\r\n}\r\n\r\nexport const Cluster: FC<ClusterProps> = ({\r\n  animated,\r\n  position,\r\n  padding = 40,\r\n  labelFontUrl,\r\n  disabled,\r\n  radius = 2,\r\n  nodes,\r\n  label,\r\n  onClick,\r\n  onPointerOver,\r\n  onPointerOut,\r\n  draggable = false,\r\n  onDragged,\r\n  onRender\r\n}) => {\r\n  const theme = useStore(state => state.theme);\r\n  const rad = Math.max(position.width, position.height) / 2;\r\n  const offset = rad - radius + padding;\r\n  const [active, setActive] = useState<boolean>(false);\r\n  const center = useStore(state => state.centerPosition);\r\n  const nodesState = useStore(state => state.nodes);\r\n  const cameraControls = useCameraControls();\r\n  const draggingIds = useStore(state => state.draggingIds);\r\n  const isDraggingCurrent = draggingIds.includes(label);\r\n  const isDragging = draggingIds.length > 0;\r\n\r\n  const isActive = useStore(state =>\r\n    state.actives?.some(id => nodes.some(n => n.id === id))\r\n  );\r\n  const hoveredNodeId = useStore(state => state.hoveredNodeId);\r\n\r\n  const isSelected = useStore(state =>\r\n    state.selections?.some(id => nodes.some(n => n.id === id))\r\n  );\r\n\r\n  const hasSelections = useStore(state => state.selections?.length > 0);\r\n\r\n  const opacity = hasSelections\r\n    ? isSelected || active || isActive\r\n      ? theme.cluster?.selectedOpacity\r\n      : theme.cluster?.inactiveOpacity\r\n    : theme.cluster?.opacity;\r\n\r\n  const labelPosition: [number, number, number] = useMemo(() => {\r\n    const defaultPosition: [number, number, number] = [0, -offset, 2];\r\n    const themeOffset = theme.cluster?.label?.offset;\r\n    if (themeOffset) {\r\n      return [\r\n        defaultPosition[0] - themeOffset[0],\r\n        defaultPosition[1] - themeOffset[1],\r\n        defaultPosition[2] - themeOffset[2]\r\n      ];\r\n    }\r\n\r\n    return defaultPosition;\r\n  }, [offset, theme.cluster?.label?.offset]);\r\n\r\n  const { circlePosition } = useSpring({\r\n    from: {\r\n      circlePosition: [center.x, center.y, -1] as [number, number, number]\r\n    },\r\n    to: {\r\n      circlePosition: position\r\n        ? ([position.x, position.y, -1] as [number, number, number])\r\n        : ([0, 0, -1] as [number, number, number])\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated && !isDragging ? undefined : 0\r\n    }\r\n  });\r\n\r\n  const normalizedStroke = useMemo(\r\n    () => new Color(theme.cluster?.stroke),\r\n    [theme.cluster?.stroke]\r\n  );\r\n\r\n  const normalizedFill = useMemo(\r\n    () => new Color(theme.cluster?.fill),\r\n    [theme.cluster?.fill]\r\n  );\r\n\r\n  const addDraggingId = useStore(state => state.addDraggingId);\r\n  const removeDraggingId = useStore(state => state.removeDraggingId);\r\n  const setClusterPosition = useStore(state => state.setClusterPosition);\r\n\r\n  // Define the drag event handlers for the cluster\r\n  const bind = useDrag({\r\n    draggable: draggable && !hoveredNodeId,\r\n    position: {\r\n      x: position.x,\r\n      y: position.y,\r\n      z: -1\r\n    } as any,\r\n    set: (pos: Vector3) => setClusterPosition(label, pos as any),\r\n    onDragStart: () => {\r\n      addDraggingId(label);\r\n      setActive(true);\r\n    },\r\n    onDragEnd: () => {\r\n      removeDraggingId(label);\r\n      setActive(false);\r\n      // Get nodes from store with updated position after dragging\r\n      const updatedClusterNodes = nodesState.filter(n => n.cluster === label);\r\n      onDragged?.({ nodes: updatedClusterNodes, label });\r\n    }\r\n  });\r\n\r\n  // Set the cursor to pointer when the cluster is active and not dragging\r\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\r\n  // Set the cursor to grab when the cluster is active and draggable\r\n  useCursor(\r\n    active && draggable && !isDraggingCurrent && onClick === undefined,\r\n    'grab'\r\n  );\r\n  // Set the cursor to grabbing when the cluster is dragging\r\n  useCursor(isDraggingCurrent, 'grabbing');\r\n\r\n  const { pointerOver, pointerOut } = useHoverIntent({\r\n    disabled,\r\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\r\n      setActive(true);\r\n      cameraControls.freeze();\r\n      onPointerOver?.(\r\n        {\r\n          nodes,\r\n          label\r\n        },\r\n        event\r\n      );\r\n    },\r\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\r\n      setActive(false);\r\n      cameraControls.unFreeze();\r\n      onPointerOut?.(\r\n        {\r\n          nodes,\r\n          label\r\n        },\r\n        event\r\n      );\r\n    }\r\n  });\r\n\r\n  const cluster = useMemo(\r\n    () =>\r\n      theme.cluster && (\r\n        <a.group\r\n          userData={{ id: label, type: 'cluster' }}\r\n          position={circlePosition as any}\r\n          onPointerOver={pointerOver}\r\n          onPointerOut={pointerOut}\r\n          onClick={(event: ThreeEvent<MouseEvent>) => {\r\n            if (!disabled && !isDraggingCurrent) {\r\n              onClick?.({ nodes, label }, event);\r\n            }\r\n          }}\r\n          {...(bind() as any)}\r\n        >\r\n          {onRender ? (\r\n            onRender({\r\n              label: {\r\n                position: labelPosition,\r\n                text: label,\r\n                opacity: opacity,\r\n                fontUrl: labelFontUrl\r\n              },\r\n              opacity,\r\n              outerRadius: offset,\r\n              innerRadius: rad,\r\n              padding,\r\n              theme\r\n            })\r\n          ) : (\r\n            <>\r\n              <Ring\r\n                outerRadius={offset}\r\n                innerRadius={rad}\r\n                padding={padding}\r\n                normalizedFill={normalizedFill}\r\n                normalizedStroke={normalizedStroke}\r\n                opacity={opacity}\r\n                animated={animated}\r\n                theme={theme}\r\n              />\r\n              {theme.cluster?.label && (\r\n                <a.group position={labelPosition}>\r\n                  <Label\r\n                    text={label}\r\n                    opacity={opacity}\r\n                    fontUrl={labelFontUrl}\r\n                    stroke={theme.cluster.label.stroke}\r\n                    active={false}\r\n                    color={theme.cluster?.label.color}\r\n                    fontSize={theme.cluster?.label.fontSize ?? 12}\r\n                    ellipsis={theme.cluster.label.ellipsis}\r\n                    backgroundColor={theme.cluster.label.backgroundColor}\r\n                    borderRadius={theme.cluster.label.borderRadius}\r\n                  />\r\n                </a.group>\r\n              )}\r\n            </>\r\n          )}\r\n        </a.group>\r\n      ),\r\n    [\r\n      theme,\r\n      circlePosition,\r\n      pointerOver,\r\n      pointerOut,\r\n      offset,\r\n      normalizedFill,\r\n      rad,\r\n      padding,\r\n      normalizedStroke,\r\n      labelPosition,\r\n      label,\r\n      opacity,\r\n      labelFontUrl,\r\n      disabled,\r\n      onClick,\r\n      nodes,\r\n      bind,\r\n      isDraggingCurrent,\r\n      onRender,\r\n      animated\r\n    ]\r\n  );\r\n\r\n  return cluster;\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport type { ColorRepresentation } from 'three';\r\nimport { Color } from 'three';\r\nimport { animationConfig } from 'utils/animation';\r\n\r\nexport interface SelfLoopProps {\r\n  /**\r\n   * The unique identifier of the edge.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The color of the edge.\r\n   */\r\n  curve: any;\r\n\r\n  /**\r\n   * The size of the edge.\r\n   */\r\n  size: number;\r\n\r\n  /**\r\n   * The color of the edge.\r\n   */\r\n  color?: ColorRepresentation;\r\n\r\n  /**\r\n   * The opacity of the edge.\r\n   */\r\n  opacity: number;\r\n\r\n  /**\r\n   * Whether the edge is animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved over the line.\r\n   */\r\n  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved out of the line.\r\n   */\r\n  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the line is clicked.\r\n   */\r\n  onClick?: (event: ThreeEvent<MouseEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the line is right-clicked.\r\n   */\r\n  onContextMenu?: () => void;\r\n}\r\n\r\nexport const SelfLoop: FC<SelfLoopProps> = ({\r\n  id,\r\n  curve,\r\n  opacity = 1,\r\n  size = 1,\r\n  color = '#000',\r\n  animated,\r\n  onPointerOver,\r\n  onPointerOut,\r\n  onClick,\r\n  onContextMenu\r\n}) => {\r\n  const { scale, loopOpacity } = useSpring({\r\n    from: {\r\n      // Note: This prevents incorrect scaling w/ 0\r\n      scale: [0.00001, 0.00001, 0.00001],\r\n      loopOpacity: 0\r\n    },\r\n    to: {\r\n      scale: [size, size, size],\r\n      loopOpacity: opacity\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n\r\n  return (\r\n    <a.mesh\r\n      userData={{ id, type: 'edge' }}\r\n      renderOrder={-1}\r\n      onPointerOver={onPointerOver}\r\n      onPointerOut={onPointerOut}\r\n      onClick={onClick}\r\n      onPointerDown={event => {\r\n        if (event.nativeEvent.buttons === 2) {\r\n          event.nativeEvent.preventDefault();\r\n          event.stopPropagation();\r\n          onContextMenu();\r\n        }\r\n      }}\r\n      scale={scale as any}\r\n    >\r\n      <tubeGeometry attach=\"geometry\" args={[curve, 128, size / 2, 8, true]} />\r\n      <a.meshBasicMaterial\r\n        attach=\"material\"\r\n        opacity={loopOpacity}\r\n        fog={true}\r\n        transparent={true}\r\n        depthTest={false}\r\n        color={normalizedColor}\r\n      />\r\n    </a.mesh>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport type { FC } from 'react';\r\nimport React, { useEffect, useMemo, useRef } from 'react';\r\nimport type { ColorRepresentation, Curve } from 'three';\r\nimport { Color, ShaderMaterial, TubeGeometry, Vector3 } from 'three';\r\n\r\nimport { useStore } from '../store';\r\nimport { animationConfig, getCurve } from '../utils';\r\n\r\nexport interface LineProps {\r\n  /**\r\n   * Whether the line should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * The color of the line.\r\n   */\r\n  color?: ColorRepresentation;\r\n\r\n  /**\r\n   * Whether the line should be curved.\r\n   */\r\n  curved: boolean;\r\n\r\n  /**\r\n   * The curve of the line in 3D space.\r\n   */\r\n  curve: Curve<Vector3>;\r\n\r\n  /**\r\n   * Whether the line should be dashed.\r\n   */\r\n  dashed?: boolean;\r\n\r\n  /**\r\n   * Dash pattern for the line: [dashSize, gapSize]\r\n   */\r\n  dashArray?: [number, number];\r\n\r\n  /**\r\n   * The unique identifier of the line.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The opacity of the line.\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * The size of the line.\r\n   */\r\n  size?: number;\r\n\r\n  /**\r\n   * The render order of the line. Useful when edges are rendered on top of each other.\r\n   */\r\n  renderOrder?: number;\r\n\r\n  /**\r\n   * A function that is called when the line is clicked.\r\n   */\r\n  onClick?: (event: ThreeEvent<MouseEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the line is right-clicked.\r\n   */\r\n  onContextMenu?: () => void;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved over the line.\r\n   */\r\n  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved out of the line.\r\n   */\r\n  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;\r\n\r\n  /**\r\n   * The offset of the curve.\r\n   */\r\n  curveOffset?: number;\r\n}\r\n\r\n// Dashed line shader for tube geometry\r\nconst dashedVertexShader = `\r\n  varying vec2 vUv;\r\n  void main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\nconst dashedFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float opacity;\r\n  uniform float dashSize;\r\n  uniform float gapSize;\r\n  uniform float lineLength;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    float totalSize = dashSize + gapSize;\r\n    float position = mod(vUv.x * lineLength, totalSize);\r\n\r\n    if (position > dashSize) {\r\n      discard;\r\n    }\r\n\r\n    gl_FragColor = vec4(color, opacity);\r\n  }\r\n`;\r\n\r\nexport const Line: FC<LineProps> = ({\r\n  curveOffset,\r\n  animated,\r\n  color = '#000',\r\n  curve,\r\n  curved = false,\r\n  dashed = false,\r\n  dashArray = [3, 1],\r\n  id,\r\n  opacity = 1,\r\n  size = 1,\r\n  renderOrder = -1,\r\n  onContextMenu,\r\n  onClick,\r\n  onPointerOver,\r\n  onPointerOut\r\n}) => {\r\n  const tubeRef = useRef<TubeGeometry | null>(null);\r\n  const isDragging = useStore(state => state.draggingIds.length > 0);\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n  const center = useStore(state => state.centerPosition);\r\n  const mounted = useRef<boolean>(false);\r\n\r\n  // Create dashed material\r\n  const dashedMaterial = useMemo(() => {\r\n    if (!dashed) return null;\r\n    const [dashSize, dashGap] = dashArray;\r\n\r\n    return new ShaderMaterial({\r\n      uniforms: {\r\n        color: { value: normalizedColor },\r\n        opacity: { value: opacity },\r\n        dashSize: { value: dashSize },\r\n        gapSize: { value: dashGap },\r\n        lineLength: { value: curve.getLength() }\r\n      },\r\n      vertexShader: dashedVertexShader,\r\n      fragmentShader: dashedFragmentShader,\r\n      transparent: true,\r\n      depthTest: false\r\n    });\r\n  }, [dashed, normalizedColor, opacity, curve, dashArray]);\r\n\r\n  // Do opacity seperate from vertices for perf\r\n  const { lineOpacity } = useSpring({\r\n    from: {\r\n      lineOpacity: 0\r\n    },\r\n    to: {\r\n      lineOpacity: opacity\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  useSpring(() => {\r\n    const from = curve.getPoint(0);\r\n    const to = curve.getPoint(1);\r\n    return {\r\n      from: {\r\n        // Animate from center first time, then from the actual from point\r\n        fromVertices: !mounted.current\r\n          ? [center?.x, center?.y, center?.z || 0]\r\n          : [to?.x, to?.y, to?.z || 0],\r\n        toVertices: [from?.x, from?.y, from?.z || 0]\r\n      },\r\n      to: {\r\n        fromVertices: [from?.x, from?.y, from?.z || 0],\r\n        toVertices: [to?.x, to?.y, to?.z || 0]\r\n      },\r\n      onChange: event => {\r\n        const { fromVertices, toVertices } = event.value;\r\n        const fromVector = new Vector3(...fromVertices);\r\n        const toVector = new Vector3(...toVertices);\r\n\r\n        const curve = getCurve(fromVector, 0, toVector, 0, curved, curveOffset);\r\n\r\n        if (tubeRef.current) {\r\n          // Use slightly smaller radius for dashed lines for visual distinction\r\n          const radius = dashed ? size * 0.4 : size / 2;\r\n          tubeRef.current.copy(new TubeGeometry(curve, 20, radius, 5, false));\r\n        }\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated && !isDragging ? undefined : 0\r\n      }\r\n    };\r\n  }, [animated, isDragging, curve, size, dashed, curved, curveOffset]);\r\n\r\n  useEffect(() => {\r\n    // Handle mount operation for initial render\r\n    mounted.current = true;\r\n  }, []);\r\n\r\n  return (\r\n    <mesh\r\n      userData={{ id, type: 'edge' }}\r\n      renderOrder={renderOrder}\r\n      onPointerOver={onPointerOver}\r\n      onPointerOut={onPointerOut}\r\n      onClick={onClick}\r\n      // context menu controls\r\n      onPointerDown={event => {\r\n        if (event.nativeEvent.buttons === 2) {\r\n          event.stopPropagation();\r\n        }\r\n      }}\r\n      onContextMenu={event => {\r\n        event.nativeEvent.preventDefault();\r\n        event.stopPropagation();\r\n        onContextMenu();\r\n      }}\r\n    >\r\n      <tubeGeometry attach=\"geometry\" ref={tubeRef} />\r\n      {dashed ? (\r\n        <primitive attach=\"material\" object={dashedMaterial} />\r\n      ) : (\r\n        <a.meshBasicMaterial\r\n          attach=\"material\"\r\n          opacity={lineOpacity}\r\n          fog={true}\r\n          transparent={true}\r\n          color={normalizedColor}\r\n        />\r\n      )}\r\n    </mesh>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { Html, useCursor } from '@react-three/drei';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo, useState } from 'react';\r\nimport { Euler, Vector3 } from 'three';\r\n\r\nimport { useStore } from '../store';\r\nimport type { ContextMenuEvent, InternalGraphEdge } from '../types';\r\nimport {\r\n  animationConfig,\r\n  calculateEdgeCurveOffset,\r\n  getArrowSize,\r\n  getArrowVectors,\r\n  getCurve,\r\n  getLabelOffsetByType,\r\n  getMidPoint,\r\n  getVector\r\n} from '../utils';\r\nimport { calculateSubLabelOffset, getSelfLoopCurve } from '../utils/position';\r\nimport { useHoverIntent } from '../utils/useHoverIntent';\r\nimport type { EdgeArrowPosition } from './Arrow';\r\nimport { Arrow } from './Arrow';\r\nimport { SelfLoop } from './edges/SelfLoop';\r\nimport { Label } from './Label';\r\nimport { Line } from './Line';\r\n\r\n/**\r\n * Label positions relatively edge.\r\n *\r\n * - below: show label under the edge line\r\n * - above: show label above the edge line\r\n * - inline: show label along the edge line\r\n * - natural: normal text positions\r\n */\r\nexport type EdgeLabelPosition = 'below' | 'above' | 'inline' | 'natural';\r\n\r\n/**\r\n * SubLabel positions relatively to the main label.\r\n *\r\n * - below: show subLabel below the main label\r\n * - above: show subLabel above the main label\r\n */\r\nexport type EdgeSubLabelPosition = 'below' | 'above';\r\n\r\n/**\r\n * Type of edge interpolation.\r\n *\r\n * - Linear is straight\r\n * - Curved is curved\r\n */\r\nexport type EdgeInterpolation = 'linear' | 'curved';\r\n\r\nexport interface EdgeProps {\r\n  /**\r\n   * The url for the label font.\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * The unique identifier of the edge.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Whether the edge should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Whether the edge should be disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The placement of the edge label.\r\n   */\r\n  labelPlacement?: EdgeLabelPosition;\r\n\r\n  /**\r\n   * The placement of the edge subLabel relative to the main label.\r\n   */\r\n  subLabelPlacement?: EdgeSubLabelPosition;\r\n\r\n  /**\r\n   * The placement of the edge arrow.\r\n   */\r\n  arrowPlacement?: EdgeArrowPosition;\r\n\r\n  /**\r\n   * The type of interpolation used to draw the edge.\r\n   */\r\n  interpolation: EdgeInterpolation;\r\n\r\n  /**\r\n   * A function that returns the context menu for the edge.\r\n   */\r\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\r\n\r\n  /**\r\n   * A function that is called when the edge is clicked.\r\n   */\r\n  onClick?: (edge: InternalGraphEdge, event: ThreeEvent<MouseEvent>) => void;\r\n\r\n  /**\r\n   * A function that is called when the edge is right-clicked.\r\n   */\r\n  onContextMenu?: (edge?: InternalGraphEdge) => void;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved over the edge.\r\n   */\r\n  onPointerOver?: (\r\n    edge: InternalGraphEdge,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * A function that is called when the mouse pointer is moved out of the edge.\r\n   */\r\n  onPointerOut?: (\r\n    edge: InternalGraphEdge,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n}\r\n\r\nconst LABEL_PLACEMENT_OFFSET = 3;\r\n\r\nexport const Edge: FC<EdgeProps> = ({\r\n  animated,\r\n  arrowPlacement = 'end',\r\n  contextMenu,\r\n  disabled,\r\n  labelPlacement = 'inline',\r\n  id,\r\n  interpolation,\r\n  labelFontUrl,\r\n  onContextMenu,\r\n  onClick,\r\n  onPointerOver,\r\n  onPointerOut,\r\n  subLabelPlacement = 'below'\r\n}) => {\r\n  const theme = useStore(state => state.theme);\r\n  const isDragging = useStore(state => state.draggingIds.length > 0);\r\n\r\n  // UI states\r\n  const [active, setActive] = useState<boolean>(false);\r\n  const [menuVisible, setMenuVisible] = useState<boolean>(false);\r\n\r\n  // Edge data\r\n  const edges = useStore(state => state.edges);\r\n  const edge = edges.find(e => e.id === id);\r\n  const {\r\n    target,\r\n    source,\r\n    label,\r\n    subLabel,\r\n    labelVisible = false,\r\n    size = 1,\r\n    fill,\r\n    dashed = false,\r\n    dashArray = [3, 1]\r\n  } = edge;\r\n\r\n  // Use subLabelPlacement from edge data if available, otherwise use the prop value\r\n  const effectiveSubLabelPlacement =\r\n    edge.subLabelPlacement || subLabelPlacement;\r\n\r\n  const from = useStore(store => store.nodes.find(node => node.id === source));\r\n  const to = useStore(store => store.nodes.find(node => node.id === target));\r\n\r\n  // Detect self-loop\r\n  const isSelfLoop = from.id === to.id;\r\n\r\n  // Edge properties\r\n  const labelOffset = (size + theme.edge.label.fontSize) / 2;\r\n  const [arrowLength, arrowSize] = useMemo(() => getArrowSize(size), [size]);\r\n\r\n  // Use edge-specific interpolation if available, otherwise use global interpolation\r\n  const effectiveInterpolation = edge.interpolation || interpolation;\r\n\r\n  // Use edge-specific arrow placement if available, otherwise use global arrow placement\r\n  const effectiveArrowPlacement = edge.arrowPlacement || arrowPlacement;\r\n\r\n  const { curveOffset, curved } = useMemo(\r\n    () =>\r\n      calculateEdgeCurveOffset({\r\n        edge,\r\n        edges,\r\n        curved: effectiveInterpolation === 'curved'\r\n      }),\r\n    [edge, edges, effectiveInterpolation]\r\n  );\r\n\r\n  const [curve, arrowPosition, arrowRotation] = useMemo(() => {\r\n    const fromVector = getVector(from);\r\n    const fromOffset = from.size;\r\n    const toVector = getVector(to);\r\n    const toOffset = to.size;\r\n\r\n    let curve = getCurve(\r\n      fromVector,\r\n      fromOffset,\r\n      toVector,\r\n      toOffset,\r\n      curved,\r\n      curveOffset\r\n    );\r\n\r\n    const [arrowPosition, arrowRotation] = getArrowVectors(\r\n      effectiveArrowPlacement,\r\n      curve,\r\n      arrowLength\r\n    );\r\n\r\n    if (effectiveArrowPlacement === 'end') {\r\n      curve = getCurve(\r\n        fromVector,\r\n        fromOffset,\r\n        arrowPosition,\r\n        0,\r\n        curved,\r\n        curveOffset\r\n      );\r\n    }\r\n\r\n    return [curve, arrowPosition, arrowRotation];\r\n  }, [from, to, curved, curveOffset, effectiveArrowPlacement, arrowLength]);\r\n\r\n  const midPoint = useMemo(() => {\r\n    let newMidPoint = getMidPoint(\r\n      from.position,\r\n      to.position,\r\n      getLabelOffsetByType(labelOffset, labelPlacement)\r\n    );\r\n\r\n    if (curved) {\r\n      // Offset the label to the mid point of the curve\r\n      const offset = new Vector3().subVectors(newMidPoint, curve.getPoint(0.5));\r\n      switch (labelPlacement) {\r\n        case 'above':\r\n          offset.y = offset.y - LABEL_PLACEMENT_OFFSET;\r\n          break;\r\n        case 'below':\r\n          offset.y = offset.y + LABEL_PLACEMENT_OFFSET;\r\n          break;\r\n      }\r\n      newMidPoint = newMidPoint.sub(offset);\r\n    }\r\n\r\n    return newMidPoint;\r\n  }, [from.position, to.position, labelOffset, labelPlacement, curved, curve]);\r\n\r\n  const center = useStore(state => state.centerPosition);\r\n\r\n  const isSelected = useStore(state => state.selections?.includes(id));\r\n  const hasSelections = useStore(state => state.selections?.length);\r\n  const isActive = useStore(state => state.actives?.includes(id));\r\n  const isActiveState = active || isActive || isSelected;\r\n\r\n  const selectionOpacity = hasSelections\r\n    ? isSelected || isActive\r\n      ? theme.edge.selectedOpacity\r\n      : theme.edge.inactiveOpacity\r\n    : theme.edge.opacity;\r\n\r\n  // Calculate subLabel position based on edge orientation and subLabelPlacement\r\n  const subLabelOffset = useMemo(() => {\r\n    return calculateSubLabelOffset(\r\n      from.position,\r\n      to.position,\r\n      effectiveSubLabelPlacement\r\n    );\r\n  }, [from.position, to.position, effectiveSubLabelPlacement]);\r\n\r\n  const [{ labelPosition }] = useSpring(\r\n    () => ({\r\n      from: {\r\n        labelPosition: center ? [center.x, center.y, center.z] : [0, 0, 0]\r\n      },\r\n      to: {\r\n        labelPosition: [midPoint.x, midPoint.y, midPoint.z]\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated && !isDragging ? undefined : 0\r\n      }\r\n    }),\r\n    [midPoint, animated, isDragging]\r\n  );\r\n\r\n  const labelRotation = useMemo(\r\n    () =>\r\n      new Euler(\r\n        0,\r\n        0,\r\n        labelPlacement === 'natural'\r\n          ? 0\r\n          : Math.atan(\r\n              (to.position.y - from.position.y) /\r\n                (to.position.x - from.position.x)\r\n            )\r\n      ),\r\n    [\r\n      to.position.x,\r\n      to.position.y,\r\n      from.position.x,\r\n      from.position.y,\r\n      labelPlacement\r\n    ]\r\n  );\r\n\r\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\r\n\r\n  const { pointerOver, pointerOut } = useHoverIntent({\r\n    disabled,\r\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\r\n      setActive(true);\r\n      onPointerOver?.(edge, event);\r\n    },\r\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\r\n      setActive(false);\r\n      onPointerOut?.(edge, event);\r\n    }\r\n  });\r\n\r\n  const selfLoopCurve = useMemo(() => getSelfLoopCurve(from), [from]);\r\n\r\n  const arrowComponent = useMemo(() => {\r\n    if (effectiveArrowPlacement === 'none') return null;\r\n\r\n    let position: Vector3;\r\n    let rotation: Vector3;\r\n\r\n    if (isSelfLoop && selfLoopCurve) {\r\n      // Arrow for self-loop\r\n      const uEnd = 0.58;\r\n      const uMid = 0.25;\r\n      if (effectiveArrowPlacement === 'mid') {\r\n        position = selfLoopCurve.getPointAt(uMid);\r\n        rotation = selfLoopCurve.getTangentAt(uMid);\r\n      } else {\r\n        // end is default\r\n        position = selfLoopCurve.getPointAt(uEnd);\r\n        rotation = selfLoopCurve.getTangentAt(uEnd);\r\n      }\r\n    } else {\r\n      // Arrow for normal edge\r\n      position = arrowPosition;\r\n      rotation = arrowRotation;\r\n    }\r\n\r\n    return (\r\n      <Arrow\r\n        animated={animated}\r\n        color={\r\n          isActiveState ? theme.arrow.activeFill : fill || theme.arrow.fill\r\n        }\r\n        length={arrowLength}\r\n        opacity={selectionOpacity}\r\n        position={position}\r\n        rotation={rotation}\r\n        size={arrowSize}\r\n        onActive={setActive}\r\n        onContextMenu={() => {\r\n          if (!disabled) {\r\n            setMenuVisible(true);\r\n            onContextMenu?.(edge);\r\n          }\r\n        }}\r\n      />\r\n    );\r\n  }, [\r\n    fill,\r\n    animated,\r\n    arrowLength,\r\n    effectiveArrowPlacement,\r\n    arrowPosition,\r\n    arrowRotation,\r\n    arrowSize,\r\n    disabled,\r\n    edge,\r\n    isActiveState,\r\n    onContextMenu,\r\n    selectionOpacity,\r\n    theme.arrow.activeFill,\r\n    theme.arrow.fill,\r\n    isSelfLoop,\r\n    selfLoopCurve\r\n  ]);\r\n\r\n  const labelComponent = useMemo(\r\n    () =>\r\n      labelVisible &&\r\n      label && (\r\n        <a.group\r\n          position={labelPosition as any}\r\n          onContextMenu={() => {\r\n            if (!disabled) {\r\n              setMenuVisible(true);\r\n              onContextMenu?.(edge);\r\n            }\r\n          }}\r\n          onPointerOver={pointerOver}\r\n          onPointerOut={pointerOut}\r\n        >\r\n          <Label\r\n            text={label}\r\n            ellipsis={15}\r\n            fontUrl={labelFontUrl}\r\n            stroke={theme.edge.label.stroke}\r\n            color={\r\n              isActiveState\r\n                ? theme.edge.label.activeColor\r\n                : theme.edge.label.color\r\n            }\r\n            opacity={selectionOpacity}\r\n            fontSize={theme.edge.label.fontSize}\r\n            rotation={labelRotation}\r\n            active={isActiveState}\r\n          />\r\n\r\n          {subLabel && (\r\n            <group position={[subLabelOffset.x, subLabelOffset.y, 0]}>\r\n              <Label\r\n                text={subLabel}\r\n                ellipsis={15}\r\n                fontUrl={labelFontUrl}\r\n                stroke={theme.edge.subLabel?.stroke || theme.edge.label.stroke}\r\n                active={isActiveState}\r\n                color={\r\n                  isActiveState\r\n                    ? theme.edge.subLabel?.activeColor ||\r\n                      theme.edge.label.activeColor\r\n                    : theme.edge.subLabel?.color || theme.edge.label.color\r\n                }\r\n                opacity={selectionOpacity}\r\n                fontSize={\r\n                  theme.edge.subLabel?.fontSize ||\r\n                  theme.edge.label.fontSize * 0.8\r\n                }\r\n                rotation={labelRotation}\r\n              />\r\n            </group>\r\n          )}\r\n        </a.group>\r\n      ),\r\n    [\r\n      disabled,\r\n      edge,\r\n      isActiveState,\r\n      label,\r\n      subLabel,\r\n      labelFontUrl,\r\n      labelPosition,\r\n      subLabelOffset,\r\n      labelRotation,\r\n      labelVisible,\r\n      onContextMenu,\r\n      pointerOut,\r\n      pointerOver,\r\n      selectionOpacity,\r\n      theme.edge.label.activeColor,\r\n      theme.edge.label.color,\r\n      theme.edge.label.fontSize,\r\n      theme.edge.label.stroke,\r\n      theme.edge.subLabel?.stroke,\r\n      theme.edge.subLabel?.activeColor,\r\n      theme.edge.subLabel?.color,\r\n      theme.edge.subLabel?.fontSize\r\n    ]\r\n  );\r\n\r\n  const menuComponent = useMemo(\r\n    () =>\r\n      menuVisible &&\r\n      contextMenu && (\r\n        <Html prepend={true} center={true} position={midPoint}>\r\n          {contextMenu({ data: edge, onClose: () => setMenuVisible(false) })}\r\n        </Html>\r\n      ),\r\n    [menuVisible, contextMenu, midPoint, edge]\r\n  );\r\n\r\n  return (\r\n    <group position={[0, 0, isActiveState ? 1 : 0]}>\r\n      {isSelfLoop && selfLoopCurve ? (\r\n        <SelfLoop\r\n          id={id}\r\n          curve={selfLoopCurve}\r\n          size={size}\r\n          animated={animated}\r\n          color={\r\n            isActiveState ? theme.edge.activeFill : fill || theme.edge.fill\r\n          }\r\n          opacity={selectionOpacity}\r\n          onClick={event => {\r\n            if (!disabled) {\r\n              onClick?.(edge, event);\r\n            }\r\n          }}\r\n          onContextMenu={() => {\r\n            if (!disabled) {\r\n              setMenuVisible(true);\r\n              onContextMenu?.(edge);\r\n            }\r\n          }}\r\n          onPointerOver={pointerOver}\r\n          onPointerOut={pointerOut}\r\n        />\r\n      ) : (\r\n        <Line\r\n          curveOffset={curveOffset}\r\n          animated={animated}\r\n          color={\r\n            isActiveState ? theme.edge.activeFill : fill || theme.edge.fill\r\n          }\r\n          curve={curve}\r\n          curved={curved}\r\n          dashed={dashed}\r\n          dashArray={dashArray}\r\n          id={id}\r\n          opacity={selectionOpacity}\r\n          size={size}\r\n          renderOrder={isActiveState ? 0 : -1}\r\n          onClick={event => {\r\n            if (!disabled) {\r\n              onClick?.(edge, event);\r\n            }\r\n          }}\r\n          onPointerOver={pointerOver}\r\n          onPointerOut={pointerOut}\r\n          onContextMenu={() => {\r\n            if (!disabled) {\r\n              setMenuVisible(true);\r\n              onContextMenu?.(edge);\r\n            }\r\n          }}\r\n        />\r\n      )}\r\n      {arrowComponent}\r\n      {labelComponent}\r\n      {menuComponent}\r\n    </group>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { Html } from '@react-three/drei';\r\nimport type { FC } from 'react';\r\nimport React, { useCallback, useMemo } from 'react';\r\nimport type { ColorRepresentation } from 'three';\r\nimport { Euler } from 'three';\r\n\r\nimport { useStore } from '../../store';\r\nimport type { ContextMenuEvent, InternalGraphEdge } from '../../types';\r\nimport {\r\n  animationConfig,\r\n  getLabelOffsetByType,\r\n  getMidPoint\r\n} from '../../utils';\r\nimport { Label } from '../Label';\r\n\r\n/**\r\n * Label positions relatively edge\r\n *\r\n * below: show label under the edge line\r\n * above: show label above the edge line\r\n * inline: show label along the edge line\r\n * natural: normal text positions\r\n */\r\nexport type EdgeLabelPosition = 'below' | 'above' | 'inline' | 'natural';\r\n\r\nexport type EdgeArrowPosition = 'none' | 'mid' | 'end';\r\n\r\nexport interface EdgeProps {\r\n  /**\r\n   * Whether the edge should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Whether the edge should be disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The color of the edge.\r\n   */\r\n  color: ColorRepresentation;\r\n\r\n  /**\r\n   * A function that returns the context menu for the edge.\r\n   */\r\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\r\n\r\n  /**\r\n   * The edge object.\r\n   */\r\n  edge: InternalGraphEdge;\r\n\r\n  /**\r\n   * The URL of the font for the edge label.\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * The placement of the edge label.\r\n   */\r\n  labelPlacement?: EdgeLabelPosition;\r\n\r\n  /**\r\n   * The opacity of the edge.\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * Whether the edge is active.\r\n   */\r\n  active?: boolean;\r\n}\r\n\r\nexport const Edge: FC<EdgeProps> = ({\r\n  animated,\r\n  color,\r\n  contextMenu,\r\n  edge,\r\n  labelFontUrl,\r\n  labelPlacement = 'inline',\r\n  opacity,\r\n  active\r\n}) => {\r\n  const theme = useStore(state => state.theme);\r\n  const { target, source, label, labelVisible = false, size = 1 } = edge;\r\n\r\n  const nodes = useStore(store => store.nodes);\r\n  const [from, to] = useMemo(\r\n    () => [\r\n      nodes.find(node => node.id === source),\r\n      nodes.find(node => node.id === target)\r\n    ],\r\n    [nodes, source, target]\r\n  );\r\n  const isDragging = useStore(state => state.draggingIds.length > 0);\r\n\r\n  const labelOffset = useMemo(\r\n    () => (size + theme.edge.label.fontSize) / 2,\r\n    [size, theme.edge.label.fontSize]\r\n  );\r\n\r\n  const midPoint = useMemo(\r\n    () =>\r\n      getMidPoint(\r\n        from.position,\r\n        to.position,\r\n        getLabelOffsetByType(labelOffset, labelPlacement)\r\n      ),\r\n    [from.position, to.position, labelOffset, labelPlacement]\r\n  );\r\n\r\n  const edgeContextMenus = useStore(state => state.edgeContextMenus);\r\n  const setEdgeContextMenus = useStore(state => state.setEdgeContextMenus);\r\n\r\n  const [{ labelPosition }] = useSpring(\r\n    () => ({\r\n      from: {\r\n        labelPosition: [0, 0, 0]\r\n      },\r\n      to: {\r\n        labelPosition: [midPoint.x, midPoint.y, midPoint.z]\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated && !isDragging ? undefined : 0\r\n      }\r\n    }),\r\n    [midPoint, animated, isDragging]\r\n  );\r\n\r\n  const removeContextMenu = useCallback(\r\n    (edgeId: string) => {\r\n      const newEdgeContextMenus = new Set(edgeContextMenus);\r\n      newEdgeContextMenus.delete(edgeId);\r\n      setEdgeContextMenus(newEdgeContextMenus);\r\n    },\r\n    [edgeContextMenus, setEdgeContextMenus]\r\n  );\r\n\r\n  const labelRotation = useMemo(\r\n    () =>\r\n      new Euler(\r\n        0,\r\n        0,\r\n        labelPlacement === 'natural'\r\n          ? 0\r\n          : Math.atan(\r\n              (to.position.y - from.position.y) /\r\n                (to.position.x - from.position.x)\r\n            )\r\n      ),\r\n    [\r\n      to.position.x,\r\n      to.position.y,\r\n      from.position.x,\r\n      from.position.y,\r\n      labelPlacement\r\n    ]\r\n  );\r\n\r\n  const htmlProps = useMemo(\r\n    () => ({\r\n      prepend: true,\r\n      center: true,\r\n      position: midPoint\r\n    }),\r\n    [midPoint]\r\n  );\r\n\r\n  const labelProps = useMemo(\r\n    () => ({\r\n      text: label,\r\n      ellipsis: 15,\r\n      fontUrl: labelFontUrl,\r\n      stroke: theme.edge.label.stroke,\r\n      color,\r\n      opacity,\r\n      fontSize: theme.edge.label.fontSize,\r\n      rotation: labelRotation,\r\n      active\r\n    }),\r\n    [\r\n      label,\r\n      labelFontUrl,\r\n      theme.edge.label.stroke,\r\n      color,\r\n      opacity,\r\n      theme.edge.label.fontSize,\r\n      labelRotation,\r\n      active\r\n    ]\r\n  );\r\n\r\n  return (\r\n    <group>\r\n      {labelVisible && label && (\r\n        <a.group position={labelPosition as any}>\r\n          <Label\r\n            text={label}\r\n            fontUrl={labelFontUrl}\r\n            stroke={theme.edge.label.stroke}\r\n            color={color}\r\n            opacity={opacity}\r\n            fontSize={theme.edge.label.fontSize}\r\n            maxWidth={theme.edge.label.maxWidth}\r\n            ellipsis={theme.edge.label.ellipsis}\r\n            rotation={labelRotation}\r\n            backgroundColor={theme.edge.label.backgroundColor}\r\n            borderRadius={theme.edge.label.borderRadius}\r\n          />\r\n        </a.group>\r\n      )}\r\n      {contextMenu && edgeContextMenus.has(edge.id) && (\r\n        <Html {...htmlProps}>\r\n          {contextMenu({\r\n            data: edge,\r\n            onClose: () => removeContextMenu(edge.id)\r\n          })}\r\n        </Html>\r\n      )}\r\n    </group>\r\n  );\r\n};\r\n","import type { SpringValue } from '@react-spring/three';\r\nimport { useSpring } from '@react-spring/three';\r\nimport { useCallback, useEffect, useRef } from 'react';\r\nimport type { BufferGeometry } from 'three';\r\nimport { BufferAttribute } from 'three';\r\n\r\nimport type { Theme } from '../../themes';\r\nimport { animationConfig } from '../../utils';\r\n\r\nexport function useEdgePositionAnimation(\r\n  geometry: BufferGeometry,\r\n  animated: boolean\r\n): void {\r\n  const geometryRef = useRef<BufferGeometry>(geometry);\r\n  const bufferPool = useRef<Float32Array | null>(null);\r\n\r\n  useEffect(() => {\r\n    geometryRef.current = geometry;\r\n    const positions = geometry.getAttribute('position');\r\n    bufferPool.current = new Float32Array(positions.array.length);\r\n  }, [geometry]);\r\n\r\n  const getAnimationPositions = useCallback(() => {\r\n    const positions = geometryRef.current.getAttribute('position');\r\n    const from = new Float32Array(positions.array.length);\r\n    return {\r\n      from,\r\n      to: positions.array\r\n    };\r\n  }, []);\r\n\r\n  const updateGeometryPosition = useCallback((positions: Array<number>) => {\r\n    const buffer = bufferPool.current!;\r\n    buffer.set(positions);\r\n    const newPosition = new BufferAttribute(buffer, 3, false);\r\n    geometryRef.current.setAttribute('position', newPosition);\r\n    newPosition.needsUpdate = true;\r\n  }, []);\r\n\r\n  useSpring(() => {\r\n    if (!animated) {\r\n      return null;\r\n    }\r\n\r\n    const animationPositions = getAnimationPositions();\r\n\r\n    return {\r\n      from: {\r\n        positions: animationPositions.from\r\n      },\r\n      to: {\r\n        positions: animationPositions.to\r\n      },\r\n      onChange: event => {\r\n        updateGeometryPosition(event.value.positions);\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated ? undefined : 0\r\n      }\r\n    };\r\n  }, [animated, getAnimationPositions, updateGeometryPosition]);\r\n}\r\n\r\nexport type UseEdgeOpacityAnimations = {\r\n  activeOpacity: SpringValue<number>;\r\n  inactiveOpacity: SpringValue<number>;\r\n};\r\n\r\nexport function useEdgeOpacityAnimation(\r\n  animated: boolean,\r\n  hasSelections: boolean,\r\n  theme: Theme\r\n): UseEdgeOpacityAnimations {\r\n  const [{ activeOpacity, inactiveOpacity }] = useSpring(() => {\r\n    return {\r\n      from: {\r\n        activeOpacity: 0,\r\n        inactiveOpacity: 0\r\n      },\r\n      to: {\r\n        activeOpacity: hasSelections\r\n          ? theme.edge.selectedOpacity\r\n          : theme.edge.opacity,\r\n        inactiveOpacity: hasSelections\r\n          ? theme.edge.inactiveOpacity\r\n          : theme.edge.opacity\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated ? undefined : 0\r\n      }\r\n    };\r\n  }, [animated, hasSelections, theme]);\r\n\r\n  return { activeOpacity, inactiveOpacity };\r\n}\r\n","import { useCallback, useEffect, useRef } from 'react';\r\n\r\nimport { useStore } from '../../store';\r\nimport type { InternalGraphEdge } from '../../types';\r\n\r\nexport type EdgeEvents = {\r\n  onClick?: (edge: InternalGraphEdge) => void;\r\n  onContextMenu?: (edge?: InternalGraphEdge) => void;\r\n  onPointerOver?: (edge: InternalGraphEdge) => void;\r\n  onPointerOut?: (edge: InternalGraphEdge) => void;\r\n};\r\n\r\nexport function useEdgeEvents(\r\n  events: EdgeEvents,\r\n  contextMenu,\r\n  disabled: boolean\r\n) {\r\n  const memoizedEvents = useRef(events);\r\n  useEffect(() => {\r\n    memoizedEvents.current = events;\r\n  }, [events]);\r\n\r\n  const edgeContextMenus = useStore(state => state.edgeContextMenus);\r\n  const setEdgeContextMenus = useStore(\r\n    useCallback(state => state.setEdgeContextMenus, [])\r\n  );\r\n  const setHoveredEdgeIds = useStore(\r\n    useCallback(state => state.setHoveredEdgeIds, [])\r\n  );\r\n\r\n  const clickRef = useRef(false);\r\n  const handleClick = useCallback(() => {\r\n    clickRef.current = true;\r\n  }, []);\r\n\r\n  const contextMenuEventRef = useRef(false);\r\n  const handleContextMenu = useCallback(() => {\r\n    contextMenuEventRef.current = true;\r\n  }, []);\r\n\r\n  const handleIntersections = useCallback(\r\n    (\r\n      previous: Array<InternalGraphEdge>,\r\n      intersected: Array<InternalGraphEdge>\r\n    ) => {\r\n      const { onClick, onContextMenu, onPointerOver, onPointerOut } =\r\n        memoizedEvents.current;\r\n\r\n      if (onClick && clickRef.current && !disabled) {\r\n        clickRef.current = false;\r\n        for (const edge of intersected) {\r\n          onClick(edge);\r\n        }\r\n      }\r\n\r\n      if (\r\n        (contextMenu || onContextMenu) &&\r\n        contextMenuEventRef.current &&\r\n        !disabled\r\n      ) {\r\n        contextMenuEventRef.current = false;\r\n        const newEdges = new Set(edgeContextMenus);\r\n        let hasChanges = false;\r\n\r\n        for (const edge of intersected) {\r\n          if (!edgeContextMenus.has(edge.id)) {\r\n            newEdges.add(edge.id);\r\n            hasChanges = true;\r\n            onContextMenu?.(edge);\r\n          }\r\n        }\r\n\r\n        if (hasChanges) {\r\n          setEdgeContextMenus(newEdges);\r\n        }\r\n      }\r\n\r\n      const hoveredIds =\r\n        intersected.length > 0 ? intersected.map(edge => edge.id) : [];\r\n      setHoveredEdgeIds(hoveredIds);\r\n\r\n      if (onPointerOver) {\r\n        const over = intersected.filter(index => !previous.includes(index));\r\n        over.forEach(edge => {\r\n          onPointerOver(edge);\r\n        });\r\n      }\r\n\r\n      if (onPointerOut) {\r\n        const out = previous.filter(index => !intersected.includes(index));\r\n        out.forEach(edge => {\r\n          onPointerOut(edge);\r\n        });\r\n      }\r\n    },\r\n    [\r\n      contextMenu,\r\n      disabled,\r\n      edgeContextMenus,\r\n      setEdgeContextMenus,\r\n      setHoveredEdgeIds\r\n    ]\r\n  );\r\n\r\n  return {\r\n    handleClick,\r\n    handleContextMenu,\r\n    handleIntersections\r\n  };\r\n}\r\n","import { useCallback, useRef } from 'react';\r\nimport type { BufferGeometry, Curve } from 'three';\r\nimport {\r\n  Color,\r\n  CylinderGeometry,\r\n  Quaternion,\r\n  TubeGeometry,\r\n  Vector3\r\n} from 'three';\r\nimport { mergeBufferGeometries } from 'three-stdlib';\r\n\r\nimport type { GraphState } from '../../store';\r\nimport { useStore } from '../../store';\r\nimport type { InternalGraphEdge } from '../../types';\r\nimport {\r\n  addColorAttribute,\r\n  createDashedGeometry,\r\n  createNullGeometry,\r\n  getArrowSize,\r\n  getArrowVectors,\r\n  getCurve,\r\n  getSelfLoopCurve,\r\n  getVector\r\n} from '../../utils';\r\nimport type { EdgeArrowPosition } from '../Arrow';\r\nimport type { EdgeInterpolation } from '../Edge';\r\n\r\nexport type UseEdgeGeometry = {\r\n  getGeometries(edges: Array<InternalGraphEdge>): Array<BufferGeometry>;\r\n  getGeometry(\r\n    active: Array<InternalGraphEdge>,\r\n    inactive: Array<InternalGraphEdge>\r\n  ): BufferGeometry;\r\n};\r\n\r\nconst NULL_GEOMETRY = createNullGeometry();\r\n\r\nexport function useEdgeGeometry(\r\n  arrowPlacement: EdgeArrowPosition,\r\n  interpolation: EdgeInterpolation\r\n): UseEdgeGeometry {\r\n  // We don't want to rerun everything when the state changes,\r\n  // but we do want to use the most recent nodes whenever `getGeometries`\r\n  // or `getGeometry` is run, so we store it in a ref:\r\n  const stateRef = useRef<GraphState | null>(null);\r\n  const theme = useStore(state => state.theme);\r\n  useStore(state => {\r\n    stateRef.current = state;\r\n  });\r\n\r\n  const geometryCacheRef = useRef(new Map<string, BufferGeometry>());\r\n\r\n  // Add memoized geometry for arrows\r\n  const baseArrowGeometryRef = useRef<CylinderGeometry | null>(null);\r\n\r\n  const getGeometries = useCallback(\r\n    (edges: Array<InternalGraphEdge>): Array<BufferGeometry> => {\r\n      const geometries: Array<BufferGeometry> = [];\r\n      const cache = geometryCacheRef.current;\r\n\r\n      // Pre-compute values outside the loop\r\n      const { nodes } = stateRef.current;\r\n      const nodesMap = new Map(nodes.map(node => [node.id, node]));\r\n\r\n      // Initialize base arrow geometry if needed\r\n      if (arrowPlacement !== 'none' && !baseArrowGeometryRef.current) {\r\n        baseArrowGeometryRef.current = new CylinderGeometry(\r\n          0,\r\n          1,\r\n          1,\r\n          20,\r\n          1,\r\n          true\r\n        );\r\n      }\r\n\r\n      edges.forEach(edge => {\r\n        const { target, source, size = 1 } = edge;\r\n        const from = nodesMap.get(source);\r\n        const to = nodesMap.get(target);\r\n\r\n        if (!from || !to) {\r\n          return;\r\n        }\r\n        // Improved hash function to include size\r\n        const hash = `${from.position.x},${from.position.y},${to.position.x},${to.position.y},${size}`;\r\n\r\n        // Detect self-loop\r\n        const isSelfLoop = from.id === to.id;\r\n        // Determine interpolation for this specific edge\r\n        const edgeInterpolation = edge.interpolation || interpolation;\r\n        const curved = edgeInterpolation === 'curved';\r\n\r\n        // Determine arrow placement for this specific edge\r\n        const edgeArrowPlacement = edge.arrowPlacement || arrowPlacement;\r\n\r\n        if (cache.has(hash)) {\r\n          geometries.push(cache.get(hash));\r\n          return;\r\n        }\r\n        const fromVector = getVector(from);\r\n        const fromOffset = from.size;\r\n        const toVector = getVector(to);\r\n        const toOffset = to.size;\r\n\r\n        let curve: Curve<Vector3>;\r\n        if (isSelfLoop) {\r\n          // Self-loop curve\r\n          curve = getSelfLoopCurve(from);\r\n        } else {\r\n          // Regular edge curve\r\n          curve = getCurve(fromVector, fromOffset, toVector, toOffset, curved);\r\n        }\r\n\r\n        // Use smaller radius for dashed edges to match Line.tsx behavior\r\n        const isDashedEdge = edge.dashed;\r\n        const radius = isDashedEdge ? size * 0.4 : size / 2;\r\n\r\n        let edgeGeometry: BufferGeometry;\r\n        if (isDashedEdge) {\r\n          edgeGeometry = createDashedGeometry(\r\n            curve,\r\n            radius,\r\n            new Color(edge.fill ?? theme.edge.fill),\r\n            edge.dashArray\r\n          );\r\n        } else {\r\n          edgeGeometry = new TubeGeometry(curve, 20, radius, 5, false);\r\n        }\r\n\r\n        if (edgeArrowPlacement === 'none') {\r\n          // Add color to edge geometry for edges without arrows (only if not dashed, dashed already have colors)\r\n          if (!isDashedEdge) {\r\n            const edgeOnlyColor = new Color(edge.fill ?? theme.edge.fill);\r\n            addColorAttribute(edgeGeometry, edgeOnlyColor);\r\n          }\r\n\r\n          geometries.push(edgeGeometry);\r\n          cache.set(hash, edgeGeometry);\r\n          return;\r\n        }\r\n\r\n        // Reuse base arrow geometry and scale/rotate as needed\r\n        const [arrowLength, arrowSize] = getArrowSize(size);\r\n        const arrowGeometry = baseArrowGeometryRef.current.clone();\r\n        arrowGeometry.scale(arrowSize, arrowLength, arrowSize);\r\n\r\n        let arrowPosition: Vector3;\r\n        let arrowRotation: Vector3;\r\n\r\n        if (isSelfLoop) {\r\n          // Arrow positioning for self-loop\r\n          const uEnd = 0.58;\r\n          const uMid = 0.25;\r\n          if (edgeArrowPlacement === 'mid') {\r\n            arrowPosition = curve.getPointAt(uMid);\r\n            arrowRotation = curve.getTangentAt(uMid);\r\n          } else {\r\n            // end is default\r\n            arrowPosition = curve.getPointAt(uEnd);\r\n            arrowRotation = curve.getTangentAt(uEnd);\r\n          }\r\n        } else {\r\n          // Regular arrow positioning\r\n          [arrowPosition, arrowRotation] = getArrowVectors(\r\n            edgeArrowPlacement,\r\n            curve,\r\n            arrowLength\r\n          );\r\n        }\r\n\r\n        const quaternion = new Quaternion();\r\n        quaternion.setFromUnitVectors(new Vector3(0, 1, 0), arrowRotation);\r\n        arrowGeometry.applyQuaternion(quaternion);\r\n        arrowGeometry.translate(\r\n          arrowPosition.x,\r\n          arrowPosition.y,\r\n          arrowPosition.z\r\n        );\r\n\r\n        // Move edge so it doesn't stick through the arrow:\r\n        if (edgeArrowPlacement && edgeArrowPlacement === 'end' && !isSelfLoop) {\r\n          const adjustedCurve = getCurve(\r\n            fromVector,\r\n            fromOffset,\r\n            arrowPosition,\r\n            0,\r\n            curved\r\n          );\r\n\r\n          if (isDashedEdge) {\r\n            edgeGeometry = createDashedGeometry(\r\n              adjustedCurve,\r\n              radius,\r\n              new Color(edge.fill ?? theme.edge.fill),\r\n              edge.dashArray\r\n            );\r\n          } else {\r\n            edgeGeometry = new TubeGeometry(\r\n              adjustedCurve,\r\n              20,\r\n              radius,\r\n              5,\r\n              false\r\n            );\r\n          }\r\n        }\r\n\r\n        // Add color attributes to both geometries (only for non-dashed, dashed already have colors)\r\n        const finalColor = new Color(edge.fill ?? theme.edge.fill);\r\n\r\n        if (!isDashedEdge) {\r\n          addColorAttribute(edgeGeometry, finalColor);\r\n        }\r\n        addColorAttribute(arrowGeometry, finalColor);\r\n\r\n        const merged = mergeBufferGeometries([edgeGeometry, arrowGeometry]);\r\n        merged.userData = { ...merged.userData, type: 'edge' };\r\n        geometries.push(merged);\r\n        cache.set(hash, merged);\r\n      });\r\n      return geometries;\r\n    },\r\n    [arrowPlacement, interpolation, theme.edge.fill]\r\n  );\r\n\r\n  const getGeometry = useCallback(\r\n    (\r\n      active: Array<InternalGraphEdge>,\r\n      inactive: Array<InternalGraphEdge>\r\n    ): BufferGeometry => {\r\n      const activeGeometries = getGeometries(active);\r\n      const inactiveGeometries = getGeometries(inactive);\r\n\r\n      return mergeBufferGeometries(\r\n        [\r\n          inactiveGeometries.length\r\n            ? mergeBufferGeometries(inactiveGeometries)\r\n            : NULL_GEOMETRY,\r\n          activeGeometries.length\r\n            ? mergeBufferGeometries(activeGeometries)\r\n            : NULL_GEOMETRY\r\n        ],\r\n        true\r\n      );\r\n    },\r\n    [getGeometries]\r\n  );\r\n\r\n  return {\r\n    getGeometries,\r\n    getGeometry\r\n  };\r\n}\r\n","import { a } from '@react-spring/three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport type { FC } from 'react';\r\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\r\nimport type { Raycaster, TubeGeometry } from 'three';\r\nimport { DoubleSide, Mesh } from 'three';\r\n\r\nimport { useStore } from '../../store';\r\nimport type { ContextMenuEvent, InternalGraphEdge } from '../../types';\r\nimport type { EdgeArrowPosition } from '../Arrow';\r\nimport type { EdgeInterpolation, EdgeLabelPosition } from '../Edge';\r\nimport { Edge } from './Edge';\r\nimport {\r\n  useEdgeOpacityAnimation,\r\n  useEdgePositionAnimation\r\n} from './useEdgeAnimations';\r\nimport type { EdgeEvents } from './useEdgeEvents';\r\nimport { useEdgeEvents } from './useEdgeEvents';\r\nimport { useEdgeGeometry } from './useEdgeGeometry';\r\n\r\nexport type EdgesProps = {\r\n  /**\r\n   * Whether the edge should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * The placement of the edge arrow.\r\n   */\r\n  arrowPlacement?: EdgeArrowPosition;\r\n\r\n  /**\r\n   * A function that returns the context menu for the edge.\r\n   */\r\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\r\n\r\n  /**\r\n   * Whether the edge should be disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The array of edge objects.\r\n   */\r\n  edges: Array<InternalGraphEdge>;\r\n\r\n  /**\r\n   * The URL of the font for the edge label.\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * The placement of the edge label.\r\n   */\r\n  labelPlacement?: EdgeLabelPosition;\r\n\r\n  /**\r\n   * The type of interpolation used to draw the edge.\r\n   */\r\n  interpolation?: EdgeInterpolation;\r\n} & EdgeEvents;\r\n\r\n/**\r\n * Three.js rendering starts to get slower if you have an individual mesh for each edge\r\n * and a high number of edges.\r\n *\r\n * Instead, we take the edges and split them into their different render states:\r\n *\r\n *  * - Active (any edges that are marked as \"selected\" or \"active\" in the state)\r\n *  * - Dragging (any edges that are connected to a node that is being dragged)\r\n *  * - Intersecting (any edges that are currently intersected by the ray from the mouse position)\r\n *  * - Inactive (any edges that aren't active, dragging, or intersected)\r\n *\r\n * We generate the geometry for each edge in each of these groups, and then merge them\r\n * into a single geometry for each group. This merged mesh is rendered as one object\r\n * which gives much better performance. This means that we only need to update geometry\r\n * and positions when edges move between the different states, rather than updating all\r\n * edges whenever any other edge changes.\r\n *\r\n * To get this all working, we have to do a few things outside the @react-three/fiber world,\r\n * specifically:\r\n *\r\n *  * manually create edge/arrow geometries (see `useEdgeGeometry`)\r\n *  * manually track mouse/edge interactions and fire events (see `useEdgeEvents`)\r\n *  * manually update edge/arrow positions during aniamations (see `useEdgeAnimations`)\r\n */\r\nexport const Edges: FC<EdgesProps> = ({\r\n  interpolation = 'linear',\r\n  arrowPlacement = 'end',\r\n  labelPlacement = 'inline',\r\n  animated,\r\n  contextMenu,\r\n  disabled,\r\n  edges,\r\n  labelFontUrl,\r\n  onClick,\r\n  onContextMenu,\r\n  onPointerOut,\r\n  onPointerOver\r\n}) => {\r\n  const theme = useStore(state => state.theme);\r\n  const { getGeometries, getGeometry } = useEdgeGeometry(\r\n    arrowPlacement,\r\n    interpolation\r\n  );\r\n\r\n  const draggingIds = useStore(state => state.draggingIds);\r\n  const edgeMeshes = useStore(state => state.edgeMeshes);\r\n  const setEdgeMeshes = useStore(state => state.setEdgeMeshes);\r\n  const actives = useStore(state => state.actives || []);\r\n  const selections = useStore(state => state.selections || []);\r\n  const hoveredEdgeIds = useStore(state => state.hoveredEdgeIds || []);\r\n\r\n  const [active, inactive, draggingActive, draggingInactive] = useMemo(() => {\r\n    const active: Array<InternalGraphEdge> = [];\r\n    const inactive: Array<InternalGraphEdge> = [];\r\n    const draggingActive: Array<InternalGraphEdge> = [];\r\n    const draggingInactive: Array<InternalGraphEdge> = [];\r\n    edges.forEach(edge => {\r\n      if (\r\n        draggingIds.includes(edge.source) ||\r\n        draggingIds.includes(edge.target)\r\n      ) {\r\n        if (\r\n          selections.includes(edge.id) ||\r\n          actives.includes(edge.id) ||\r\n          hoveredEdgeIds.includes(edge.id)\r\n        ) {\r\n          draggingActive.push(edge);\r\n        } else {\r\n          draggingInactive.push(edge);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (\r\n        selections.includes(edge.id) ||\r\n        actives.includes(edge.id) ||\r\n        hoveredEdgeIds.includes(edge.id)\r\n      ) {\r\n        active.push(edge);\r\n      } else {\r\n        inactive.push(edge);\r\n      }\r\n    });\r\n    return [active, inactive, draggingActive, draggingInactive];\r\n  }, [edges, actives, selections, draggingIds, hoveredEdgeIds]);\r\n\r\n  const hasSelections = !!selections.length;\r\n\r\n  const staticEdgesGeometry = useMemo(\r\n    () => getGeometry(active, inactive),\r\n    [getGeometry, active, inactive]\r\n  );\r\n\r\n  const { activeOpacity, inactiveOpacity } = useEdgeOpacityAnimation(\r\n    animated,\r\n    hasSelections,\r\n    theme\r\n  );\r\n\r\n  useEdgePositionAnimation(staticEdgesGeometry, animated);\r\n\r\n  useEffect(() => {\r\n    if (draggingIds.length === 0) {\r\n      const edgeGeometries = getGeometries(edges);\r\n      const edgeMeshes = edgeGeometries.map(edge => new Mesh(edge));\r\n      setEdgeMeshes(edgeMeshes);\r\n    }\r\n  }, [getGeometries, setEdgeMeshes, edges, draggingIds.length]);\r\n\r\n  const staticEdgesRef = useRef(new Mesh());\r\n  const dynamicEdgesRef = useRef(new Mesh());\r\n\r\n  const intersect = useCallback(\r\n    (raycaster: Raycaster): Array<InternalGraphEdge> => {\r\n      // Handle initial raycaster state:\r\n      if (!raycaster.camera) {\r\n        return [];\r\n      }\r\n      const intersections =\r\n        raycaster.intersectObjects<Mesh<TubeGeometry>>(edgeMeshes);\r\n      if (!intersections.length) {\r\n        return [];\r\n      }\r\n      return intersections.map(\r\n        intersection => edges[edgeMeshes.indexOf(intersection.object)]\r\n      );\r\n    },\r\n    [edgeMeshes, edges]\r\n  );\r\n\r\n  const { handleClick, handleContextMenu, handleIntersections } = useEdgeEvents(\r\n    {\r\n      onClick,\r\n      onContextMenu,\r\n      onPointerOut,\r\n      onPointerOver\r\n    },\r\n    contextMenu,\r\n    disabled\r\n  );\r\n\r\n  const draggingIdRef = useRef<string[]>([]);\r\n  const intersectingRef = useRef<Array<InternalGraphEdge>>([]);\r\n\r\n  useFrame(state => {\r\n    staticEdgesRef.current.geometry = staticEdgesGeometry;\r\n\r\n    if (disabled) {\r\n      return;\r\n    }\r\n\r\n    const previousDraggingId = draggingIdRef.current;\r\n    if (\r\n      draggingIds.length ||\r\n      (draggingIds.length === 0 && previousDraggingId !== null)\r\n    ) {\r\n      dynamicEdgesRef.current.geometry = getGeometry(\r\n        draggingActive,\r\n        draggingInactive\r\n      );\r\n    }\r\n\r\n    draggingIdRef.current = draggingIds;\r\n    if (draggingIds.length) {\r\n      return;\r\n    }\r\n\r\n    const previousIntersecting = intersectingRef.current;\r\n    const intersecting = intersect(state.raycaster);\r\n    handleIntersections(previousIntersecting, intersecting);\r\n\r\n    if (intersecting.join() !== previousIntersecting.join()) {\r\n      dynamicEdgesRef.current.geometry = getGeometry(intersecting, []);\r\n    }\r\n\r\n    intersectingRef.current = intersecting;\r\n  });\r\n\r\n  return (\r\n    <group onClick={handleClick} onContextMenu={handleContextMenu}>\r\n      {/* Static edges */}\r\n      <mesh ref={staticEdgesRef}>\r\n        <a.meshBasicMaterial\r\n          attach=\"material-0\"\r\n          color={theme.edge.fill}\r\n          depthTest={true}\r\n          fog={true}\r\n          opacity={inactiveOpacity}\r\n          side={DoubleSide}\r\n          transparent={true}\r\n          vertexColors={true}\r\n        />\r\n        <a.meshBasicMaterial\r\n          attach=\"material-1\"\r\n          color={theme.edge.activeFill}\r\n          depthTest={true}\r\n          fog={true}\r\n          opacity={activeOpacity}\r\n          side={DoubleSide}\r\n          transparent={true}\r\n        />\r\n      </mesh>\r\n      {/* Dynamic edges */}\r\n      <mesh ref={dynamicEdgesRef}>\r\n        <a.meshBasicMaterial\r\n          attach=\"material-0\"\r\n          color={theme.edge.fill}\r\n          depthTest={true}\r\n          fog={true}\r\n          opacity={inactiveOpacity}\r\n          side={DoubleSide}\r\n          transparent={true}\r\n        />\r\n        <a.meshBasicMaterial\r\n          attach=\"material-1\"\r\n          color={theme.edge.activeFill}\r\n          depthTest={true}\r\n          fog={true}\r\n          opacity={activeOpacity}\r\n          side={DoubleSide}\r\n          transparent={true}\r\n        />\r\n      </mesh>\r\n      {edges.map(edge => {\r\n        const isSelected = selections.includes(edge.id);\r\n        const isActive = actives.includes(edge.id);\r\n        const isHovered = hoveredEdgeIds.includes(edge.id);\r\n\r\n        return (\r\n          <Edge\r\n            animated={animated}\r\n            contextMenu={contextMenu}\r\n            color={\r\n              isSelected || isActive || isHovered\r\n                ? theme.edge.label.activeColor\r\n                : theme.edge.label.color\r\n            }\r\n            disabled={disabled}\r\n            edge={edge}\r\n            key={edge.id}\r\n            labelFontUrl={labelFontUrl}\r\n            labelPlacement={labelPlacement}\r\n            active={isSelected || isActive || isHovered}\r\n          />\r\n        );\r\n      })}\r\n    </group>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { Billboard, Image, RoundedBox, Text } from '@react-three/drei';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport { Color } from 'three';\r\n\r\nimport type { NodeRendererProps } from '../../types';\r\nimport { animationConfig } from '../../utils';\r\nimport { measureText } from '../../utils/textMeasurement';\r\n\r\nexport type BadgePosition =\r\n  | 'top-right'\r\n  | 'top-left'\r\n  | 'bottom-right'\r\n  | 'bottom-left'\r\n  | 'center';\r\n\r\nexport type IconPosition = 'start' | 'end';\r\n\r\nexport interface BadgeProps extends Omit<NodeRendererProps, 'opacity'> {\r\n  /**\r\n   * The text to display in the badge.\r\n   */\r\n  label: string;\r\n\r\n  /**\r\n   * Background color of the badge.\r\n   */\r\n  backgroundColor?: string;\r\n\r\n  /**\r\n   * Opacity of the badge background and stroke (0-1).\r\n   * Default: 1\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * Text color of the badge.\r\n   */\r\n  textColor?: string;\r\n\r\n  /**\r\n   * Stroke color of the badge border.\r\n   */\r\n  strokeColor?: string;\r\n\r\n  /**\r\n   * Size of the badge border stroke.\r\n   */\r\n  strokeWidth?: number;\r\n\r\n  /**\r\n   * Corner radius of the badge.\r\n   */\r\n  radius?: number;\r\n\r\n  /**\r\n   * Size multiplier for the badge relative to the node size.\r\n   */\r\n  badgeSize?: number;\r\n\r\n  /**\r\n   * Position offset from the node center or preset position.\r\n   */\r\n  position?: [number, number, number] | BadgePosition;\r\n\r\n  /**\r\n   * Padding around the badge text.\r\n   * Default: 0.15\r\n   */\r\n  padding?: number;\r\n\r\n  /**\r\n   * SVG icon path or URL to display in the badge.\r\n   */\r\n  icon?: string;\r\n\r\n  /**\r\n   * Size of the icon in the badge.\r\n   */\r\n  iconSize?: number;\r\n\r\n  /**\r\n   * Position of the icon relative to the text or custom coordinates [x, y].\r\n   * - 'start': Icon appears before the text (left side)\r\n   * - 'end': Icon appears after the text (right side)\r\n   * - [x, y]: Custom coordinates within the badge. When using custom coordinates,\r\n   *   the text remains centered and only the icon moves to the specified position.\r\n   */\r\n  iconPosition?: IconPosition | [number, number];\r\n\r\n  /**\r\n   * Font size for the badge text.\r\n   */\r\n  fontSize?: number;\r\n\r\n  /**\r\n   * Font weight for the badge text (100-900).\r\n   * Values outside this range will be clamped to the nearest valid value.\r\n   * Common values: 400 (normal), 700 (bold), 900 (extra bold).\r\n   */\r\n  fontWeight?: number;\r\n\r\n  /**\r\n   * Gap between icon and text.\r\n   * Default: 0.01\r\n   */\r\n  iconTextGap?: number;\r\n}\r\n\r\nconst DEFAULT_FONT_SIZE = 0.3;\r\n\r\nexport const Badge: FC<BadgeProps> = ({\r\n  label,\r\n  size,\r\n  opacity = 1,\r\n  animated,\r\n  backgroundColor = '#ffffff',\r\n  textColor = '#000000',\r\n  strokeColor,\r\n  strokeWidth = 0,\r\n  radius = 0.12,\r\n  badgeSize = 1.5,\r\n  position = 'top-right',\r\n  padding = 0.15,\r\n  icon,\r\n  iconSize = 0.35,\r\n  iconPosition = 'start',\r\n  fontSize = DEFAULT_FONT_SIZE,\r\n  fontWeight,\r\n  iconTextGap = 0.01\r\n}) => {\r\n  const normalizedBgColor = useMemo(\r\n    () => new Color(backgroundColor),\r\n    [backgroundColor]\r\n  );\r\n  const normalizedTextColor = useMemo(() => new Color(textColor), [textColor]);\r\n  const normalizedStrokeColor = useMemo(\r\n    () => (strokeColor ? new Color(strokeColor) : null),\r\n    [strokeColor]\r\n  );\r\n  // Guard for radius\r\n  const normalizedRadius = Math.min(radius, 0.2);\r\n\r\n  // Normalize fontWeight to valid CSS font-weight values (100-900 in increments of 100)\r\n  const normalizedFontWeight = useMemo(() => {\r\n    if (fontWeight === undefined) return undefined;\r\n    // Round to nearest hundred and clamp to 100-900 range\r\n    return Math.max(100, Math.min(900, Math.round(fontWeight / 100) * 100));\r\n  }, [fontWeight]);\r\n\r\n  // Calculate position based on preset or custom coordinates\r\n  const badgePosition = useMemo((): [number, number, number] => {\r\n    if (Array.isArray(position)) {\r\n      return position;\r\n    }\r\n\r\n    const offset = size * 0.65;\r\n    switch (position) {\r\n      case 'top-right':\r\n        return [offset, offset, 11];\r\n      case 'top-left':\r\n        return [-offset, offset, 11];\r\n      case 'bottom-right':\r\n        return [offset, -offset, 11];\r\n      case 'bottom-left':\r\n        return [-offset, -offset, 11];\r\n      case 'center':\r\n        return [0, 0, 11];\r\n      default:\r\n        return [offset, offset, 11];\r\n    }\r\n  }, [position, size]);\r\n\r\n  // Shared text size calculations (used by both badgeDimensions and contentLayout)\r\n  const textSizeCalculations = useMemo(() => {\r\n    const fontSizeScale = fontSize / DEFAULT_FONT_SIZE;\r\n    const fontWeightMultiplier = (normalizedFontWeight ?? 0) >= 700 ? 1.1 : 1;\r\n\r\n    // Use Canvas measureText for accurate width when charWidthEstimate is not provided\r\n    const measured = measureText({\r\n      text: label,\r\n      fontSize,\r\n      fontWeight: normalizedFontWeight\r\n    });\r\n    const estimatedTextWidth = measured.width;\r\n\r\n    return {\r\n      fontSizeScale,\r\n      fontWeightMultiplier,\r\n      estimatedTextWidth\r\n    };\r\n  }, [fontSize, normalizedFontWeight, label]);\r\n\r\n  // Calculate dynamic badge dimensions based on text length and icon\r\n  const badgeDimensions = useMemo(() => {\r\n    const baseWidth = 0.5;\r\n    const baseHeight = 0.5;\r\n    const minWidth = baseWidth;\r\n    const minHeight = baseHeight;\r\n\r\n    const { fontSizeScale, estimatedTextWidth } = textSizeCalculations;\r\n\r\n    // Calculate content width (text + icon + gap, no padding yet)\r\n    let contentWidth = estimatedTextWidth;\r\n    if (icon) {\r\n      contentWidth += iconSize + iconTextGap;\r\n    }\r\n\r\n    // Add padding to total width (padding on both left and right sides)\r\n    const estimatedWidth = Math.max(minWidth, contentWidth + padding * 2);\r\n\r\n    // Scale height based on fontSize\r\n    const charCount = label?.length;\r\n    const estimatedHeight = Math.max(\r\n      minHeight,\r\n      Math.min(\r\n        charCount * 0.05 * fontSizeScale + padding * 0.5,\r\n        0.8 * fontSizeScale + padding * 0.5\r\n      )\r\n    );\r\n\r\n    return {\r\n      width: estimatedWidth,\r\n      height: estimatedHeight\r\n    };\r\n  }, [\r\n    textSizeCalculations,\r\n    label?.length,\r\n    padding,\r\n    icon,\r\n    iconSize,\r\n    iconTextGap\r\n  ]);\r\n\r\n  const { scale } = useSpring({\r\n    from: {\r\n      scale: [0.00001, 0.00001, 0.00001]\r\n    },\r\n    to: {\r\n      scale: [size * badgeSize, size * badgeSize, size * badgeSize]\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  // Calculate content layout positions for icon and text\r\n  const contentLayout = useMemo(() => {\r\n    if (!icon) {\r\n      return {\r\n        textX: 0,\r\n        textY: 0,\r\n        iconX: 0,\r\n        iconY: 0\r\n      };\r\n    }\r\n\r\n    // If custom position is provided as an array\r\n    if (Array.isArray(iconPosition)) {\r\n      return {\r\n        iconX: iconPosition[0],\r\n        iconY: iconPosition[1],\r\n        textX: 0,\r\n        textY: 0\r\n      };\r\n    }\r\n\r\n    const { estimatedTextWidth } = textSizeCalculations;\r\n    const totalContentWidth = iconSize + iconTextGap + estimatedTextWidth;\r\n    const startX = -totalContentWidth / 2;\r\n\r\n    if (iconPosition === 'start') {\r\n      return {\r\n        iconX: startX + iconSize / 2,\r\n        iconY: 0,\r\n        textX: startX + iconSize + iconTextGap + estimatedTextWidth / 2,\r\n        textY: 0\r\n      };\r\n    } else {\r\n      return {\r\n        textX: startX + estimatedTextWidth / 2,\r\n        textY: 0,\r\n        iconX: startX + estimatedTextWidth + iconTextGap + iconSize / 2,\r\n        iconY: 0\r\n      };\r\n    }\r\n  }, [textSizeCalculations, icon, iconSize, iconPosition, iconTextGap]);\r\n\r\n  return (\r\n    <Billboard position={badgePosition}>\r\n      <a.group scale={scale as any} renderOrder={2}>\r\n        {/* Stroke layer */}\r\n        {strokeWidth > 0 && normalizedStrokeColor && (\r\n          <a.mesh position={[0, 0, 0.9]}>\r\n            <RoundedBox\r\n              args={[\r\n                badgeDimensions.width + strokeWidth,\r\n                badgeDimensions.height + strokeWidth,\r\n                0.01\r\n              ]}\r\n              radius={normalizedRadius}\r\n              smoothness={8}\r\n              material-color={normalizedStrokeColor}\r\n              material-transparent={true}\r\n              material-opacity={opacity}\r\n            />\r\n          </a.mesh>\r\n        )}\r\n        {/* Main background layer */}\r\n        <a.mesh position={[0, 0, 1]}>\r\n          <RoundedBox\r\n            args={[badgeDimensions.width, badgeDimensions.height, 0.01]} // dynamic width, height, depth\r\n            radius={normalizedRadius} // corner radius\r\n            smoothness={8}\r\n            material-color={normalizedBgColor}\r\n            material-transparent={true}\r\n            material-opacity={opacity}\r\n          />\r\n        </a.mesh>\r\n        {/* Icon */}\r\n        {icon && (\r\n          <Image\r\n            url={icon}\r\n            position={[contentLayout.iconX, contentLayout.iconY, 1.1]}\r\n            scale={[iconSize, iconSize]}\r\n            transparent\r\n            material-depthTest={false}\r\n            material-depthWrite={false}\r\n          />\r\n        )}\r\n        {/* Text */}\r\n        <Text\r\n          position={[contentLayout.textX, contentLayout.textY, 1.1]}\r\n          fontSize={fontSize}\r\n          fontWeight={normalizedFontWeight}\r\n          color={normalizedTextColor}\r\n          anchorX=\"center\"\r\n          anchorY=\"middle\"\r\n          textAlign=\"center\"\r\n          material-depthTest={false}\r\n          material-depthWrite={false}\r\n        >\r\n          {label}\r\n        </Text>\r\n      </a.group>\r\n    </Billboard>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport { DoubleSide, LinearFilter, TextureLoader } from 'three';\r\n\r\nimport type { NodeRendererProps } from '../../types';\r\nimport { animationConfig } from '../../utils';\r\n\r\nexport interface IconProps extends NodeRendererProps {\r\n  /**\r\n   * The image to display on the icon.\r\n   */\r\n  image: string;\r\n}\r\n\r\nexport const Icon: FC<IconProps> = ({\r\n  image,\r\n  id,\r\n  size,\r\n  opacity = 1,\r\n  animated\r\n}) => {\r\n  const texture = useMemo(() => new TextureLoader().load(image), [image]);\r\n\r\n  const { scale, spriteOpacity } = useSpring({\r\n    from: {\r\n      scale: [0.00001, 0.00001, 0.00001],\r\n      spriteOpacity: 0\r\n    },\r\n    to: {\r\n      scale: [size, size, size],\r\n      spriteOpacity: opacity\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  return (\r\n    <a.sprite userData={{ id, type: 'node' }} scale={scale as any}>\r\n      <a.spriteMaterial\r\n        attach=\"material\"\r\n        opacity={spriteOpacity}\r\n        fog={true}\r\n        depthTest={false}\r\n        transparent={true}\r\n        side={DoubleSide}\r\n      >\r\n        <primitive attach=\"map\" object={texture} minFilter={LinearFilter} />\r\n      </a.spriteMaterial>\r\n    </a.sprite>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { Billboard } from '@react-three/drei';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport type { ColorRepresentation } from 'three';\r\nimport { Color, DoubleSide } from 'three';\r\n\r\nimport { animationConfig } from '../utils/animation';\r\n\r\nexport interface RingProps {\r\n  /**\r\n   * The color of the ring.\r\n   */\r\n  color?: ColorRepresentation;\r\n\r\n  /**\r\n   * Whether the ring should be animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * The size of the ring.\r\n   */\r\n  size?: number;\r\n\r\n  /**\r\n   * The opacity of the ring.\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * The stroke width of the ring.\r\n   */\r\n  strokeWidth?: number;\r\n\r\n  /**\r\n   * The inner radius of the ring.\r\n   * Default value: 4\r\n   */\r\n  innerRadius?: number;\r\n\r\n  /**\r\n   * The number of segments in the ring geometry.\r\n   * Default value: 25\r\n   */\r\n  segments?: number;\r\n}\r\n\r\nexport const Ring: FC<RingProps> = ({\r\n  color = '#D8E6EA',\r\n  size = 1,\r\n  opacity = 0.5,\r\n  animated,\r\n  strokeWidth,\r\n  innerRadius = 2,\r\n  segments = 50\r\n}) => {\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n\r\n  const { ringSize, ringOpacity } = useSpring({\r\n    from: {\r\n      ringOpacity: 0,\r\n      ringSize: [0.00001, 0.00001, 0.00001]\r\n    },\r\n    to: {\r\n      ringOpacity: opacity,\r\n      ringSize: [size / 2, size / 2, 1]\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  const strokeWidthFraction = strokeWidth / 10;\r\n  const outerRadius = innerRadius + strokeWidthFraction;\r\n\r\n  return (\r\n    <Billboard position={[0, 0, 1]}>\r\n      <a.mesh\r\n        scale={ringSize as any}\r\n        // Disabling raycast/pointer events when ring is invisible (opacity = 0)\r\n        // This prevents invisible rings highlighting parent nodes when hovered over\r\n        raycast={opacity > 0 ? undefined : () => []}\r\n      >\r\n        <ringGeometry\r\n          attach=\"geometry\"\r\n          args={[innerRadius, outerRadius, segments]}\r\n        />\r\n        <a.meshBasicMaterial\r\n          attach=\"material\"\r\n          color={normalizedColor}\r\n          transparent={true}\r\n          depthTest={true}\r\n          opacity={ringOpacity}\r\n          side={DoubleSide}\r\n          fog={true}\r\n        />\r\n      </a.mesh>\r\n    </Billboard>\r\n  );\r\n};\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport { Color, DoubleSide } from 'three';\r\n\r\nimport { useStore } from '../../store';\r\nimport type { NodeRendererProps } from '../../types';\r\nimport { animationConfig } from '../../utils/animation';\r\nimport { Ring } from '../Ring';\r\n\r\nexport const Sphere: FC<NodeRendererProps> = ({\r\n  color,\r\n  id,\r\n  size,\r\n  selected,\r\n  active,\r\n  opacity,\r\n  animated,\r\n  showRing\r\n}) => {\r\n  const { scale, nodeOpacity } = useSpring({\r\n    from: {\r\n      // Note: This prevents incorrect scaling w/ 0\r\n      scale: [0.00001, 0.00001, 0.00001],\r\n      nodeOpacity: 0\r\n    },\r\n    to: {\r\n      scale: active\r\n        ? [size * 1.05, size * 1.05, size * 1.05]\r\n        : [size, size, size],\r\n      nodeOpacity: opacity\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n  const theme = useStore(state => state.theme);\r\n\r\n  return (\r\n    <>\r\n      <a.mesh userData={{ id, type: 'node' }} scale={scale as any}>\r\n        <sphereGeometry attach=\"geometry\" args={[1, 25, 25]} />\r\n        <a.meshPhongMaterial\r\n          attach=\"material\"\r\n          side={DoubleSide}\r\n          transparent={true}\r\n          fog={true}\r\n          opacity={nodeOpacity}\r\n          color={normalizedColor}\r\n          emissive={normalizedColor}\r\n          emissiveIntensity={0.7}\r\n        />\r\n      </a.mesh>\r\n      {(showRing || selected || active) && (\r\n        <a.mesh position={[0, 0, 0]}>\r\n          <Ring\r\n            opacity={1}\r\n            size={size / 1}\r\n            animated={animated}\r\n            color={theme.ring.activeFill}\r\n            strokeWidth={5}\r\n          />\r\n        </a.mesh>\r\n      )}\r\n    </>\r\n  );\r\n};\r\n","import type { FC } from 'react';\r\nimport React from 'react';\r\n\r\nimport type { NodeRendererProps } from '../../types';\r\nimport { Icon } from './Icon';\r\nimport { Sphere } from './Sphere';\r\n\r\nexport interface SphereWithIconProps extends NodeRendererProps {\r\n  /**\r\n   * The image to display on the icon.\r\n   */\r\n  image: string;\r\n}\r\n\r\nexport const SphereWithIcon: FC<SphereWithIconProps> = ({\r\n  color,\r\n  id,\r\n  size,\r\n  opacity = 1,\r\n  node,\r\n  active = false,\r\n  animated,\r\n  image,\r\n  selected\r\n}) => (\r\n  <>\r\n    <Sphere\r\n      id={id}\r\n      selected={selected}\r\n      size={size}\r\n      opacity={opacity}\r\n      animated={animated}\r\n      color={color}\r\n      node={node}\r\n      active={active}\r\n      showRing={node.showRing}\r\n    />\r\n    <Icon\r\n      id={id}\r\n      image={image}\r\n      selected={selected}\r\n      size={size + 8}\r\n      opacity={opacity}\r\n      animated={animated}\r\n      color={color}\r\n      node={node}\r\n      active={active}\r\n    />\r\n  </>\r\n);\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport type { SvgProps as DreiSvgProps } from '@react-three/drei';\r\nimport { Billboard, Svg as DreiSvg } from '@react-three/drei';\r\nimport type { FC } from 'react';\r\nimport React, { useMemo } from 'react';\r\nimport { Color, DoubleSide } from 'three';\r\n\r\nimport type { NodeRendererProps } from '../../types';\r\nimport { animationConfig } from '../../utils';\r\n\r\nexport type SvgProps = NodeRendererProps &\r\n  Omit<DreiSvgProps, 'src' | 'id'> & {\r\n    /**\r\n     * The image to display on the icon.\r\n     */\r\n    image: string;\r\n  };\r\n\r\nexport const Svg: FC<SvgProps> = ({\r\n  id,\r\n  image,\r\n  color,\r\n  size,\r\n  opacity = 1,\r\n  animated,\r\n  ...rest\r\n}) => {\r\n  const normalizedSize = size / 25;\r\n\r\n  const { scale } = useSpring({\r\n    from: {\r\n      scale: [0.00001, 0.00001, 0.00001]\r\n    },\r\n    to: {\r\n      scale: [normalizedSize, normalizedSize, normalizedSize]\r\n    },\r\n    config: {\r\n      ...animationConfig,\r\n      duration: animated ? undefined : 0\r\n    }\r\n  });\r\n\r\n  const normalizedColor = useMemo(() => new Color(color), [color]);\r\n\r\n  return (\r\n    <a.group userData={{ id, type: 'node' }} scale={scale as any}>\r\n      <Billboard position={[0, 0, 1]}>\r\n        <DreiSvg\r\n          {...rest}\r\n          src={image}\r\n          fillMaterial={{\r\n            fog: true,\r\n            depthTest: false,\r\n            transparent: true,\r\n            color: normalizedColor,\r\n            opacity,\r\n            side: DoubleSide,\r\n            ...(rest.fillMaterial || {})\r\n          }}\r\n          fillMeshProps={{\r\n            // Note: This is a hack to get the svg to\r\n            // render in the correct position.\r\n            position: [-25, -25, 1],\r\n            ...(rest.fillMeshProps || {})\r\n          }}\r\n        />\r\n      </Billboard>\r\n    </a.group>\r\n  );\r\n};\r\n","import type { FC } from 'react';\r\nimport React from 'react';\r\nimport type { ColorRepresentation } from 'three';\r\n\r\nimport { Sphere } from './Sphere';\r\nimport type { SvgProps } from './Svg';\r\nimport { Svg } from './Svg';\r\n\r\nexport interface SphereWithSvgProps extends SvgProps {\r\n  /**\r\n   * The image to display on the icon.\r\n   */\r\n  image: string;\r\n\r\n  /**\r\n   * The color of the svg fill.\r\n   */\r\n  svgFill?: ColorRepresentation;\r\n}\r\n\r\nexport const SphereWithSvg: FC<SphereWithSvgProps> = ({\r\n  color,\r\n  id,\r\n  size,\r\n  opacity = 1,\r\n  node,\r\n  svgFill,\r\n  active = false,\r\n  animated,\r\n  image,\r\n  selected,\r\n  ...rest\r\n}) => (\r\n  <>\r\n    <Sphere\r\n      id={id}\r\n      selected={selected}\r\n      size={size}\r\n      opacity={opacity}\r\n      animated={animated}\r\n      color={color}\r\n      node={node}\r\n      active={active}\r\n    />\r\n    <Svg\r\n      {...rest}\r\n      id={id}\r\n      selected={selected}\r\n      image={image}\r\n      size={size}\r\n      opacity={opacity}\r\n      animated={animated}\r\n      color={svgFill}\r\n      node={node}\r\n      active={active}\r\n    />\r\n  </>\r\n);\r\n","import { a, useSpring } from '@react-spring/three';\r\nimport { Html, useCursor } from '@react-three/drei';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport type { FC, ReactNode } from 'react';\r\nimport React, { useCallback, useMemo, useRef, useState } from 'react';\r\nimport type { Group } from 'three';\r\n\r\nimport { useCameraControls } from '../CameraControls/useCameraControls';\r\nimport { useStore } from '../store';\r\nimport type {\r\n  CollapseProps,\r\n  ContextMenuEvent,\r\n  InternalGraphNode,\r\n  NodeContextMenuProps,\r\n  NodeRenderer\r\n} from '../types';\r\nimport { animationConfig } from '../utils';\r\nimport { useDrag } from '../utils/useDrag';\r\nimport { useHoverIntent } from '../utils/useHoverIntent';\r\nimport { Label } from './Label';\r\nimport { Icon } from './nodes';\r\nimport { Sphere } from './nodes/Sphere';\r\n\r\nexport interface NodeProps {\r\n  /**\r\n   * The unique identifier for the node.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The parent nodes of the node.\r\n   */\r\n  parents?: string[];\r\n\r\n  /**\r\n   * Whether the node is disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * Whether the node is animated.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Whether the node is draggable.\r\n   */\r\n  draggable?: boolean;\r\n\r\n  /**\r\n   * Constrain dragging to the cluster bounds.\r\n   */\r\n  constrainDragging?: boolean;\r\n\r\n  /**\r\n   * The url for the label font.\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * The function to use to render the node.\r\n   */\r\n  renderNode?: NodeRenderer;\r\n\r\n  /**\r\n   * The context menu for the node.\r\n   */\r\n  contextMenu?: (event: ContextMenuEvent) => ReactNode;\r\n\r\n  /**\r\n   * The function to call when the pointer is over the node.\r\n   */\r\n  onPointerOver?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * The function to call when the pointer is out of the node.\r\n   */\r\n  onPointerOut?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * The function to call when the node is clicked.\r\n   */\r\n  onClick?: (\r\n    node: InternalGraphNode,\r\n    props?: CollapseProps,\r\n    event?: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * The function to call when the node is double clicked.\r\n   */\r\n  onDoubleClick?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * The function to call when the node is right clicked.\r\n   */\r\n  onContextMenu?: (\r\n    node?: InternalGraphNode,\r\n    props?: NodeContextMenuProps\r\n  ) => void;\r\n\r\n  /**\r\n   * Triggered after a node was dragged.\r\n   */\r\n  onDragged?: (node: InternalGraphNode) => void;\r\n}\r\n\r\nexport const Node: FC<NodeProps> = ({\r\n  animated,\r\n  disabled,\r\n  id,\r\n  draggable = false,\r\n  labelFontUrl,\r\n  contextMenu,\r\n  onClick,\r\n  onDoubleClick,\r\n  onPointerOver,\r\n  onDragged,\r\n  onPointerOut,\r\n  onContextMenu,\r\n  renderNode,\r\n  constrainDragging\r\n}) => {\r\n  const cameraControls = useCameraControls();\r\n  const theme = useStore(state => state.theme);\r\n  const node = useStore(state => state.nodes.find(n => n.id === id));\r\n  const edges = useStore(state => state.edges);\r\n  const draggingIds = useStore(state => state.draggingIds);\r\n  const collapsedNodeIds = useStore(state => state.collapsedNodeIds);\r\n  const addDraggingId = useStore(state => state.addDraggingId);\r\n  const removeDraggingId = useStore(state => state.removeDraggingId);\r\n  const setHoveredNodeId = useStore(state => state.setHoveredNodeId);\r\n  const setNodePosition = useStore(state => state.setNodePosition);\r\n  const setCollapsedNodeIds = useStore(state => state.setCollapsedNodeIds);\r\n  const isCollapsed = useStore(state => state.collapsedNodeIds.includes(id));\r\n  const isActive = useStore(state => state.actives?.includes(id));\r\n  const isSelected = useStore(state => state.selections?.includes(id));\r\n  const hasSelections = useStore(state => state.selections?.length > 0);\r\n  const center = useStore(state => state.centerPosition);\r\n  const cluster = useStore(state => state.clusters.get(node.cluster));\r\n\r\n  const isDraggingCurrent = draggingIds.includes(id);\r\n  const isDragging = draggingIds.length > 0;\r\n\r\n  const {\r\n    position,\r\n    label,\r\n    subLabel,\r\n    size: nodeSize = 7,\r\n    labelVisible = true\r\n  } = node;\r\n\r\n  const group = useRef<Group | null>(null);\r\n  const [active, setActive] = useState<boolean>(false);\r\n  const [menuVisible, setMenuVisible] = useState<boolean>(false);\r\n\r\n  const shouldHighlight = active || isSelected || isActive;\r\n\r\n  const selectionOpacity = hasSelections\r\n    ? shouldHighlight\r\n      ? theme.node.selectedOpacity\r\n      : theme.node.inactiveOpacity\r\n    : theme.node.opacity;\r\n\r\n  const canCollapse = useMemo(() => {\r\n    // If the node has outgoing edges, it can collapse via context menu\r\n    const outboundLinks = edges.filter(l => l.source === id);\r\n\r\n    return outboundLinks.length > 0 || isCollapsed;\r\n  }, [edges, id, isCollapsed]);\r\n\r\n  const onCollapse = useCallback(() => {\r\n    if (canCollapse) {\r\n      if (isCollapsed) {\r\n        setCollapsedNodeIds(collapsedNodeIds.filter(p => p !== id));\r\n      } else {\r\n        setCollapsedNodeIds([...collapsedNodeIds, id]);\r\n      }\r\n    }\r\n  }, [canCollapse, collapsedNodeIds, id, isCollapsed, setCollapsedNodeIds]);\r\n\r\n  const [{ nodePosition, labelPosition }] = useSpring(\r\n    () => ({\r\n      from: {\r\n        nodePosition: center ? [center.x, center.y, 0] : [0, 0, 0],\r\n        labelPosition: [0, -(nodeSize + 4), 2],\r\n        subLabelPosition: [0, -(nodeSize + 14), 2]\r\n      },\r\n      to: {\r\n        nodePosition: position\r\n          ? [\r\n              position.x,\r\n              position.y,\r\n              shouldHighlight ? position.z + 50 : position.z\r\n            ]\r\n          : [0, 0, 0],\r\n        labelPosition: [0, -(nodeSize + 4), 2],\r\n        subLabelPosition: [0, -(nodeSize + 14), 2]\r\n      },\r\n      config: {\r\n        ...animationConfig,\r\n        duration: animated && !isDragging ? undefined : 0\r\n      }\r\n    }),\r\n    [isDraggingCurrent, position, animated, nodeSize, shouldHighlight]\r\n  );\r\n\r\n  const bind = useDrag({\r\n    draggable,\r\n    position,\r\n    // If dragging is constrained to the cluster, use the cluster's position as the bounds\r\n    bounds: constrainDragging ? cluster?.position : undefined,\r\n    // @ts-ignore\r\n    set: pos => setNodePosition(id, pos),\r\n    onDragStart: () => {\r\n      addDraggingId(id);\r\n      setActive(true);\r\n    },\r\n    onDragEnd: () => {\r\n      removeDraggingId(id);\r\n      onDragged?.(node);\r\n    }\r\n  });\r\n\r\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\r\n  useCursor(\r\n    active && draggable && !isDraggingCurrent && onClick === undefined,\r\n    'grab'\r\n  );\r\n  useCursor(isDraggingCurrent, 'grabbing');\r\n\r\n  const combinedActiveState = shouldHighlight || isDraggingCurrent;\r\n  const color = combinedActiveState\r\n    ? node.activeFill || theme.node.activeFill\r\n    : node.fill || theme.node.fill;\r\n\r\n  const actualShowRing = node.showRing;\r\n  const { pointerOver, pointerOut } = useHoverIntent({\r\n    disabled: disabled || isDraggingCurrent,\r\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\r\n      cameraControls.freeze();\r\n      setActive(true);\r\n      onPointerOver?.(node, event);\r\n      setHoveredNodeId(id);\r\n    },\r\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\r\n      cameraControls.unFreeze();\r\n      setActive(false);\r\n      onPointerOut?.(node, event);\r\n      setHoveredNodeId(null);\r\n    }\r\n  });\r\n\r\n  const nodeComponent = useMemo(\r\n    () =>\r\n      renderNode ? (\r\n        renderNode({\r\n          id,\r\n          color,\r\n          size: nodeSize,\r\n          active: combinedActiveState,\r\n          opacity: selectionOpacity,\r\n          animated,\r\n          selected: isSelected,\r\n          node\r\n        })\r\n      ) : (\r\n        <>\r\n          {node.icon ? (\r\n            <Icon\r\n              id={id}\r\n              image={node.icon || ''}\r\n              size={nodeSize + 8}\r\n              opacity={selectionOpacity}\r\n              animated={animated}\r\n              color={color}\r\n              node={node}\r\n              active={combinedActiveState}\r\n              selected={isSelected}\r\n            />\r\n          ) : (\r\n            <Sphere\r\n              id={id}\r\n              size={nodeSize}\r\n              opacity={selectionOpacity}\r\n              animated={animated}\r\n              color={color}\r\n              node={node}\r\n              active={combinedActiveState}\r\n              selected={isSelected}\r\n              showRing={actualShowRing}\r\n            />\r\n          )}\r\n        </>\r\n      ),\r\n    [\r\n      renderNode,\r\n      id,\r\n      color,\r\n      nodeSize,\r\n      combinedActiveState,\r\n      selectionOpacity,\r\n      animated,\r\n      isSelected,\r\n      node,\r\n      actualShowRing\r\n    ]\r\n  );\r\n\r\n  const labelComponent = useMemo(\r\n    () =>\r\n      label && (\r\n        <>\r\n          <a.group position={labelPosition as any}>\r\n            <Label\r\n              text={label}\r\n              fontUrl={labelFontUrl}\r\n              opacity={selectionOpacity}\r\n              stroke={theme.node.label.stroke}\r\n              maxWidth={theme.node.label.maxWidth}\r\n              ellipsis={theme.node.label.ellipsis}\r\n              backgroundColor={theme.node.label.backgroundColor}\r\n              borderRadius={theme.node.label.borderRadius}\r\n              active={isSelected || active || isDragging || isActive}\r\n              color={\r\n                isSelected || active || isDragging || isActive\r\n                  ? theme.node.label.activeColor\r\n                  : theme.node.label.color\r\n              }\r\n              type=\"node\"\r\n              labelVisible={labelVisible}\r\n            />\r\n          </a.group>\r\n          {subLabel && (\r\n            <group position={[0, -(nodeSize - 3), 0]}>\r\n              <Label\r\n                text={subLabel}\r\n                fontUrl={labelFontUrl}\r\n                fontSize={theme.node.label.fontSize}\r\n                maxWidth={theme.node.label.maxWidth}\r\n                ellipsis={theme.node.label.ellipsis}\r\n                backgroundColor={theme.node.label.backgroundColor}\r\n                borderRadius={theme.node.label.borderRadius}\r\n                opacity={selectionOpacity}\r\n                stroke={theme.node.subLabel?.stroke}\r\n                active={isSelected || active || isDraggingCurrent || isActive}\r\n                color={\r\n                  isSelected || active || isDraggingCurrent || isActive\r\n                    ? theme.node.subLabel?.activeColor\r\n                    : theme.node.subLabel?.color\r\n                }\r\n                labelVisible={labelVisible}\r\n              />\r\n            </group>\r\n          )}\r\n        </>\r\n      ),\r\n    [\r\n      active,\r\n      isActive,\r\n      isDraggingCurrent,\r\n      isSelected,\r\n      label,\r\n      labelFontUrl,\r\n      labelPosition,\r\n      labelVisible,\r\n      nodeSize,\r\n      selectionOpacity,\r\n      subLabel,\r\n      theme.node.label.activeColor,\r\n      theme.node.label.color,\r\n      theme.node.label.stroke,\r\n      theme.node.label.backgroundColor,\r\n      theme.node.label.backgroundOpacity,\r\n      theme.node.label.padding,\r\n      theme.node.label.strokeColor,\r\n      theme.node.label.strokeWidth,\r\n      theme.node.label.radius,\r\n      theme.node.subLabel?.activeColor,\r\n      theme.node.subLabel?.color,\r\n      theme.node.subLabel?.stroke,\r\n      theme.node.label.fontSize,\r\n      theme.node.label.maxWidth,\r\n      theme.node.label.ellipsis,\r\n      theme.node.label.backgroundColor,\r\n      theme.node.label.borderRadius\r\n    ]\r\n  );\r\n\r\n  const menuComponent = useMemo(\r\n    () =>\r\n      menuVisible &&\r\n      contextMenu && (\r\n        <Html prepend={true} center={true}>\r\n          {contextMenu({\r\n            data: node,\r\n            canCollapse,\r\n            isCollapsed,\r\n            onCollapse,\r\n            onClose: () => setMenuVisible(false)\r\n          })}\r\n        </Html>\r\n      ),\r\n    [menuVisible, contextMenu, node, canCollapse, isCollapsed, onCollapse]\r\n  );\r\n\r\n  return (\r\n    <a.group\r\n      renderOrder={1}\r\n      userData={{ id, type: 'node' }}\r\n      ref={group}\r\n      position={nodePosition as any}\r\n      onPointerOver={pointerOver}\r\n      onPointerOut={pointerOut}\r\n      onClick={(event: ThreeEvent<MouseEvent>) => {\r\n        if (!disabled && !isDraggingCurrent) {\r\n          onClick?.(\r\n            node,\r\n            {\r\n              canCollapse,\r\n              isCollapsed\r\n            },\r\n            event\r\n          );\r\n        }\r\n      }}\r\n      onDoubleClick={(event: ThreeEvent<MouseEvent>) => {\r\n        event.stopPropagation();\r\n        if (!disabled && !isDraggingCurrent) {\r\n          onDoubleClick?.(node, event);\r\n        }\r\n      }}\r\n      onContextMenu={() => {\r\n        if (!disabled) {\r\n          setMenuVisible(true);\r\n          onContextMenu?.(node, {\r\n            canCollapse,\r\n            isCollapsed,\r\n            onCollapse\r\n          });\r\n        }\r\n      }}\r\n      {...(bind() as any)}\r\n    >\r\n      {nodeComponent}\r\n      {menuComponent}\r\n      {labelComponent}\r\n    </a.group>\r\n  );\r\n};\r\n","import type Graph from 'graphology';\r\n\r\nimport type { InternalGraphEdge, InternalGraphNode } from '../types';\r\nimport type { LayoutStrategy } from './types';\r\n\r\n/**\r\n * Promise based tick helper.\r\n */\r\nexport function tick(layout: LayoutStrategy) {\r\n  return new Promise((resolve, _reject) => {\r\n    let stable: boolean | undefined;\r\n\r\n    function run() {\r\n      if (!stable) {\r\n        stable = layout.step();\r\n        run();\r\n      } else {\r\n        resolve(stable);\r\n      }\r\n    }\r\n\r\n    run();\r\n  });\r\n}\r\n\r\n/**\r\n * Helper function to turn the graph nodes/edges into an array for\r\n * easier manipulation.\r\n */\r\nexport function buildNodeEdges(graph: Graph) {\r\n  const nodes: InternalGraphNode[] = [];\r\n  const edges: InternalGraphEdge[] = [];\r\n\r\n  graph.forEachNode((id, n: any) => {\r\n    nodes.push({\r\n      ...n,\r\n      id,\r\n      // This is for the clustering\r\n      radius: n.size || 1\r\n    });\r\n  });\r\n\r\n  graph.forEachEdge((id, l: any) => {\r\n    edges.push({ ...l, id });\r\n  });\r\n\r\n  return { nodes, edges };\r\n}\r\n","import circular from 'graphology-layout/circular.js';\r\n\r\nimport { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps } from './types';\r\n\r\nexport interface CircularLayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Radius of the circle.\r\n   */\r\n  radius: number;\r\n}\r\n\r\nexport function circular2d({\r\n  graph,\r\n  radius,\r\n  drags,\r\n  getNodePosition\r\n}: CircularLayoutInputs) {\r\n  const layout = circular(graph, {\r\n    scale: radius\r\n  });\r\n\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) {\r\n          return pos;\r\n        }\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        // If we dragged, we need to use that position\r\n        return drags?.[id]?.position as any;\r\n      }\r\n\r\n      return layout?.[id];\r\n    }\r\n  };\r\n}\r\n","import { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps } from './types';\r\n\r\nexport interface ConcentricLayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Base radius of the innermost circle.\r\n   */\r\n  radius: number;\r\n  /**\r\n   * Distance between circles.\r\n   */\r\n  concentricSpacing?: number;\r\n}\r\n\r\n/**\r\n * Concentric layout algorithm for 2D graphs.\r\n * @param graph\r\n * @param radius\r\n * @param drags\r\n * @param getNodePosition\r\n * @param concentricSpacing\r\n */\r\nexport function concentric2d({\r\n  graph,\r\n  radius = 40,\r\n  drags,\r\n  getNodePosition,\r\n  concentricSpacing = 100\r\n}: ConcentricLayoutInputs) {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  const layout: Record<string, { x: number; y: number }> = {};\r\n\r\n  const getNodesInLevel = (level: number) => {\r\n    const circumference = 2 * Math.PI * (radius + level * concentricSpacing);\r\n    const minNodeSpacing = 40;\r\n    return Math.floor(circumference / minNodeSpacing);\r\n  };\r\n\r\n  const fixedLevelMap = new Map<number, string[]>();\r\n  const dynamicNodes: { id: string; metric: number }[] = [];\r\n\r\n  // Split nodes: fixed-level and dynamic\r\n  for (const node of nodes) {\r\n    const data = graph.getNodeAttribute(node.id, 'data');\r\n    const level = data?.level;\r\n\r\n    if (typeof level === 'number' && level >= 0) {\r\n      if (!fixedLevelMap.has(level)) {\r\n        fixedLevelMap.set(level, []);\r\n      }\r\n      fixedLevelMap.get(level)!.push(node.id);\r\n    } else {\r\n      dynamicNodes.push({ id: node.id, metric: graph.degree(node.id) });\r\n    }\r\n  }\r\n\r\n  // Sort dynamic nodes by degree\r\n  dynamicNodes.sort((a, b) => b.metric - a.metric);\r\n\r\n  // Fill layout for fixed-level nodes\r\n  for (const [level, nodeIds] of fixedLevelMap.entries()) {\r\n    const count = nodeIds.length;\r\n    const r = radius + level * concentricSpacing;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      const angle = (2 * Math.PI * i) / count;\r\n      layout[nodeIds[i]] = {\r\n        x: r * Math.cos(angle),\r\n        y: r * Math.sin(angle)\r\n      };\r\n    }\r\n  }\r\n\r\n  // Determine which levels are partially used and which are available\r\n  const occupiedLevels = new Set(fixedLevelMap.keys());\r\n  let dynamicLevel = 0;\r\n\r\n  let i = 0;\r\n  while (i < dynamicNodes.length) {\r\n    // Skip occupied levels\r\n    while (occupiedLevels.has(dynamicLevel)) {\r\n      dynamicLevel++;\r\n    }\r\n\r\n    const nodesInLevel = getNodesInLevel(dynamicLevel);\r\n    const r = radius + dynamicLevel * concentricSpacing;\r\n\r\n    for (let j = 0; j < nodesInLevel && i < dynamicNodes.length; j++) {\r\n      const angle = (2 * Math.PI * j) / nodesInLevel;\r\n      layout[dynamicNodes[i].id] = {\r\n        x: r * Math.cos(angle),\r\n        y: r * Math.sin(angle)\r\n      };\r\n      i++;\r\n    }\r\n\r\n    dynamicLevel++;\r\n  }\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) return pos;\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        return drags[id].position as any;\r\n      }\r\n\r\n      return layout[id];\r\n    }\r\n  };\r\n}\r\n","import { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps } from './types';\r\n\r\nexport function custom({ graph, drags, getNodePosition }: LayoutFactoryProps) {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      return getNodePosition(id, { graph, drags, nodes, edges });\r\n    }\r\n  };\r\n}\r\n","import type { InternalGraphEdge, InternalGraphNode } from '../types';\r\n\r\nexport interface DepthNode {\r\n  data: InternalGraphNode;\r\n  ins: DepthNode[];\r\n  out: DepthNode[];\r\n  depth: number;\r\n}\r\n\r\n/**\r\n * Traverse the graph and get the depth of each node.\r\n */\r\nfunction traverseGraph(nodes: DepthNode[], nodeStack: DepthNode[] = []) {\r\n  const currentDepth = nodeStack.length;\r\n\r\n  for (const node of nodes) {\r\n    const idx = nodeStack.indexOf(node);\r\n    if (idx > -1) {\r\n      const loop = [...nodeStack.slice(idx), node].map(d => d.data.id);\r\n      throw new Error(\r\n        `Invalid Graph: Circular node path detected: ${loop.join(' -> ')}.`\r\n      );\r\n    }\r\n\r\n    if (currentDepth > node.depth) {\r\n      node.depth = currentDepth;\r\n      traverseGraph(node.out, [...nodeStack, node]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the depth of the graph's nodes. Used in the radial layout.\r\n */\r\nexport function getNodeDepth(\r\n  nodes: InternalGraphNode[],\r\n  links: InternalGraphEdge[]\r\n) {\r\n  let invalid = false;\r\n\r\n  const graph: { [key: string]: DepthNode } = nodes.reduce(\r\n    (acc, cur) => ({\r\n      ...acc,\r\n      [cur.id]: {\r\n        data: cur,\r\n        out: [],\r\n        depth: -1,\r\n        ins: []\r\n      }\r\n    }),\r\n    {}\r\n  );\r\n\r\n  try {\r\n    for (const link of links) {\r\n      const from = link.source;\r\n      const to = link.target;\r\n\r\n      /* eslint-disable no-prototype-builtins */\r\n      if (!graph.hasOwnProperty(from)) {\r\n        throw new Error(`Missing source Node ${from}`);\r\n      }\r\n      /* eslint-disable no-prototype-builtins */\r\n      if (!graph.hasOwnProperty(to)) {\r\n        throw new Error(`Missing target Node ${to}`);\r\n      }\r\n\r\n      const sourceNode = graph[from];\r\n      const targetNode = graph[to];\r\n      targetNode.ins.push(sourceNode);\r\n      sourceNode.out.push(targetNode);\r\n    }\r\n\r\n    traverseGraph(Object.values(graph));\r\n  } catch (e) {\r\n    invalid = true;\r\n  }\r\n\r\n  const allDepths = Object.keys(graph).map(id => graph[id].depth);\r\n  const maxDepth = Math.max(...allDepths);\r\n\r\n  return {\r\n    invalid,\r\n    depths: graph,\r\n    maxDepth: maxDepth || 1\r\n  };\r\n}\r\n","import random from 'graphology-layout/random.js';\r\nimport forceAtlas2Layout from 'graphology-layout-forceatlas2';\r\n\r\nimport type { LayoutFactoryProps } from './types';\r\n\r\nexport interface ForceAtlas2LayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Should the nodes sizes be taken into account. Default: false.\r\n   */\r\n  adjustSizes?: boolean;\r\n\r\n  /**\r\n   * whether to use the Barnes-Hut approximation to compute\r\n   * repulsion in O(n*log(n)) rather than default O(n^2),\r\n   * n being the number of nodes. Default: false.\r\n   */\r\n  barnesHutOptimize?: boolean;\r\n\r\n  /**\r\n   * Barnes-Hut approximation theta parameter. Default: 0.5.\r\n   */\r\n  barnesHutTheta?: number;\r\n\r\n  /**\r\n   * Influence of the edges weights on the layout. To consider edge weight, dont\r\n   *  forget to pass weighted as true. Default: 1.\r\n   */\r\n  edgeWeightInfluence?: number;\r\n\r\n  /**\r\n   * Strength of the layouts gravity. Default: 10.\r\n   */\r\n  gravity?: number;\r\n\r\n  /**\r\n   * Whether to use Noacks LinLog model. Default: false.\r\n   */\r\n  linLogMode?: boolean;\r\n\r\n  /**\r\n   * Whether to consider edge weights when calculating repulsion. Default: false.\r\n   */\r\n  outboundAttractionDistribution?: boolean;\r\n\r\n  /**\r\n   * Scaling ratio for repulsion. Default: 100.\r\n   */\r\n  scalingRatio?: number;\r\n\r\n  /**\r\n   * Speed of the slowdown. Default: 1.\r\n   */\r\n  slowDown?: number;\r\n\r\n  /**\r\n   * Whether to use the strong gravity mode. Default: false.\r\n   */\r\n  strongGravityMode?: boolean;\r\n\r\n  /**\r\n   * Number of iterations to perform. Default: 50.\r\n   */\r\n  iterations?: number;\r\n}\r\n\r\nexport function forceAtlas2({\r\n  graph,\r\n  drags,\r\n  iterations,\r\n  ...rest\r\n}: ForceAtlas2LayoutInputs) {\r\n  // Note: We need to assign a random position to each node\r\n  // in order for the force atlas to work.\r\n  // Reference: https://graphology.github.io/standard-library/layout-forceatlas2.html#pre-requisites\r\n  random.assign(graph);\r\n\r\n  const layout = forceAtlas2Layout(graph, {\r\n    iterations,\r\n    settings: rest\r\n  });\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      // If we dragged, we need to use that position\r\n      return (drags?.[id]?.position as any) || layout?.[id];\r\n    }\r\n  };\r\n}\r\n","import {\r\n  forceCollide,\r\n  forceLink,\r\n  forceManyBody,\r\n  forceSimulation,\r\n  forceX,\r\n  forceY\r\n} from 'd3-force-3d';\r\nimport { hierarchy, treemap } from 'd3-hierarchy';\r\n\r\nimport type { ClusterGroup } from '../utils/cluster';\r\n\r\n/**\r\n * Used for calculating clusterings of nodes.\r\n *\r\n * Modified version of: https://github.com/john-guerra/forceInABox\r\n *\r\n * Changes:\r\n *  - Improved d3 import for tree shaking\r\n *  - Fixed node lookup for edges using array\r\n *  - Updated d3-force to use d3-force-3d\r\n *  - Removed template logic\r\n */\r\nexport function forceInABox() {\r\n  // d3 style\r\n  const constant = (_: any) => () => _;\r\n  const index = (d: any) => d.index;\r\n\r\n  // Default values\r\n  let id = index;\r\n  let nodes = [];\r\n  let links = []; // needed for the force version\r\n  let clusters: Map<string, ClusterGroup>;\r\n  let tree;\r\n  let size = [100, 100];\r\n  let forceNodeSize = constant(1); // The expected node size used for computing the cluster node\r\n  let forceCharge = constant(-1);\r\n  let forceLinkDistance = constant(100);\r\n  let forceLinkStrength = constant(0.1);\r\n  const foci = {};\r\n  let linkStrengthIntraCluster = 0.1;\r\n  let linkStrengthInterCluster = 0.001;\r\n  let templateNodes = [];\r\n  let offset = [0, 0];\r\n  let templateForce;\r\n  let groupBy = d => d.cluster;\r\n  let template = 'treemap';\r\n  let enableGrouping = true;\r\n  let strength = 0.1;\r\n\r\n  function force(alpha) {\r\n    if (!enableGrouping) {\r\n      return force;\r\n    }\r\n\r\n    if (template === 'force') {\r\n      // Do the tick of the template force and get the new focis\r\n      templateForce.tick();\r\n      getFocisFromTemplate();\r\n    }\r\n\r\n    for (let i = 0, n = nodes.length, node, k = alpha * strength; i < n; ++i) {\r\n      node = nodes[i];\r\n      node.vx += (foci[groupBy(node)].x - node.x) * k;\r\n      node.vy += (foci[groupBy(node)].y - node.y) * k;\r\n    }\r\n  }\r\n\r\n  function initialize() {\r\n    if (!nodes) {\r\n      return;\r\n    }\r\n\r\n    if (template === 'treemap') {\r\n      initializeWithTreemap();\r\n    } else {\r\n      initializeWithForce();\r\n    }\r\n  }\r\n\r\n  force.initialize = function (_) {\r\n    nodes = _;\r\n    initialize();\r\n  };\r\n\r\n  function getLinkKey(l) {\r\n    const sourceID = groupBy(l.source),\r\n      targetID = groupBy(l.target);\r\n\r\n    return sourceID <= targetID\r\n      ? sourceID + '~' + targetID\r\n      : targetID + '~' + sourceID;\r\n  }\r\n\r\n  function computeClustersNodeCounts(nodes) {\r\n    let clustersCounts = new Map(),\r\n      tmpCount: any = {};\r\n\r\n    nodes.forEach(function (d) {\r\n      if (!clustersCounts.has(groupBy(d))) {\r\n        clustersCounts.set(groupBy(d), { count: 0, sumforceNodeSize: 0 });\r\n      }\r\n    });\r\n\r\n    nodes.forEach(function (d) {\r\n      tmpCount = clustersCounts.get(groupBy(d));\r\n      tmpCount.count = tmpCount.count + 1;\r\n      tmpCount.sumforceNodeSize =\r\n        tmpCount.sumforceNodeSize +\r\n        // @ts-ignore\r\n        Math.PI * (forceNodeSize(d) * forceNodeSize(d)) * 1.3;\r\n      clustersCounts.set(groupBy(d), tmpCount);\r\n    });\r\n\r\n    return clustersCounts;\r\n  }\r\n\r\n  //Returns\r\n  function computeClustersLinkCounts(links) {\r\n    const dClusterLinks = new Map(),\r\n      clusterLinks = [];\r\n\r\n    links.forEach(function (l) {\r\n      let key = getLinkKey(l),\r\n        count;\r\n      if (dClusterLinks.has(key)) {\r\n        count = dClusterLinks.get(key);\r\n      } else {\r\n        count = 0;\r\n      }\r\n      count += 1;\r\n      dClusterLinks.set(key, count);\r\n    });\r\n\r\n    dClusterLinks.forEach(function (value, key) {\r\n      let source, target;\r\n      source = key.split('~')[0];\r\n      target = key.split('~')[1];\r\n      if (source !== undefined && target !== undefined) {\r\n        clusterLinks.push({\r\n          source: source,\r\n          target: target,\r\n          count: value\r\n        });\r\n      }\r\n    });\r\n\r\n    return clusterLinks;\r\n  }\r\n\r\n  //Returns the metagraph of the clusters\r\n  function getGroupsGraph() {\r\n    const gnodes = [];\r\n    const glinks = [];\r\n    const dNodes = new Map();\r\n    let c;\r\n    let i;\r\n    let cc;\r\n    let clustersCounts;\r\n    let clustersLinks;\r\n\r\n    clustersCounts = computeClustersNodeCounts(nodes);\r\n    clustersLinks = computeClustersLinkCounts(links);\r\n\r\n    for (c of clustersCounts.keys()) {\r\n      cc = clustersCounts.get(c);\r\n      gnodes.push({\r\n        id: c,\r\n        size: cc.count,\r\n        r: Math.sqrt(cc.sumforceNodeSize / Math.PI)\r\n      }); // Uses approx meta-node size\r\n      dNodes.set(c, i);\r\n    }\r\n\r\n    clustersLinks.forEach(function (l) {\r\n      const source = dNodes.get(l.source),\r\n        target = dNodes.get(l.target);\r\n      if (source !== undefined && target !== undefined) {\r\n        glinks.push({\r\n          source: source,\r\n          target: target,\r\n          count: l.count\r\n        });\r\n      }\r\n    });\r\n\r\n    return { nodes: gnodes, links: glinks };\r\n  }\r\n\r\n  function getGroupsTree() {\r\n    const children = [];\r\n    let c;\r\n    let cc;\r\n    let clustersCounts;\r\n\r\n    // @ts-ignore\r\n    clustersCounts = computeClustersNodeCounts(force.nodes());\r\n\r\n    for (c of clustersCounts.keys()) {\r\n      cc = clustersCounts.get(c);\r\n      children.push({ id: c, size: cc.count });\r\n    }\r\n    return { id: 'clustersTree', children: children };\r\n  }\r\n\r\n  function getFocisFromTemplate() {\r\n    //compute foci\r\n    // @ts-ignore\r\n    foci.none = { x: 0, y: 0 };\r\n    templateNodes.forEach(function (d) {\r\n      if (template === 'treemap') {\r\n        foci[d.data.id] = {\r\n          x: d.x0 + (d.x1 - d.x0) / 2 - offset[0],\r\n          y: d.y0 + (d.y1 - d.y0) / 2 - offset[1]\r\n        };\r\n      } else {\r\n        foci[d.id] = {\r\n          x: d.x - offset[0],\r\n          y: d.y - offset[1]\r\n        };\r\n      }\r\n    });\r\n    return foci;\r\n  }\r\n\r\n  function initializeWithTreemap() {\r\n    // @ts-ignore\r\n    const sim = treemap().size(force.size());\r\n\r\n    tree = hierarchy(getGroupsTree())\r\n      .sum((d: any) => d.radius)\r\n      .sort(function (a, b) {\r\n        return b.height - a.height || b.value - a.value;\r\n      });\r\n\r\n    templateNodes = sim(tree).leaves();\r\n    getFocisFromTemplate();\r\n  }\r\n\r\n  function checkLinksAsObjects() {\r\n    // Check if links come in the format of indexes instead of objects\r\n    let linkCount = 0;\r\n    if (nodes.length === 0) return;\r\n\r\n    links.forEach(function (link) {\r\n      let source, target;\r\n      if (!nodes) {\r\n        return;\r\n      }\r\n\r\n      source = link.source;\r\n      target = link.target;\r\n\r\n      if (typeof link.source !== 'object') {\r\n        source = nodes.find(n => n.id === link.source);\r\n      }\r\n\r\n      if (typeof link.target !== 'object') {\r\n        target = nodes.find(n => n.id === link.target);\r\n      }\r\n\r\n      if (source === undefined || target === undefined) {\r\n        throw Error(\r\n          'Error setting links, couldnt find nodes for a link (see it on the console)'\r\n        );\r\n      }\r\n      link.source = source;\r\n      link.target = target;\r\n      link.index = linkCount++;\r\n    });\r\n  }\r\n\r\n  function initializeWithForce() {\r\n    let net;\r\n\r\n    if (!nodes || !nodes.length) {\r\n      return;\r\n    }\r\n\r\n    checkLinksAsObjects();\r\n\r\n    net = getGroupsGraph();\r\n\r\n    // Use dragged clusters position if available\r\n    if (clusters.size > 0) {\r\n      net.nodes.forEach(n => {\r\n        // Set fixed X position for cluster\r\n        n.fx = clusters.get(n.id)?.position?.x;\r\n        // Set fixed Y position for cluster\r\n        n.fy = clusters.get(n.id)?.position?.y;\r\n      });\r\n    }\r\n\r\n    templateForce = forceSimulation(net.nodes)\r\n      .force('x', forceX(size[0] / 2).strength(0.1))\r\n      .force('y', forceY(size[1] / 2).strength(0.1))\r\n      .force('collide', forceCollide(d => d.r).iterations(4))\r\n      .force('charge', forceManyBody().strength(forceCharge))\r\n      .force(\r\n        'links',\r\n        forceLink(net.nodes.length ? net.links : [])\r\n          .distance(forceLinkDistance)\r\n          .strength(forceLinkStrength)\r\n      );\r\n\r\n    templateNodes = templateForce.nodes();\r\n\r\n    getFocisFromTemplate();\r\n  }\r\n\r\n  force.template = function (x) {\r\n    if (!arguments.length) {\r\n      return template;\r\n    }\r\n\r\n    template = x;\r\n    initialize();\r\n    return force;\r\n  };\r\n\r\n  force.groupBy = function (x) {\r\n    if (!arguments.length) {\r\n      return groupBy;\r\n    }\r\n\r\n    if (typeof x === 'string') {\r\n      groupBy = function (d) {\r\n        return d[x];\r\n      };\r\n\r\n      return force;\r\n    }\r\n\r\n    groupBy = x;\r\n\r\n    return force;\r\n  };\r\n\r\n  force.enableGrouping = function (x) {\r\n    if (!arguments.length) {\r\n      return enableGrouping;\r\n    }\r\n\r\n    enableGrouping = x;\r\n\r\n    return force;\r\n  };\r\n\r\n  force.strength = function (x) {\r\n    if (!arguments.length) {\r\n      return strength;\r\n    }\r\n\r\n    strength = x;\r\n\r\n    return force as any;\r\n  };\r\n\r\n  force.getLinkStrength = function (e) {\r\n    if (enableGrouping) {\r\n      if (groupBy(e.source) === groupBy(e.target)) {\r\n        if (typeof linkStrengthIntraCluster === 'function') {\r\n          // @ts-ignore\r\n          return linkStrengthIntraCluster(e);\r\n        } else {\r\n          return linkStrengthIntraCluster;\r\n        }\r\n      } else {\r\n        if (typeof linkStrengthInterCluster === 'function') {\r\n          // @ts-ignore\r\n          return linkStrengthInterCluster(e);\r\n        } else {\r\n          return linkStrengthInterCluster;\r\n        }\r\n      }\r\n    } else {\r\n      // Not grouping return the intracluster\r\n      if (typeof linkStrengthIntraCluster === 'function') {\r\n        // @ts-ignore\r\n        return linkStrengthIntraCluster(e);\r\n      } else {\r\n        return linkStrengthIntraCluster;\r\n      }\r\n    }\r\n  };\r\n\r\n  force.id = function (_) {\r\n    return arguments.length ? ((id = _), force) : id;\r\n  };\r\n\r\n  force.size = function (_) {\r\n    return arguments.length ? ((size = _), force) : size;\r\n  };\r\n\r\n  force.linkStrengthInterCluster = function (_) {\r\n    return arguments.length\r\n      ? ((linkStrengthInterCluster = _), force)\r\n      : linkStrengthInterCluster;\r\n  };\r\n\r\n  force.linkStrengthIntraCluster = function (_) {\r\n    return arguments.length\r\n      ? ((linkStrengthIntraCluster = _), force)\r\n      : linkStrengthIntraCluster;\r\n  };\r\n\r\n  force.nodes = function (_) {\r\n    return arguments.length ? ((nodes = _), force) : nodes;\r\n  };\r\n\r\n  force.links = function (_) {\r\n    if (!arguments.length) {\r\n      return links;\r\n    }\r\n\r\n    if (_ === null) {\r\n      links = [];\r\n    } else {\r\n      links = _;\r\n    }\r\n\r\n    initialize();\r\n\r\n    return force;\r\n  };\r\n\r\n  force.template = function (x) {\r\n    if (!arguments.length) {\r\n      return template;\r\n    }\r\n\r\n    template = x;\r\n    initialize();\r\n    return force;\r\n  };\r\n\r\n  force.forceNodeSize = function (_) {\r\n    return arguments.length\r\n      ? ((forceNodeSize = typeof _ === 'function' ? _ : constant(+_)),\r\n        initialize(),\r\n        force)\r\n      : forceNodeSize;\r\n  };\r\n\r\n  // Legacy support\r\n  force.nodeSize = force.forceNodeSize;\r\n\r\n  force.forceCharge = function (_) {\r\n    return arguments.length\r\n      ? ((forceCharge = typeof _ === 'function' ? _ : constant(+_)),\r\n        initialize(),\r\n        force)\r\n      : forceCharge;\r\n  };\r\n\r\n  force.forceLinkDistance = function (_) {\r\n    return arguments.length\r\n      ? ((forceLinkDistance = typeof _ === 'function' ? _ : constant(+_)),\r\n        initialize(),\r\n        force)\r\n      : forceLinkDistance;\r\n  };\r\n\r\n  force.forceLinkStrength = function (_) {\r\n    return arguments.length\r\n      ? ((forceLinkStrength = typeof _ === 'function' ? _ : constant(+_)),\r\n        initialize(),\r\n        force)\r\n      : forceLinkStrength;\r\n  };\r\n\r\n  force.offset = function (_) {\r\n    return arguments.length\r\n      ? ((offset = typeof _ === 'function' ? _ : constant(+_)), force)\r\n      : offset;\r\n  };\r\n\r\n  force.getFocis = getFocisFromTemplate;\r\n\r\n  // Define the clusters to reuse positions from\r\n  force.setClusters = function (value: any) {\r\n    clusters = value;\r\n\r\n    return force;\r\n  };\r\n\r\n  return force;\r\n}\r\n","import { forceRadial as d3ForceRadial } from 'd3-force-3d';\r\n\r\nimport type { InternalGraphEdge, InternalGraphNode } from '../types';\r\nimport { getNodeDepth } from './depthUtils';\r\n\r\nconst RADIALS: DagMode[] = ['radialin', 'radialout'];\r\n\r\nexport type DagMode =\r\n  | 'lr'\r\n  | 'rl'\r\n  | 'td'\r\n  | 'but'\r\n  | 'zout'\r\n  | 'zin'\r\n  | 'radialin'\r\n  | 'radialout';\r\n\r\nexport interface ForceRadialInputs {\r\n  nodes: InternalGraphNode[];\r\n  edges: InternalGraphEdge[];\r\n  mode: DagMode;\r\n  nodeLevelRatio: number;\r\n}\r\n\r\n/**\r\n * Radial graph layout using D3 Force 3d.\r\n * Inspired by: https://github.com/vasturiano/three-forcegraph/blob/master/src/forcegraph-kapsule.js#L970-L1018\r\n */\r\nexport function forceRadial({\r\n  nodes,\r\n  edges,\r\n  mode = 'lr',\r\n  nodeLevelRatio = 2\r\n}: ForceRadialInputs) {\r\n  const { depths, maxDepth, invalid } = getNodeDepth(nodes, edges);\r\n\r\n  if (invalid) {\r\n    return null;\r\n  }\r\n\r\n  const modeDistance = RADIALS.includes(mode) ? 1 : 5;\r\n  const dagLevelDistance =\r\n    (nodes.length / maxDepth) * nodeLevelRatio * modeDistance;\r\n\r\n  if (mode) {\r\n    const getFFn =\r\n      (fix: boolean, invert: boolean) => (node: InternalGraphNode) =>\r\n        !fix\r\n          ? undefined\r\n          : (depths[node.id].depth - maxDepth / 2) *\r\n            dagLevelDistance *\r\n            (invert ? -1 : 1);\r\n\r\n    const fxFn = getFFn(['lr', 'rl'].includes(mode), mode === 'rl');\r\n    const fyFn = getFFn(['td', 'bu'].includes(mode), mode === 'td');\r\n    const fzFn = getFFn(['zin', 'zout'].includes(mode), mode === 'zout');\r\n\r\n    nodes.forEach(node => {\r\n      node.fx = fxFn(node);\r\n      node.fy = fyFn(node);\r\n      node.fz = fzFn(node);\r\n    });\r\n  }\r\n\r\n  return RADIALS.includes(mode)\r\n    ? d3ForceRadial(node => {\r\n        const nodeDepth = depths[node.id];\r\n        const depth =\r\n          mode === 'radialin' ? maxDepth - nodeDepth.depth : nodeDepth.depth;\r\n        return depth * dagLevelDistance;\r\n      }).strength(1)\r\n    : null;\r\n}\r\n","import {\r\n  forceCenter as d3ForceCenter,\r\n  forceCollide,\r\n  forceLink as d3ForceLink,\r\n  forceManyBody as d3ForceManyBody,\r\n  forceSimulation as d3ForceSimulation,\r\n  forceX as d3ForceX,\r\n  forceY as d3ForceY,\r\n  forceZ as d3ForceZ\r\n} from 'd3-force-3d';\r\n\r\nimport type { ClusterGroup } from '../utils/cluster';\r\nimport { forceInABox } from './forceInABox';\r\nimport type { DagMode } from './forceUtils';\r\nimport { forceRadial } from './forceUtils';\r\nimport type { FORCE_LAYOUTS } from './layoutProvider';\r\nimport { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\r\n\r\nexport interface ForceDirectedLayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Center inertia for the layout. Default: 1.\r\n   */\r\n  centerInertia?: number;\r\n\r\n  /**\r\n   * Number of dimensions for the layout. 2d or 3d.\r\n   */\r\n  dimensions?: number;\r\n\r\n  /**\r\n   * Mode for the dag layout. Only applicable for dag layouts.\r\n   */\r\n  mode?: DagMode;\r\n\r\n  /**\r\n   * Distance between links.\r\n   */\r\n  linkDistance?: number;\r\n\r\n  /**\r\n   * Strength of the node repulsion.\r\n   */\r\n  nodeStrength?: number;\r\n\r\n  /**\r\n   * Strength of the cluster repulsion.\r\n   */\r\n  clusterStrength?: number;\r\n\r\n  /**\r\n   * The clusters dragged position to reuse for the layout.\r\n   */\r\n  clusters: Map<string, ClusterGroup>;\r\n\r\n  /**\r\n   * The type of clustering.\r\n   */\r\n  clusterType?: 'force' | 'treemap';\r\n\r\n  /**\r\n   * Ratio of the distance between nodes on the same level.\r\n   */\r\n  nodeLevelRatio?: number;\r\n\r\n  /**\r\n   * LinkStrength between nodes of different clusters\r\n   */\r\n  linkStrengthInterCluster?: number | ((d: any) => number);\r\n\r\n  /**\r\n   * LinkStrength between nodes of the same cluster\r\n   */\r\n  linkStrengthIntraCluster?: number | ((d: any) => number);\r\n\r\n  /**\r\n   * Charge between the meta-nodes (Force template only)\r\n   */\r\n  forceLinkDistance?: number;\r\n\r\n  /**\r\n   * Used to compute the template force nodes size (Force template only)\r\n   */\r\n  forceLinkStrength?: number;\r\n\r\n  /**\r\n   * Used to compute the template force nodes size (Force template only)\r\n   */\r\n  forceCharge?: number;\r\n\r\n  /**\r\n   * Used to determine the simulation forceX and forceY values\r\n   */\r\n  forceLayout: (typeof FORCE_LAYOUTS)[number];\r\n}\r\n\r\nexport function forceDirected({\r\n  graph,\r\n  nodeLevelRatio = 2,\r\n  mode = null,\r\n  dimensions = 2,\r\n  nodeStrength = -250,\r\n  linkDistance = 100,\r\n  clusterStrength = 0.5,\r\n  linkStrengthInterCluster = 0.01,\r\n  linkStrengthIntraCluster = 0.5,\r\n  forceLinkDistance = 100,\r\n  forceLinkStrength = 0.1,\r\n  clusterType = 'force',\r\n  forceCharge = -700,\r\n  getNodePosition,\r\n  drags,\r\n  clusters,\r\n  clusterAttribute,\r\n  forceLayout\r\n}: ForceDirectedLayoutInputs): LayoutStrategy {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  // Dynamically adjust node strength based on the number of edges\r\n  const is2d = dimensions === 2;\r\n  const nodeStrengthAdjustment =\r\n    is2d && edges.length > 25 ? nodeStrength * 2 : nodeStrength;\r\n\r\n  let forceX;\r\n  let forceY;\r\n  if (forceLayout === 'forceDirected2d') {\r\n    forceX = d3ForceX();\r\n    forceY = d3ForceY();\r\n  } else {\r\n    forceX = d3ForceX(600).strength(0.05);\r\n    forceY = d3ForceY(600).strength(0.05);\r\n  }\r\n\r\n  // Create the simulation\r\n  const sim = d3ForceSimulation()\r\n    .force('center', d3ForceCenter(0, 0))\r\n    .force('link', d3ForceLink())\r\n    .force('charge', d3ForceManyBody().strength(nodeStrengthAdjustment))\r\n    .force('x', forceX)\r\n    .force('y', forceY)\r\n    .force('z', d3ForceZ())\r\n    // Handles nodes not overlapping each other ( most relevant in clustering )\r\n    .force(\r\n      'collide',\r\n      forceCollide(d => d.radius + 10)\r\n    )\r\n    .force(\r\n      'dagRadial',\r\n      forceRadial({\r\n        nodes,\r\n        edges,\r\n        mode,\r\n        nodeLevelRatio\r\n      })\r\n    )\r\n    .stop();\r\n\r\n  let groupingForce;\r\n  if (clusterAttribute) {\r\n    // Dynamically adjust cluster force charge based on the number of nodes\r\n    let forceChargeAdjustment = forceCharge;\r\n    if (nodes?.length) {\r\n      const adjustmentFactor = Math.ceil(nodes.length / 200);\r\n      forceChargeAdjustment = forceCharge * adjustmentFactor;\r\n    }\r\n\r\n    groupingForce = forceInABox()\r\n      // The clusters dragged position to reuse for the layout\r\n      .setClusters(clusters)\r\n      // Strength to foci\r\n      .strength(clusterStrength)\r\n      // Either treemap or force\r\n      .template(clusterType)\r\n      // Node attribute to group\r\n      .groupBy(d => d.data[clusterAttribute])\r\n      // The graph links. Must be called after setting the grouping attribute\r\n      .links(edges)\r\n      // Size of the chart\r\n      .size([100, 100])\r\n      // linkStrength between nodes of different clusters\r\n      .linkStrengthInterCluster(linkStrengthInterCluster)\r\n      // linkStrength between nodes of the same cluster\r\n      .linkStrengthIntraCluster(linkStrengthIntraCluster)\r\n      // linkDistance between meta-nodes on the template (Force template only)\r\n      .forceLinkDistance(forceLinkDistance)\r\n      // linkStrength between meta-nodes of the template (Force template only)\r\n      .forceLinkStrength(forceLinkStrength)\r\n      // Charge between the meta-nodes (Force template only)\r\n      .forceCharge(forceChargeAdjustment)\r\n      // Used to compute the template force nodes size (Force template only)\r\n      .forceNodeSize(d => d.radius);\r\n  }\r\n\r\n  // Initialize the simulation\r\n  let layout = sim.numDimensions(dimensions).nodes(nodes);\r\n\r\n  if (groupingForce) {\r\n    layout = layout.force('group', groupingForce);\r\n  }\r\n\r\n  // Run the force on the links\r\n  if (linkDistance) {\r\n    let linkForce = layout.force('link');\r\n    if (linkForce) {\r\n      linkForce\r\n        .id(d => d.id)\r\n        .links(edges)\r\n        // When no mode passed, its a tree layout\r\n        // so let's use a larger distance\r\n        .distance(linkDistance);\r\n\r\n      if (groupingForce) {\r\n        linkForce = linkForce.strength(groupingForce?.getLinkStrength ?? 0.1);\r\n      }\r\n    }\r\n  }\r\n\r\n  const nodeMap = new Map(nodes.map(n => [n.id, n]));\r\n\r\n  return {\r\n    step() {\r\n      // Run the simulation til we get a stable result\r\n      while (sim.alpha() > 0.01) {\r\n        sim.tick();\r\n      }\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) {\r\n          return pos;\r\n        }\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        // If we dragged, we need to use that position\r\n        return drags?.[id]?.position as any;\r\n      }\r\n\r\n      return nodeMap.get(id);\r\n    }\r\n  };\r\n}\r\n","import { hierarchy, stratify, tree } from 'd3-hierarchy';\r\n\r\nimport type { InternalGraphNode } from '../types';\r\nimport type { DepthNode } from './depthUtils';\r\nimport { getNodeDepth } from './depthUtils';\r\nimport { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\r\n\r\nexport interface HierarchicalLayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Direction of the layout. Default 'td'.\r\n   */\r\n  mode?: 'td' | 'lr';\r\n  /**\r\n   * Factor of distance between nodes. Default 1.\r\n   */\r\n  nodeSeparation?: number;\r\n  /**\r\n   * Size of each node. Default [50,50]\r\n   */\r\n  nodeSize?: [number, number];\r\n}\r\n\r\nconst DIRECTION_MAP = {\r\n  td: {\r\n    x: 'x',\r\n    y: 'y',\r\n    factor: -1\r\n  },\r\n  lr: {\r\n    x: 'y',\r\n    y: 'x',\r\n    factor: 1\r\n  }\r\n};\r\n\r\nexport function hierarchical({\r\n  graph,\r\n  drags,\r\n  mode = 'td',\r\n  nodeSeparation = 2,\r\n  nodeSize = [60, 60],\r\n  getNodePosition\r\n}: HierarchicalLayoutInputs): LayoutStrategy {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  // find root node by finding the nodes which have no incoming edges\r\n  const parentNodes = nodes.filter(n => !edges.find(e => e.target === n.id));\r\n  console.log('parentNodes', parentNodes);\r\n\r\n  // if more than 1 root node, then we have multiple trees\r\n  // insert a fake root node to connect all root nodes\r\n  if (parentNodes.length > 1) {\r\n    const fakeRootNode: InternalGraphNode = {\r\n      id: 'fakeRoot',\r\n      label: '',\r\n      fill: '#fff',\r\n      activeFill: '#fff',\r\n      icon: '',\r\n      data: {\r\n        id: 'fakeRoot',\r\n        loaded: true,\r\n        extra: {\r\n          id: 'fakeRoot',\r\n          properties: {},\r\n          labels: []\r\n        },\r\n        className: '',\r\n        style: {\r\n          label: ''\r\n        }\r\n      },\r\n      position: {\r\n        id: '',\r\n        data: {},\r\n        links: [],\r\n        index: 0,\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        vx: 0,\r\n        vy: 0\r\n      }\r\n    };\r\n\r\n    // add fake root node to nodes\r\n    nodes.push(fakeRootNode);\r\n\r\n    // add edges from fake root to root nodes\r\n    parentNodes.forEach(n => {\r\n      edges.push({\r\n        id: `fakeRoot-${n.id}`,\r\n        source: 'fakeRoot',\r\n        target: n.id,\r\n        label: '',\r\n        backgroundColor: '#fff'\r\n      });\r\n    });\r\n  }\r\n\r\n  const { depths } = getNodeDepth(nodes, edges);\r\n  const rootNodes = Object.keys(depths).map(d => depths[d]);\r\n\r\n  const root = stratify<DepthNode>()\r\n    .id(d => d.data.id)\r\n    .parentId(d => d.ins?.[0]?.data?.id)(rootNodes);\r\n\r\n  const treeRoot = tree()\r\n    .separation(() => nodeSeparation)\r\n    .nodeSize(nodeSize)(hierarchy(root));\r\n\r\n  const treeNodes = treeRoot.descendants();\r\n  const path = DIRECTION_MAP[mode];\r\n\r\n  const mappedNodes = new Map<string, InternalGraphNode>(\r\n    nodes.map(n => {\r\n      const { x, y } = treeNodes.find((t: any) => t.data.id === n.id);\r\n      return [\r\n        n.id,\r\n        {\r\n          ...n,\r\n          [path.x]: x * path.factor,\r\n          [path.y]: y * path.factor,\r\n          z: 0\r\n        }\r\n      ];\r\n    })\r\n  );\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) {\r\n          return pos;\r\n        }\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        // If we dragged, we need to use that position\r\n        return drags?.[id]?.position as any;\r\n      }\r\n\r\n      return mappedNodes.get(id);\r\n    }\r\n  };\r\n}\r\n","import type { ConcentricLayoutInputs } from 'layout/concentric2d';\r\nimport { Vector3 } from 'three';\r\n\r\nimport { buildNodeEdges } from './layoutUtils';\r\n\r\n/**\r\n * Generates a point on a Fibonacci sphere.\r\n * @param i\r\n * @param n\r\n * @param r\r\n */\r\nfunction fibonacciSpherePoint(i: number, n: number, r: number) {\r\n  const phi = Math.acos(1 - (2 * (i + 0.5)) / n);\r\n  const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);\r\n  const x = r * Math.sin(phi) * Math.cos(theta);\r\n  const y = r * Math.sin(phi) * Math.sin(theta);\r\n  const z = r * Math.cos(phi);\r\n\r\n  return new Vector3(x, y, z);\r\n}\r\n\r\n/**\r\n * Concentric layout algorithm for 3D graphs.\r\n * @param graph\r\n * @param radius\r\n * @param drags\r\n * @param getNodePosition\r\n * @param concentricSpacing\r\n */\r\nexport function concentric3d({\r\n  graph,\r\n  radius = 40,\r\n  drags,\r\n  getNodePosition,\r\n  concentricSpacing = 100\r\n}: ConcentricLayoutInputs) {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  const layout: Record<string, { x: number; y: number; z: number }> = {};\r\n\r\n  const getNodesInLevel = (level: number) => {\r\n    const circumference = 2 * Math.PI * (radius + level * concentricSpacing);\r\n    const minNodeSpacing = 40;\r\n    return Math.floor(circumference / minNodeSpacing);\r\n  };\r\n\r\n  const fixedLevelMap = new Map<number, string[]>();\r\n  const dynamicNodes: { id: string; metric: number }[] = [];\r\n\r\n  // Split nodes: fixed-level and dynamic\r\n  for (const node of nodes) {\r\n    const data = graph.getNodeAttribute(node.id, 'data');\r\n    const level = data?.level;\r\n\r\n    if (typeof level === 'number' && level >= 0) {\r\n      if (!fixedLevelMap.has(level)) {\r\n        fixedLevelMap.set(level, []);\r\n      }\r\n      fixedLevelMap.get(level)!.push(node.id);\r\n    } else {\r\n      dynamicNodes.push({ id: node.id, metric: graph.degree(node.id) });\r\n    }\r\n  }\r\n\r\n  // Sort dynamic nodes by degree\r\n  dynamicNodes.sort((a, b) => b.metric - a.metric);\r\n\r\n  // Fill layout for fixed-level nodes (3D spherical placement)\r\n  for (const [level, nodeIds] of fixedLevelMap.entries()) {\r\n    const count = nodeIds.length;\r\n    const r = radius + level * concentricSpacing;\r\n\r\n    for (const [i, id] of nodeIds.entries()) {\r\n      const pos = fibonacciSpherePoint(i, count, r);\r\n      layout[id] = { x: pos.x, y: pos.y, z: pos.z };\r\n    }\r\n  }\r\n\r\n  // Determine which levels are partially used and which are available\r\n  const occupiedLevels = new Set(fixedLevelMap.keys());\r\n  let dynamicLevel = 0;\r\n\r\n  let i = 0;\r\n  while (i < dynamicNodes.length) {\r\n    // Skip occupied levels\r\n    while (occupiedLevels.has(dynamicLevel)) {\r\n      dynamicLevel++;\r\n    }\r\n\r\n    const nodesInLevel = getNodesInLevel(dynamicLevel);\r\n    const r = radius + dynamicLevel * concentricSpacing;\r\n\r\n    for (let j = 0; j < nodesInLevel && i < dynamicNodes.length; j++) {\r\n      const pos = fibonacciSpherePoint(j, nodesInLevel, r);\r\n      layout[dynamicNodes[i].id] = { x: pos.x, y: pos.y, z: pos.z };\r\n      i++;\r\n    }\r\n\r\n    dynamicLevel++;\r\n  }\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) {\r\n          return pos;\r\n        }\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        return drags[id].position as any;\r\n      }\r\n\r\n      return layout[id];\r\n    }\r\n  };\r\n}\r\n","import noverlapLayout from 'graphology-layout-noverlap';\r\n\r\nimport { buildNodeEdges } from './layoutUtils';\r\nimport type { LayoutFactoryProps } from './types';\r\n\r\nexport interface NoOverlapLayoutInputs extends LayoutFactoryProps {\r\n  /**\r\n   * Grid size. Default 20.\r\n   */\r\n  gridSize?: number;\r\n\r\n  /**\r\n   * Ratio of the layout. Default 10.\r\n   */\r\n  ratio?: number;\r\n\r\n  /**\r\n   * Maximum number of iterations. Default 50.\r\n   */\r\n  maxIterations?: number;\r\n\r\n  /**\r\n   * Margin between nodes. Default 10.\r\n   */\r\n  margin?: number;\r\n}\r\n\r\nexport function nooverlap({\r\n  graph,\r\n  margin,\r\n  drags,\r\n  getNodePosition,\r\n  ratio,\r\n  gridSize,\r\n  maxIterations\r\n}: NoOverlapLayoutInputs) {\r\n  const { nodes, edges } = buildNodeEdges(graph);\r\n\r\n  const layout = noverlapLayout(graph, {\r\n    maxIterations,\r\n    inputReducer: (_key, attr) => ({\r\n      ...attr,\r\n      // Have to specify defaults for the engine\r\n      x: attr.x || 0,\r\n      y: attr.y || 0\r\n    }),\r\n    settings: {\r\n      ratio,\r\n      margin,\r\n      gridSize\r\n    }\r\n  });\r\n\r\n  return {\r\n    step() {\r\n      return true;\r\n    },\r\n    getNodePosition(id: string) {\r\n      if (getNodePosition) {\r\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\r\n        if (pos) {\r\n          return pos;\r\n        }\r\n      }\r\n\r\n      if (drags?.[id]?.position) {\r\n        // If we dragged, we need to use that position\r\n        return drags?.[id]?.position as any;\r\n      }\r\n\r\n      return layout?.[id];\r\n    }\r\n  };\r\n}\r\n","import { concentric2d } from 'layout/concentric2d';\r\nimport { concentric3d } from 'layout/concentric3d';\r\n\r\nimport type { CircularLayoutInputs } from './circular2d';\r\nimport { circular2d } from './circular2d';\r\nimport type { ConcentricLayoutInputs } from './concentric2d';\r\nimport { custom } from './custom';\r\nimport type { ForceAtlas2LayoutInputs } from './forceatlas2';\r\nimport { forceAtlas2 } from './forceatlas2';\r\nimport type { ForceDirectedLayoutInputs } from './forceDirected';\r\nimport { forceDirected } from './forceDirected';\r\nimport type { HierarchicalLayoutInputs } from './hierarchical';\r\nimport { hierarchical } from './hierarchical';\r\nimport type { NoOverlapLayoutInputs } from './nooverlap';\r\nimport { nooverlap } from './nooverlap';\r\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\r\n\r\nexport type LayoutOverrides = Partial<\r\n  | Omit<ForceDirectedLayoutInputs, 'dimensions' | 'mode'>\r\n  | CircularLayoutInputs\r\n  | ConcentricLayoutInputs\r\n  | HierarchicalLayoutInputs\r\n>;\r\n\r\nexport const FORCE_LAYOUTS = [\r\n  'forceDirected2d',\r\n  'treeTd2d',\r\n  'treeLr2d',\r\n  'radialOut2d',\r\n  'treeTd3d',\r\n  'treeLr3d',\r\n  'radialOut3d',\r\n  'forceDirected3d'\r\n];\r\n\r\nexport function layoutProvider({\r\n  type,\r\n  ...rest\r\n}: LayoutFactoryProps | LayoutOverrides): LayoutStrategy {\r\n  if (FORCE_LAYOUTS.includes(type)) {\r\n    const { nodeStrength, linkDistance, nodeLevelRatio } =\r\n      rest as ForceDirectedLayoutInputs;\r\n\r\n    if (type === 'forceDirected2d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        dimensions: 2,\r\n        nodeLevelRatio: nodeLevelRatio || 2,\r\n        nodeStrength: nodeStrength || -250,\r\n        linkDistance,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'treeTd2d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'td',\r\n        dimensions: 2,\r\n        nodeLevelRatio: nodeLevelRatio || 5,\r\n        nodeStrength: nodeStrength || -250,\r\n        linkDistance: linkDistance || 50,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'treeLr2d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'lr',\r\n        dimensions: 2,\r\n        nodeLevelRatio: nodeLevelRatio || 5,\r\n        nodeStrength: nodeStrength || -250,\r\n        linkDistance: linkDistance || 50,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'radialOut2d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'radialout',\r\n        dimensions: 2,\r\n        nodeLevelRatio: nodeLevelRatio || 5,\r\n        nodeStrength: nodeStrength || -500,\r\n        linkDistance: linkDistance || 100,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'treeTd3d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'td',\r\n        dimensions: 3,\r\n        nodeLevelRatio: nodeLevelRatio || 2,\r\n        nodeStrength: nodeStrength || -500,\r\n        linkDistance: linkDistance || 50\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'treeLr3d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'lr',\r\n        dimensions: 3,\r\n        nodeLevelRatio: nodeLevelRatio || 2,\r\n        nodeStrength: nodeStrength || -500,\r\n        linkDistance: linkDistance || 50,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'radialOut3d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        mode: 'radialout',\r\n        dimensions: 3,\r\n        nodeLevelRatio: nodeLevelRatio || 2,\r\n        nodeStrength: nodeStrength || -500,\r\n        linkDistance: linkDistance || 100,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    } else if (type === 'forceDirected3d') {\r\n      return forceDirected({\r\n        ...rest,\r\n        dimensions: 3,\r\n        nodeLevelRatio: nodeLevelRatio || 2,\r\n        nodeStrength: nodeStrength || -250,\r\n        linkDistance,\r\n        forceLayout: type\r\n      } as ForceDirectedLayoutInputs);\r\n    }\r\n  } else if (type === 'circular2d') {\r\n    const { radius } = rest as CircularLayoutInputs;\r\n    return circular2d({\r\n      ...rest,\r\n      radius: radius || 300\r\n    } as CircularLayoutInputs);\r\n  } else if (type === 'concentric2d') {\r\n    return concentric2d(rest as ConcentricLayoutInputs);\r\n  } else if (type === 'concentric3d') {\r\n    return concentric3d(rest as ConcentricLayoutInputs);\r\n  } else if (type === 'hierarchicalTd') {\r\n    return hierarchical({ ...rest, mode: 'td' } as HierarchicalLayoutInputs);\r\n  } else if (type === 'hierarchicalLr') {\r\n    return hierarchical({ ...rest, mode: 'lr' } as HierarchicalLayoutInputs);\r\n  } else if (type === 'nooverlap') {\r\n    const { graph, maxIterations, ratio, margin, gridSize, ...settings } =\r\n      rest as NoOverlapLayoutInputs;\r\n\r\n    return nooverlap({\r\n      type: 'nooverlap',\r\n      graph,\r\n      margin: margin || 10,\r\n      maxIterations: maxIterations || 50,\r\n      ratio: ratio || 10,\r\n      gridSize: gridSize || 20,\r\n      ...settings\r\n    });\r\n  } else if (type === 'forceatlas2') {\r\n    const { graph, iterations, gravity, scalingRatio, ...settings } =\r\n      rest as ForceAtlas2LayoutInputs;\r\n\r\n    return forceAtlas2({\r\n      type: 'forceatlas2',\r\n      graph,\r\n      ...settings,\r\n      scalingRatio: scalingRatio || 100,\r\n      gravity: gravity || 10,\r\n      iterations: iterations || 50\r\n    });\r\n  } else if (type === 'custom') {\r\n    return custom({\r\n      type: 'custom',\r\n      ...rest\r\n    } as LayoutFactoryProps);\r\n  }\r\n\r\n  throw new Error(`Layout ${type} not found.`);\r\n}\r\n","import type { GraphEdge, GraphNode } from '../types';\r\nimport { getNodeDepth } from './depthUtils';\r\nimport type { LayoutTypes } from './types';\r\n\r\n/**\r\n * Given a set of nodes and edges, determine the type of layout that\r\n * is most ideal. This is very beta.\r\n */\r\nexport function recommendLayout(\r\n  nodes: GraphNode[],\r\n  edges: GraphEdge[]\r\n): LayoutTypes {\r\n  const { invalid } = getNodeDepth(nodes as any[], edges as any[]);\r\n  const nodeCount = nodes.length;\r\n\r\n  if (!invalid) {\r\n    // Large tree layouts\r\n    if (nodeCount > 100) {\r\n      return 'radialOut2d';\r\n    } else {\r\n      // Smaller tree layouts\r\n      return 'treeTd2d';\r\n    }\r\n  }\r\n\r\n  // Circular layouts\r\n  return 'forceDirected2d';\r\n}\r\n","import { useThree } from '@react-three/fiber';\r\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\r\nimport type { PerspectiveCamera } from 'three';\r\n\r\nimport { getVisibleEntities } from './collapse';\r\nimport type { LayoutOverrides, LayoutStrategy, LayoutTypes } from './layout';\r\nimport { layoutProvider } from './layout';\r\nimport { tick } from './layout/layoutUtils';\r\nimport type { SizingType } from './sizing';\r\nimport type { DragReferences } from './store';\r\nimport { useStore } from './store';\r\nimport type { GraphEdge, GraphNode, InternalGraphNode } from './types';\r\nimport { calculateClusters } from './utils/cluster';\r\nimport { buildGraph, transformGraph } from './utils/graph';\r\nimport type { LabelVisibilityType } from './utils/visibility';\r\nimport { calcLabelVisibility } from './utils/visibility';\r\n\r\nexport interface GraphInputs {\r\n  nodes: GraphNode[];\r\n  edges: GraphEdge[];\r\n  collapsedNodeIds?: string[];\r\n  layoutType?: LayoutTypes;\r\n  sizingType?: SizingType;\r\n  labelType?: LabelVisibilityType;\r\n  sizingAttribute?: string;\r\n  selections?: string[];\r\n  actives?: string[];\r\n  clusterAttribute?: string;\r\n  defaultNodeSize?: number;\r\n  minNodeSize?: number;\r\n  maxNodeSize?: number;\r\n  constrainDragging?: boolean;\r\n  layoutOverrides?: LayoutOverrides;\r\n}\r\n\r\nexport const useGraph = ({\r\n  layoutType,\r\n  sizingType,\r\n  labelType,\r\n  sizingAttribute,\r\n  clusterAttribute,\r\n  selections,\r\n  nodes,\r\n  edges,\r\n  actives,\r\n  collapsedNodeIds,\r\n  defaultNodeSize,\r\n  maxNodeSize,\r\n  minNodeSize,\r\n  layoutOverrides,\r\n  constrainDragging\r\n}: GraphInputs) => {\r\n  const graph = useStore(state => state.graph);\r\n  const clusters = useStore(state => state.clusters);\r\n  const storedNodes = useStore(state => state.nodes);\r\n  const setClusters = useStore(state => state.setClusters);\r\n  const stateCollapsedNodeIds = useStore(state => state.collapsedNodeIds);\r\n  const setEdges = useStore(state => state.setEdges);\r\n  const stateNodes = useStore(state => state.nodes);\r\n  const setNodes = useStore(state => state.setNodes);\r\n  const setSelections = useStore(state => state.setSelections);\r\n  const setActives = useStore(state => state.setActives);\r\n  const drags = useStore(state => state.drags);\r\n  const setDrags = useStore(state => state.setDrags);\r\n  const setCollapsedNodeIds = useStore(state => state.setCollapsedNodeIds);\r\n  const layoutMounted = useRef<boolean>(false);\r\n  const layout = useRef<LayoutStrategy | null>(null);\r\n  const camera = useThree(state => state.camera) as PerspectiveCamera;\r\n  const dragRef = useRef<DragReferences>(drags);\r\n  const clustersRef = useRef<any>([]);\r\n\r\n  // When a new node is added, remove the dragged position of the cluster nodes to put new node in the right place\r\n  useEffect(() => {\r\n    if (!clusterAttribute) {\r\n      return;\r\n    }\r\n\r\n    const existedNodesIds = storedNodes.map(n => n.id);\r\n    const newNode = nodes.find(n => !existedNodesIds.includes(n.id));\r\n    if (newNode) {\r\n      const clusterName = newNode.data[clusterAttribute];\r\n      const cluster = clusters.get(clusterName);\r\n      const drags = { ...dragRef.current };\r\n\r\n      cluster?.nodes?.forEach(node => (drags[node.id] = undefined));\r\n\r\n      dragRef.current = drags;\r\n      setDrags(drags);\r\n    }\r\n  }, [storedNodes, nodes, clusterAttribute, clusters, setDrags]);\r\n\r\n  // Calculate the visible entities\r\n  const { visibleEdges, visibleNodes } = useMemo(\r\n    () =>\r\n      getVisibleEntities({\r\n        collapsedIds: stateCollapsedNodeIds,\r\n        nodes,\r\n        edges\r\n      }),\r\n    [stateCollapsedNodeIds, nodes, edges]\r\n  );\r\n\r\n  // Store node positions inside drags state\r\n  const updateDrags = useCallback(\r\n    (nodes: InternalGraphNode[]) => {\r\n      const drags = { ...dragRef.current };\r\n      nodes.forEach(node => (drags[node.id] = node));\r\n      dragRef.current = drags;\r\n      setDrags(drags);\r\n    },\r\n    [setDrags]\r\n  );\r\n\r\n  const updateLayout = useCallback(\r\n    async (curLayout?: any) => {\r\n      // Cache the layout provider\r\n      layout.current =\r\n        curLayout ||\r\n        layoutProvider({\r\n          ...layoutOverrides,\r\n          type: layoutType,\r\n          graph,\r\n          drags: dragRef.current,\r\n          clusters: clustersRef?.current,\r\n          clusterAttribute\r\n        });\r\n\r\n      // Run the layout\r\n      await tick(layout.current);\r\n\r\n      // Transform the graph\r\n      const result = transformGraph({\r\n        graph,\r\n        layout: layout.current,\r\n        sizingType,\r\n        labelType,\r\n        sizingAttribute,\r\n        maxNodeSize,\r\n        minNodeSize,\r\n        defaultNodeSize,\r\n        clusterAttribute\r\n      });\r\n\r\n      // Calculate clusters\r\n      const newClusters = calculateClusters({\r\n        nodes: result.nodes,\r\n        clusterAttribute\r\n      });\r\n\r\n      // Do not decrease the cluster size is the number of nodes is the same\r\n      if (constrainDragging) {\r\n        newClusters.forEach(cluster => {\r\n          const prevCluster = clustersRef.current.get(cluster.label);\r\n          if (prevCluster?.nodes.length === cluster.nodes.length) {\r\n            cluster.position =\r\n              clustersRef.current?.get(cluster.label)?.position ??\r\n              cluster.position;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Set our store outputs\r\n      setEdges(result.edges);\r\n      setNodes(result.nodes);\r\n      setClusters(newClusters);\r\n      if (clusterAttribute) {\r\n        // Set drag positions for nodes to prevent them from being moved by the layout update\r\n        updateDrags(result.nodes);\r\n      }\r\n    },\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [\r\n      layoutOverrides,\r\n      layoutType,\r\n      clusterAttribute,\r\n      sizingType,\r\n      labelType,\r\n      sizingAttribute,\r\n      maxNodeSize,\r\n      minNodeSize,\r\n      defaultNodeSize,\r\n      setEdges,\r\n      setNodes,\r\n      setClusters\r\n    ]\r\n  );\r\n\r\n  // Transient updates\r\n  useEffect(() => {\r\n    dragRef.current = drags;\r\n  }, [drags, clusterAttribute, updateLayout]);\r\n\r\n  // Transient cluster state\r\n  useEffect(() => {\r\n    clustersRef.current = clusters;\r\n  }, [clusters]);\r\n\r\n  useEffect(() => {\r\n    // When the camera position/zoom changes, update the label visibility\r\n    const nodes = stateNodes.map(node => ({\r\n      ...node,\r\n      labelVisible: calcLabelVisibility({\r\n        nodeCount: stateNodes?.length,\r\n        labelType,\r\n        camera,\r\n        nodePosition: node?.position\r\n      })('node', node?.size)\r\n    }));\r\n\r\n    // Determine if the label visibility has changed\r\n    const isVisibilityUpdated = nodes.some(\r\n      (node, i) => node.labelVisible !== stateNodes[i].labelVisible\r\n    );\r\n\r\n    // Update the nodes if the label visibility has changed\r\n    if (isVisibilityUpdated) {\r\n      setNodes(nodes);\r\n    }\r\n  }, [camera, camera.zoom, camera.position.z, setNodes, stateNodes, labelType]);\r\n\r\n  useEffect(() => {\r\n    // Let's set the store selections so its easier to access\r\n    if (layoutMounted.current) {\r\n      setSelections(selections);\r\n    }\r\n  }, [selections, setSelections]);\r\n\r\n  useEffect(() => {\r\n    // Let's set the store actives so its easier to access\r\n    if (layoutMounted.current) {\r\n      setActives(actives);\r\n    }\r\n  }, [actives, setActives]);\r\n\r\n  // Create the nggraph graph object\r\n  useEffect(() => {\r\n    async function update() {\r\n      layoutMounted.current = false;\r\n      buildGraph(graph, visibleNodes, visibleEdges);\r\n      await updateLayout();\r\n      // rqf to prevent race condition\r\n      requestAnimationFrame(() => (layoutMounted.current = true));\r\n    }\r\n\r\n    update();\r\n    // eslint-disable-next-line\r\n  }, [visibleNodes, visibleEdges]);\r\n\r\n  useEffect(() => {\r\n    // Let's set the store collapsedNodeIds so its easier to access\r\n    if (layoutMounted.current) {\r\n      setCollapsedNodeIds(collapsedNodeIds);\r\n    }\r\n  }, [collapsedNodeIds, setCollapsedNodeIds]);\r\n\r\n  // Update layout on type changes\r\n  useEffect(() => {\r\n    if (layoutMounted.current) {\r\n      // When a update is changed, discard all the previous drag positions\r\n      // NOTE: This sets the transient and the state\r\n      dragRef.current = {};\r\n      setDrags({});\r\n\r\n      // Recalculate the layout\r\n      updateLayout();\r\n    }\r\n  }, [layoutType, updateLayout, setDrags]);\r\n\r\n  // Update layout on size, label changes\r\n  useEffect(() => {\r\n    if (layoutMounted.current) {\r\n      updateLayout(layout.current);\r\n    }\r\n  }, [sizingType, sizingAttribute, labelType, updateLayout]);\r\n\r\n  return {\r\n    updateLayout\r\n  };\r\n};\r\n","import type Graph from 'graphology';\r\n\r\nimport type { InternalGraphEdge } from '../types';\r\nimport type { LabelVisibilityType } from './visibility';\r\n\r\n/**\r\n * Graphology-native approach using reduceEdges for optimal performance\r\n * @param graph Graphology graph instance\r\n * @returns Map with source-target pairs as keys and arrays of edges as values\r\n */\r\nexport const groupEdgesBySourceTarget = (\r\n  graph: Graph\r\n): Map<string, InternalGraphEdge[]> => {\r\n  // Use Graphology's native reduceEdges\r\n  return graph.reduceEdges(\r\n    (\r\n      edgeGroups: Map<string, InternalGraphEdge[]>,\r\n      edgeKey,\r\n      attributes,\r\n      source,\r\n      target\r\n    ) => {\r\n      const key = `${source}-${target}`;\r\n\r\n      // Construct complete InternalGraphEdge object\r\n      const edge: InternalGraphEdge = {\r\n        id: edgeKey,\r\n        source,\r\n        target,\r\n        ...attributes\r\n      };\r\n\r\n      const group = edgeGroups.get(key);\r\n      if (group) {\r\n        group.push(edge);\r\n      } else {\r\n        edgeGroups.set(key, [edge]);\r\n      }\r\n\r\n      return edgeGroups;\r\n    },\r\n    new Map<string, InternalGraphEdge[]>()\r\n  );\r\n};\r\n\r\n/**\r\n * Aggregates edges with the same source and target using Graphology's native functions\r\n * @param graph Graphology graph instance\r\n * @param labelType Label visibility type to determine if edge labels should be visible\r\n * @returns Array of aggregated edges\r\n */\r\nexport const aggregateEdges = (\r\n  graph: Graph,\r\n  labelType?: LabelVisibilityType\r\n): InternalGraphEdge[] => {\r\n  if (!graph || graph.size === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Use Graphology's native reduceEdges to group and aggregate in one pass\r\n  const edgeGroups = groupEdgesBySourceTarget(graph);\r\n  const aggregatedEdges: InternalGraphEdge[] = [];\r\n  // Determine if edge labels should be visible based on labelType\r\n  const shouldShowEdgeLabels = labelType === 'all' || labelType === 'edges';\r\n\r\n  // Process groups efficiently\r\n  for (const [key, group] of edgeGroups) {\r\n    const [source, target] = key.split('-');\r\n    const firstEdge = group[0];\r\n\r\n    if (!source || !target || !firstEdge) {\r\n      continue;\r\n    }\r\n\r\n    // Calculate the aggregated edge size based on the number of edges\r\n    const baseSize = firstEdge.size || 1; // Default to 1 if no size is specified\r\n    const aggregatedSize = baseSize + group.length * baseSize * 0.5;\r\n\r\n    // Only show aggregation label when actually aggregating multiple edges\r\n    const aggregated = group.length > 1;\r\n    const label = aggregated ? `${group.length} edges` : firstEdge.label;\r\n\r\n    // Create an aggregated edge that represents the group\r\n    const aggregatedEdge: InternalGraphEdge = {\r\n      ...firstEdge,\r\n      source,\r\n      target,\r\n      label,\r\n      labelVisible: shouldShowEdgeLabels,\r\n      size: aggregatedSize,\r\n      // Store the original edges in the data property\r\n      data: {\r\n        ...(firstEdge.data || {}),\r\n        originalEdges: group,\r\n        count: group.length,\r\n        isAggregated: aggregated,\r\n        originalSize: baseSize\r\n      }\r\n    };\r\n\r\n    aggregatedEdges.push(aggregatedEdge);\r\n  }\r\n\r\n  return aggregatedEdges;\r\n};\r\n","import type { ThreeEvent } from '@react-three/fiber';\r\nimport { useThree } from '@react-three/fiber';\r\nimport type Graph from 'graphology';\r\nimport type { ReactNode } from 'react';\r\nimport React, {\r\n  forwardRef,\r\n  Fragment,\r\n  useCallback,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useMemo\r\n} from 'react';\r\n\r\nimport type {\r\n  CenterNodesParams,\r\n  FitNodesParams\r\n} from './CameraControls/useCenterGraph';\r\nimport { useCenterGraph } from './CameraControls/useCenterGraph';\r\nimport type { LayoutOverrides, LayoutTypes } from './layout';\r\nimport type { SizingType } from './sizing';\r\nimport { useStore } from './store';\r\nimport { Node } from './symbols';\r\nimport type { ClusterEventArgs } from './symbols/Cluster';\r\nimport { Cluster } from './symbols/Cluster';\r\nimport type { EdgeInterpolation, EdgeLabelPosition } from './symbols/Edge';\r\nimport { Edge } from './symbols/Edge';\r\nimport { Edges } from './symbols/edges';\r\nimport type { EdgeArrowPosition } from './symbols/edges/Edge';\r\nimport type {\r\n  ClusterRenderer,\r\n  CollapseProps,\r\n  ContextMenuEvent,\r\n  GraphEdge,\r\n  GraphNode,\r\n  InternalGraphEdge,\r\n  InternalGraphNode,\r\n  NodeContextMenuProps,\r\n  NodeRenderer\r\n} from './types';\r\nimport { useGraph } from './useGraph';\r\nimport { aggregateEdges as aggregateEdgesUtil } from './utils/aggregateEdges';\r\nimport type { LabelVisibilityType } from './utils/visibility';\r\n\r\nexport interface GraphSceneProps {\r\n  /**\r\n   * Type of layout.\r\n   */\r\n  layoutType?: LayoutTypes;\r\n\r\n  /**\r\n   * List of ids that are selected.\r\n   */\r\n  selections?: string[];\r\n\r\n  /**\r\n   * List of ids that are active.\r\n   */\r\n  actives?: string[];\r\n\r\n  /**\r\n   * List of node ids that are collapsed.\r\n   */\r\n  collapsedNodeIds?: string[];\r\n\r\n  /**\r\n   * Animate or not the graph positions.\r\n   */\r\n  animated?: boolean;\r\n\r\n  /**\r\n   * Nodes to pass to the graph.\r\n   */\r\n  nodes: GraphNode[];\r\n\r\n  /**\r\n   * Edges to pass to the graph.\r\n   */\r\n  edges: GraphEdge[];\r\n\r\n  /**\r\n   * Context menu element.\r\n   */\r\n  contextMenu?: (event: ContextMenuEvent) => ReactNode;\r\n\r\n  /**\r\n   * Type of sizing for nodes.\r\n   */\r\n  sizingType?: SizingType;\r\n\r\n  /**\r\n   * Type of visibility for labels.\r\n   */\r\n  labelType?: LabelVisibilityType;\r\n\r\n  /**\r\n   * Place of visibility for edge labels.\r\n   */\r\n  edgeLabelPosition?: EdgeLabelPosition;\r\n\r\n  /**\r\n   * Placement of edge arrows.\r\n   */\r\n  edgeArrowPosition?: EdgeArrowPosition;\r\n\r\n  /**\r\n   * Shape of edge.\r\n   */\r\n  edgeInterpolation?: EdgeInterpolation;\r\n\r\n  /**\r\n   * Font of label, same as troika-three-text\r\n   * The URL of a custom font file to be used. Supported font formats are: * .ttf * .otf * .woff (.woff2 is not supported)\r\n   * Default: The Roboto font loaded from Google Fonts CDN\r\n   */\r\n  labelFontUrl?: string;\r\n\r\n  /**\r\n   * Attribute based sizing property.\r\n   */\r\n  sizingAttribute?: string;\r\n\r\n  /**\r\n   * The default size to size nodes to. Default is 7.\r\n   */\r\n  defaultNodeSize?: number;\r\n\r\n  /**\r\n   * When using sizing attributes, the min size a node can be.\r\n   */\r\n  minNodeSize?: number;\r\n\r\n  /**\r\n   * When using sizing attributes, the max size a node can be.\r\n   */\r\n  maxNodeSize?: number;\r\n\r\n  /**\r\n   * Attribute used for clustering.\r\n   */\r\n  clusterAttribute?: string;\r\n\r\n  /**\r\n   * Disable interactions or not.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * Allow dragging of nodes.\r\n   */\r\n  draggable?: boolean;\r\n\r\n  /**\r\n   * Constrain dragging to the cluster bounds. Default is `false`.\r\n   */\r\n  constrainDragging?: boolean;\r\n\r\n  /**\r\n   * Render a custom node\r\n   */\r\n  renderNode?: NodeRenderer;\r\n\r\n  /**\r\n   * Render a custom cluster\r\n   */\r\n  onRenderCluster?: ClusterRenderer;\r\n\r\n  /**\r\n   * Advanced overrides for the layout.\r\n   */\r\n  layoutOverrides?: LayoutOverrides;\r\n\r\n  /**\r\n   * Whether to aggregate edges with the same source and target.\r\n   */\r\n  aggregateEdges?: boolean;\r\n\r\n  /**\r\n   * When a node was clicked.\r\n   */\r\n  onNodeClick?: (\r\n    node: InternalGraphNode,\r\n    props?: CollapseProps,\r\n    event?: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When a node was double clicked.\r\n   */\r\n  onNodeDoubleClick?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When a node context menu happened.\r\n   */\r\n  onNodeContextMenu?: (\r\n    node: InternalGraphNode,\r\n    props?: NodeContextMenuProps\r\n  ) => void;\r\n\r\n  /**\r\n   * When node got a pointer over.\r\n   */\r\n  onNodePointerOver?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When node lost pointer over.\r\n   */\r\n  onNodePointerOut?: (\r\n    node: InternalGraphNode,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * Triggered after a node was dragged.\r\n   */\r\n  onNodeDragged?: (node: InternalGraphNode) => void;\r\n\r\n  /**\r\n   * Triggered after a cluster was dragged.\r\n   */\r\n  onClusterDragged?: (cluster: ClusterEventArgs) => void;\r\n\r\n  /**\r\n   * When a edge context menu happened.\r\n   */\r\n  onEdgeContextMenu?: (edge?: InternalGraphEdge) => void;\r\n\r\n  /**\r\n   * When an edge was clicked.\r\n   */\r\n  onEdgeClick?: (\r\n    edge: InternalGraphEdge,\r\n    event?: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When edge got a pointer over.\r\n   */\r\n  onEdgePointerOver?: (\r\n    edge: InternalGraphEdge,\r\n    event?: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When edge lost pointer over.\r\n   */\r\n  onEdgePointerOut?: (\r\n    edge: InternalGraphEdge,\r\n    event?: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When a cluster was clicked.\r\n   */\r\n  onClusterClick?: (\r\n    cluster: ClusterEventArgs,\r\n    event: ThreeEvent<MouseEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When a cluster receives a pointer over event.\r\n   */\r\n  onClusterPointerOver?: (\r\n    cluster: ClusterEventArgs,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n\r\n  /**\r\n   * When cluster receives a pointer leave event.\r\n   */\r\n  onClusterPointerOut?: (\r\n    cluster: ClusterEventArgs,\r\n    event: ThreeEvent<PointerEvent>\r\n  ) => void;\r\n}\r\n\r\nexport interface GraphSceneRef {\r\n  /**\r\n   * Reference to the graph object.\r\n   */\r\n  graph: Graph;\r\n\r\n  /**\r\n   * Centers the graph on a specific node or list of nodes.\r\n   *\r\n   * @param nodeIds - An array of node IDs to center the graph on. If this parameter is omitted,\r\n   * the graph will be centered on all nodes.\r\n   *\r\n   * @param opts.centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\r\n   * only be centered if the nodes specified by `ids` are not currently in view. If this\r\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\r\n   * specified by `ids` are not currently in view. If this parameter is\r\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\r\n   * are currently in view.\r\n   */\r\n  centerGraph: (nodeIds?: string[], opts?: CenterNodesParams) => void;\r\n\r\n  /**\r\n   * Fit all the given nodes into view of the camera.\r\n   *\r\n   * @param nodeIds - An array of node IDs to fit the view on. If this parameter is omitted,\r\n   * the view will fit to all nodes.\r\n   *\r\n   * @param opts.fitOnlyIfNodesNotInView - A boolean flag that determines whether the view should\r\n   * only be fit if the nodes specified by `ids` are not currently in view. If this\r\n   * parameter is `true`, the view will only be fit if one or more of the nodes\r\n   * specified by `ids` are not currently visible in the viewport. If this parameter is\r\n   * `false` or omitted, the view will be fit regardless of whether the nodes\r\n   * are currently in view.\r\n   */\r\n  fitNodesInView: (nodeIds?: string[], opts?: FitNodesParams) => void;\r\n\r\n  /**\r\n   * Calls render scene on the graph. this is useful when you want to manually render the graph\r\n   * for things like screenshots.\r\n   */\r\n  renderScene: () => void;\r\n}\r\n\r\nexport const GraphScene = forwardRef<GraphSceneRef, GraphSceneProps>(\r\n  (\r\n    {\r\n      onNodeClick,\r\n      onNodeDoubleClick,\r\n      onNodeContextMenu,\r\n      onEdgeContextMenu,\r\n      onEdgeClick,\r\n      onEdgePointerOver,\r\n      onEdgePointerOut,\r\n      onNodePointerOver,\r\n      onNodePointerOut,\r\n      onClusterClick,\r\n      onNodeDragged,\r\n      onClusterDragged,\r\n      onClusterPointerOver,\r\n      onClusterPointerOut,\r\n      contextMenu,\r\n      animated,\r\n      disabled,\r\n      draggable,\r\n      constrainDragging = false,\r\n      edgeLabelPosition,\r\n      edgeArrowPosition,\r\n      edgeInterpolation = 'linear',\r\n      labelFontUrl,\r\n      renderNode,\r\n      onRenderCluster,\r\n      aggregateEdges,\r\n      ...rest\r\n    },\r\n    ref\r\n  ) => {\r\n    const { layoutType, clusterAttribute, labelType } = rest;\r\n\r\n    // Get the gl/scene/camera for render shortcuts\r\n    const gl = useThree(state => state.gl);\r\n    const scene = useThree(state => state.scene);\r\n    const camera = useThree(state => state.camera);\r\n\r\n    // Mount and build the graph\r\n    const { updateLayout } = useGraph({ ...rest, constrainDragging });\r\n\r\n    if (\r\n      clusterAttribute &&\r\n      !(layoutType === 'forceDirected2d' || layoutType === 'forceDirected3d')\r\n    ) {\r\n      throw new Error(\r\n        'Clustering is only supported for the force directed layouts.'\r\n      );\r\n    }\r\n\r\n    // Get the graph and nodes via the store for memo\r\n    const graph = useStore(state => state.graph);\r\n    const nodes = useStore(state => state.nodes);\r\n    const edgesStore = useStore(state => state.edges);\r\n    const setEdges = useStore(state => state.setEdges);\r\n    const clusters = useStore(state => [...state.clusters.values()]);\r\n\r\n    // Process edges based on aggregation setting and update store\r\n    const edges = useMemo(() => {\r\n      if (aggregateEdges) {\r\n        const aggregatedEdges = aggregateEdgesUtil(graph, labelType);\r\n        return aggregatedEdges;\r\n      } else {\r\n        return edgesStore;\r\n      }\r\n    }, [edgesStore, aggregateEdges, graph, labelType]);\r\n\r\n    // Update the store if edges were aggregated (moved to useEffect to avoid render cycle error)\r\n    useEffect(() => {\r\n      if (aggregateEdges && edgesStore.length !== edges.length) {\r\n        setEdges(edges);\r\n      }\r\n    }, [edges, edgesStore.length, setEdges, aggregateEdges]);\r\n\r\n    // Center the graph on the nodes\r\n    const { centerNodesById, fitNodesInViewById, isCentered } = useCenterGraph({\r\n      animated,\r\n      disabled,\r\n      layoutType\r\n    });\r\n\r\n    // Let's expose some helper methods\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        centerGraph: centerNodesById,\r\n        fitNodesInView: fitNodesInViewById,\r\n        graph,\r\n        renderScene: () => gl.render(scene, camera)\r\n      }),\r\n      [centerNodesById, fitNodesInViewById, graph, gl, scene, camera]\r\n    );\r\n\r\n    const onNodeDraggedHandler = useCallback(\r\n      (node: InternalGraphNode) => {\r\n        onNodeDragged?.(node);\r\n\r\n        // Update layout to recalculate the cluster positions when a node is dragged\r\n        if (clusterAttribute) {\r\n          updateLayout();\r\n        }\r\n      },\r\n      [clusterAttribute, onNodeDragged, updateLayout]\r\n    );\r\n\r\n    const nodeComponents = useMemo(\r\n      () =>\r\n        nodes.map(n => (\r\n          <Node\r\n            key={n?.id}\r\n            id={n?.id}\r\n            labelFontUrl={labelFontUrl}\r\n            draggable={draggable}\r\n            constrainDragging={constrainDragging}\r\n            disabled={disabled}\r\n            animated={animated}\r\n            contextMenu={contextMenu}\r\n            renderNode={renderNode}\r\n            onClick={onNodeClick}\r\n            onDoubleClick={onNodeDoubleClick}\r\n            onContextMenu={onNodeContextMenu}\r\n            onPointerOver={onNodePointerOver}\r\n            onPointerOut={onNodePointerOut}\r\n            onDragged={onNodeDraggedHandler}\r\n          />\r\n        )),\r\n      [\r\n        constrainDragging,\r\n        animated,\r\n        contextMenu,\r\n        disabled,\r\n        draggable,\r\n        labelFontUrl,\r\n        nodes,\r\n        onNodeClick,\r\n        onNodeContextMenu,\r\n        onNodeDoubleClick,\r\n        onNodeDraggedHandler,\r\n        onNodePointerOut,\r\n        onNodePointerOver,\r\n        renderNode\r\n      ]\r\n    );\r\n\r\n    const edgeComponents = useMemo(\r\n      () =>\r\n        animated ? (\r\n          edges.map(e => (\r\n            <Edge\r\n              key={e.id}\r\n              id={e.id}\r\n              disabled={disabled}\r\n              animated={animated}\r\n              labelFontUrl={labelFontUrl}\r\n              labelPlacement={edgeLabelPosition}\r\n              arrowPlacement={edgeArrowPosition}\r\n              interpolation={edgeInterpolation}\r\n              contextMenu={contextMenu}\r\n              onClick={onEdgeClick}\r\n              onContextMenu={onEdgeContextMenu}\r\n              onPointerOver={onEdgePointerOver}\r\n              onPointerOut={onEdgePointerOut}\r\n            />\r\n          ))\r\n        ) : (\r\n          <Edges\r\n            edges={edges}\r\n            disabled={disabled}\r\n            animated={animated}\r\n            labelFontUrl={labelFontUrl}\r\n            labelPlacement={edgeLabelPosition}\r\n            arrowPlacement={edgeArrowPosition}\r\n            interpolation={edgeInterpolation}\r\n            contextMenu={contextMenu}\r\n            onClick={onEdgeClick}\r\n            onContextMenu={onEdgeContextMenu}\r\n            onPointerOver={onEdgePointerOver}\r\n            onPointerOut={onEdgePointerOut}\r\n          />\r\n        ),\r\n      [\r\n        animated,\r\n        contextMenu,\r\n        disabled,\r\n        edgeArrowPosition,\r\n        edgeInterpolation,\r\n        edgeLabelPosition,\r\n        edges,\r\n        labelFontUrl,\r\n        onEdgeClick,\r\n        onEdgeContextMenu,\r\n        onEdgePointerOut,\r\n        onEdgePointerOver\r\n      ]\r\n    );\r\n\r\n    const clusterComponents = useMemo(\r\n      () =>\r\n        clusters.map(c => (\r\n          <Cluster\r\n            key={c.label}\r\n            animated={animated}\r\n            disabled={disabled}\r\n            draggable={draggable}\r\n            labelFontUrl={labelFontUrl}\r\n            onClick={onClusterClick}\r\n            onPointerOver={onClusterPointerOver}\r\n            onPointerOut={onClusterPointerOut}\r\n            onDragged={onClusterDragged}\r\n            onRender={onRenderCluster}\r\n            {...c}\r\n          />\r\n        )),\r\n      [\r\n        animated,\r\n        clusters,\r\n        disabled,\r\n        draggable,\r\n        labelFontUrl,\r\n        onClusterClick,\r\n        onClusterPointerOut,\r\n        onClusterPointerOver,\r\n        onClusterDragged,\r\n        onRenderCluster\r\n      ]\r\n    );\r\n\r\n    return (\r\n      isCentered && (\r\n        <Fragment>\r\n          {edgeComponents}\r\n          {nodeComponents}\r\n          {clusterComponents}\r\n        </Fragment>\r\n      )\r\n    );\r\n  }\r\n);\r\n","import type Graph from 'graphology';\r\n\r\nimport type { Theme } from '../themes';\r\n\r\nexport type PathSelectionTypes = 'direct' | 'out' | 'in' | 'all';\r\n\r\n/**\r\n * Given a graph and a list of node ids, return the adjacent nodes and edges.\r\n *\r\n * TODO: This method could be improved with the introduction of graphology\r\n */\r\nexport function getAdjacents(\r\n  graph: Graph,\r\n  nodeIds: string | string[],\r\n  type: PathSelectionTypes\r\n) {\r\n  nodeIds = Array.isArray(nodeIds) ? nodeIds : [nodeIds];\r\n\r\n  const nodes: string[] = [];\r\n  const edges: string[] = [];\r\n\r\n  for (const nodeId of nodeIds) {\r\n    const graphLinks = [\r\n      ...(graph.inEdgeEntries(nodeId) ?? []),\r\n      ...(graph.outEdgeEntries(nodeId) ?? [])\r\n    ];\r\n\r\n    if (!graphLinks) {\r\n      continue;\r\n    }\r\n\r\n    for (const link of graphLinks) {\r\n      const linkId = link.attributes.id;\r\n\r\n      if (type === 'in') {\r\n        if (link.target === nodeId && !edges.includes(linkId)) {\r\n          edges.push(linkId);\r\n        }\r\n      } else if (type === 'out') {\r\n        if (link.source === nodeId && !edges.includes(linkId)) {\r\n          edges.push(linkId);\r\n        }\r\n      } else {\r\n        if (!edges.includes(linkId)) {\r\n          edges.push(linkId);\r\n        }\r\n      }\r\n\r\n      if (type === 'out' || type === 'all') {\r\n        const toId = link.target;\r\n        if (!nodes.includes(toId as string)) {\r\n          nodes.push(toId as string);\r\n        }\r\n      }\r\n\r\n      if (type === 'in' || type === 'all') {\r\n        if (!nodes.includes(link.source)) {\r\n          nodes.push(link.source as string);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    nodes,\r\n    edges\r\n  };\r\n}\r\n\r\n/**\r\n * Set the vectors.\r\n */\r\nexport function prepareRay(event, vec, size) {\r\n  const { offsetX, offsetY } = event;\r\n  const { width, height } = size;\r\n  vec.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);\r\n}\r\n\r\n/**\r\n * Create a lasso element.\r\n */\r\nexport function createElement(theme: Theme) {\r\n  const element = document.createElement('div');\r\n  element.style.pointerEvents = 'none';\r\n  element.style.border = theme.lasso.border;\r\n  element.style.backgroundColor = theme.lasso.background;\r\n  element.style.position = 'fixed';\r\n  return element;\r\n}\r\n","import { useThree } from '@react-three/fiber';\r\nimport type { FC, PropsWithChildren } from 'react';\r\nimport React, { useCallback, useEffect, useRef } from 'react';\r\nimport type { Mesh, TubeGeometry } from 'three';\r\nimport { Scene, Vector2 } from 'three';\r\nimport { SelectionBox } from 'three-stdlib';\r\n\r\nimport { useCameraControls } from '../CameraControls/useCameraControls';\r\nimport { useStore } from '../store';\r\nimport { createElement, prepareRay } from './utils';\r\n\r\nexport type LassoType = 'none' | 'all' | 'node' | 'edge';\r\n\r\nexport type LassoProps = PropsWithChildren<{\r\n  /**\r\n   * Whether the lasso tool is disabled.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * The type of the lasso tool.\r\n   */\r\n  type?: LassoType;\r\n\r\n  /**\r\n   * A function that is called when the lasso tool is used to select nodes.\r\n   * The function receives an array of the ids of the selected nodes.\r\n   */\r\n  onLasso?: (selections: string[]) => void;\r\n\r\n  /**\r\n   * A function that is called when the lasso tool is released, ending the selection.\r\n   * The function receives an array of the ids of the selected nodes.\r\n   */\r\n  onLassoEnd?: (selections: string[]) => void;\r\n}>;\r\n\r\nexport const Lasso: FC<LassoProps> = ({\r\n  children,\r\n  type = 'none',\r\n  onLasso,\r\n  onLassoEnd,\r\n  disabled\r\n}) => {\r\n  const theme = useStore(state => state.theme);\r\n  const camera = useThree(state => state.camera);\r\n  const gl = useThree(state => state.gl);\r\n  const setEvents = useThree(state => state.setEvents);\r\n  const size = useThree(state => state.size);\r\n  const get = useThree(state => state.get);\r\n  const scene = useThree(state => state.scene);\r\n\r\n  const cameraControls = useCameraControls();\r\n\r\n  const actives = useStore(state => state.actives);\r\n  const setActives = useStore(state => state.setActives);\r\n  const edges = useStore(state => state.edges);\r\n  const edgeMeshes = useStore(state => state.edgeMeshes);\r\n\r\n  const selectionBoxRef = useRef<SelectionBox | null>(null);\r\n  const edgeMeshSelectionBoxRef = useRef<SelectionBox | null>(null);\r\n  const elementRef = useRef<HTMLDivElement>(createElement(theme));\r\n  const vectorsRef = useRef<[Vector2, Vector2, Vector2] | null>(null);\r\n  const isDownRef = useRef(false);\r\n  const oldRaycasterEnabledRef = useRef<boolean>(get().events.enabled);\r\n  const oldControlsEnabledRef = useRef<boolean>(\r\n    cameraControls.controls?.enabled\r\n  );\r\n\r\n  const onPointerMove = useCallback(\r\n    event => {\r\n      if (isDownRef.current) {\r\n        const [startPoint, pointTopLeft, pointBottomRight] = vectorsRef.current;\r\n\r\n        pointBottomRight.x = Math.max(startPoint.x, event.clientX);\r\n        pointBottomRight.y = Math.max(startPoint.y, event.clientY);\r\n        pointTopLeft.x = Math.min(startPoint.x, event.clientX);\r\n        pointTopLeft.y = Math.min(startPoint.y, event.clientY);\r\n        elementRef.current.style.left = `${pointTopLeft.x}px`;\r\n        elementRef.current.style.top = `${pointTopLeft.y}px`;\r\n        elementRef.current.style.width = `${\r\n          pointBottomRight.x - pointTopLeft.x\r\n        }px`;\r\n        elementRef.current.style.height = `${\r\n          pointBottomRight.y - pointTopLeft.y\r\n        }px`;\r\n\r\n        prepareRay(event, selectionBoxRef.current.endPoint, size);\r\n        prepareRay(event, edgeMeshSelectionBoxRef.current.endPoint, size);\r\n\r\n        const allSelected = [];\r\n        const edgesSelected = edgeMeshSelectionBoxRef.current\r\n          .select()\r\n          .sort(o => (o as any).uuid)\r\n          .filter(o => o.geometry?.userData?.type === type || type === 'all')\r\n          .map(\r\n            edge => edges[edgeMeshes.indexOf(edge as Mesh<TubeGeometry>)].id\r\n          );\r\n        allSelected.push(...edgesSelected);\r\n\r\n        const selected = selectionBoxRef.current\r\n          .select()\r\n          .sort(o => (o as any).uuid)\r\n          .filter(\r\n            o =>\r\n              o.isMesh &&\r\n              o.userData?.id &&\r\n              (o.userData?.type === type || type === 'all')\r\n          )\r\n          .map(o => o.userData.id);\r\n        allSelected.push(...selected);\r\n\r\n        // Note: This probably isn't the best solution but\r\n        // it prevents the render thrashing and causing flickering\r\n        requestAnimationFrame(() => {\r\n          setActives(allSelected);\r\n          onLasso?.(allSelected);\r\n        });\r\n\r\n        document.addEventListener('pointermove', onPointerMove, {\r\n          passive: true,\r\n          capture: true,\r\n          once: true\r\n        });\r\n      }\r\n    },\r\n    [size, edges, edgeMeshes, type, setActives, onLasso]\r\n  );\r\n\r\n  const onPointerUp = useCallback(() => {\r\n    if (isDownRef.current) {\r\n      setEvents({ enabled: oldRaycasterEnabledRef.current });\r\n      isDownRef.current = false;\r\n      elementRef.current.parentElement?.removeChild(elementRef.current);\r\n      cameraControls.controls.enabled = oldControlsEnabledRef.current;\r\n      onLassoEnd?.(actives);\r\n\r\n      document.removeEventListener('pointermove', onPointerMove);\r\n      document.removeEventListener('pointerup', onPointerUp);\r\n    }\r\n  }, [setEvents, cameraControls.controls, onLassoEnd, actives, onPointerMove]);\r\n\r\n  const onPointerDown = useCallback(\r\n    event => {\r\n      if (event.shiftKey) {\r\n        // Let's capture the old props to restore them later\r\n        oldRaycasterEnabledRef.current = get().events.enabled;\r\n        oldControlsEnabledRef.current = cameraControls.controls?.enabled;\r\n\r\n        // SelectionBox for all meshes\r\n        selectionBoxRef.current = new SelectionBox(camera, scene);\r\n\r\n        // SelectionBox for all Edge meshes (since they are combined into one geometry for rendering)\r\n        const edgeScene = new Scene();\r\n        if (edgeMeshes.length) {\r\n          edgeScene.add(...edgeMeshes);\r\n        }\r\n        edgeMeshSelectionBoxRef.current = new SelectionBox(camera, edgeScene);\r\n\r\n        vectorsRef.current = [\r\n          // start point\r\n          new Vector2(),\r\n          // point top left\r\n          new Vector2(),\r\n          // point bottom right\r\n          new Vector2()\r\n        ];\r\n\r\n        const [startPoint] = vectorsRef.current;\r\n\r\n        cameraControls.controls.enabled = false;\r\n        setEvents({ enabled: false });\r\n        isDownRef.current = true;\r\n        gl.domElement.parentElement?.appendChild(elementRef.current);\r\n        elementRef.current.style.left = `${event.clientX}px`;\r\n        elementRef.current.style.top = `${event.clientY}px`;\r\n        elementRef.current.style.width = '0px';\r\n        elementRef.current.style.height = '0px';\r\n        startPoint.x = event.clientX;\r\n        startPoint.y = event.clientY;\r\n\r\n        prepareRay(event, selectionBoxRef.current.startPoint, size);\r\n        prepareRay(event, edgeMeshSelectionBoxRef.current.startPoint, size);\r\n\r\n        document.addEventListener('pointermove', onPointerMove, {\r\n          passive: true,\r\n          capture: true,\r\n          once: true\r\n        });\r\n        document.addEventListener('pointerup', onPointerUp, { passive: true });\r\n      }\r\n    },\r\n    [\r\n      camera,\r\n      cameraControls.controls,\r\n      edgeMeshes,\r\n      get,\r\n      gl.domElement.parentElement,\r\n      onPointerMove,\r\n      onPointerUp,\r\n      scene,\r\n      setEvents,\r\n      size\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (disabled || type === 'none') {\r\n      return;\r\n    }\r\n\r\n    if (typeof window !== 'undefined') {\r\n      document.addEventListener('pointerdown', onPointerDown, {\r\n        passive: true\r\n      });\r\n      document.addEventListener('pointermove', onPointerMove, {\r\n        passive: true\r\n      });\r\n      document.addEventListener('pointerup', onPointerUp, { passive: true });\r\n    }\r\n\r\n    return () => {\r\n      if (typeof window !== 'undefined') {\r\n        document.removeEventListener('pointerdown', onPointerDown);\r\n        document.removeEventListener('pointermove', onPointerMove);\r\n        document.removeEventListener('pointerup', onPointerUp);\r\n      }\r\n    };\r\n  }, [type, disabled, onPointerDown, onPointerMove, onPointerUp]);\r\n\r\n  return <group>{children}</group>;\r\n};\r\n","import type { Theme } from './theme';\r\n\r\nexport const darkTheme: Theme = {\r\n  canvas: {\r\n    background: '#1E2026'\r\n  },\r\n  node: {\r\n    fill: '#7A8C9E',\r\n    activeFill: '#1DE9AC',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.1,\r\n    label: {\r\n      color: '#202020',\r\n      activeColor: '#000000',\r\n      fontSize: 6,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#fafafa',\r\n      borderRadius: 2\r\n    },\r\n    subLabel: {\r\n      stroke: '#1E2026',\r\n      color: '#ACBAC7',\r\n      activeColor: '#1DE9AC'\r\n    }\r\n  },\r\n  lasso: {\r\n    border: '1px solid #55aaff',\r\n    background: 'rgba(75, 160, 255, 0.1)'\r\n  },\r\n  ring: {\r\n    fill: '#54616D',\r\n    activeFill: '#1DE9AC'\r\n  },\r\n  edge: {\r\n    fill: '#ffffff',\r\n    activeFill: '#1DE9AC',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.1,\r\n    label: {\r\n      color: '#202020',\r\n      activeColor: '#000000',\r\n      fontSize: 4,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#fafafa',\r\n      borderRadius: 2\r\n    }\r\n  },\r\n  arrow: {\r\n    fill: '#474B56',\r\n    activeFill: '#1DE9AC'\r\n  },\r\n  cluster: {\r\n    stroke: '#474B56',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.1,\r\n    label: {\r\n      color: '#202020',\r\n      activeColor: '#000000',\r\n      fontSize: 4,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#fafafa',\r\n      borderRadius: 2\r\n    }\r\n  }\r\n};\r\n","import type { Theme } from './theme';\r\n\r\nexport const lightTheme: Theme = {\r\n  canvas: {\r\n    background: '#fff'\r\n  },\r\n  node: {\r\n    fill: '#7CA0AB',\r\n    activeFill: '#1DE9AC',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.2,\r\n    label: {\r\n      color: '#2A6475',\r\n      // stroke: '#fff',\r\n      activeColor: '#1DE9AC',\r\n      fontSize: 6,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#1E2026',\r\n      borderRadius: 2\r\n    },\r\n    subLabel: {\r\n      color: '#ddd',\r\n      stroke: 'transparent',\r\n      activeColor: '#1DE9AC'\r\n    }\r\n  },\r\n  lasso: {\r\n    border: '1px solid #55aaff',\r\n    background: 'rgba(75, 160, 255, 0.1)'\r\n  },\r\n  ring: {\r\n    fill: '#D8E6EA',\r\n    activeFill: '#1DE9AC'\r\n  },\r\n  edge: {\r\n    fill: '#474B56',\r\n    activeFill: '#1DE9AC',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.1,\r\n    label: {\r\n      // stroke: '#fff',\r\n      color: '#2A6475',\r\n      activeColor: '#1DE9AC',\r\n      fontSize: 6,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#1E2026',\r\n      borderRadius: 2\r\n    }\r\n  },\r\n  arrow: {\r\n    fill: '#D8E6EA',\r\n    activeFill: '#1DE9AC'\r\n  },\r\n  cluster: {\r\n    stroke: '#D8E6EA',\r\n    opacity: 1,\r\n    selectedOpacity: 1,\r\n    inactiveOpacity: 0.1,\r\n    label: {\r\n      stroke: '#1E2026',\r\n      color: '#ACBAC7',\r\n      activeColor: '#1DE9AC',\r\n      fontSize: 6,\r\n      maxWidth: 100,\r\n      ellipsis: 100,\r\n      backgroundColor: '#1E2026',\r\n      borderRadius: 2\r\n    }\r\n  }\r\n};\r\n","import { Canvas } from '@react-three/fiber';\r\nimport type ThreeCameraControls from 'camera-controls';\r\nimport type Graph from 'graphology';\r\nimport type { ReactNode, Ref } from 'react';\r\nimport React, {\r\n  forwardRef,\r\n  Suspense,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useMemo,\r\n  useRef\r\n} from 'react';\r\n\r\nimport type { CameraControlsRef, CameraMode } from '../CameraControls';\r\nimport { CameraControls } from '../CameraControls';\r\nimport type { GraphSceneProps, GraphSceneRef } from '../GraphScene';\r\nimport { GraphScene } from '../GraphScene';\r\nimport type { LassoType } from '../selection/Lasso';\r\nimport { Lasso } from '../selection/Lasso';\r\nimport { createStore, Provider } from '../store';\r\nimport type { Theme } from '../themes';\r\nimport { lightTheme } from '../themes';\r\nimport css from './GraphCanvas.module.css';\r\n\r\nexport interface GraphCanvasProps extends Omit<GraphSceneProps, 'theme'> {\r\n  /**\r\n   * Theme to use for the graph.\r\n   */\r\n  theme?: Theme;\r\n\r\n  /**\r\n   * Type of camera interaction.\r\n   */\r\n  cameraMode?: CameraMode;\r\n\r\n  /**\r\n   * The maximum distance for the camera. Default is 50000.\r\n   */\r\n  maxDistance?: number;\r\n\r\n  /**\r\n   * The minimum distance for the camera. Default is 1000.\r\n   */\r\n  minDistance?: number;\r\n\r\n  /**\r\n   * The minimum zoom level for the camera. Default is 1.\r\n   */\r\n  minZoom?: number;\r\n\r\n  /**\r\n   * The maximum zoom level for the camera. Default is 100.\r\n   */\r\n  maxZoom?: number;\r\n\r\n  /**\r\n   * The type of lasso selection.\r\n   */\r\n  lassoType?: LassoType;\r\n\r\n  /**\r\n   * Children to render in the canvas. Useful for things like lights.\r\n   */\r\n  children?: ReactNode;\r\n\r\n  /**\r\n   * Ability to extend Cavas gl options. For example { preserveDrawingBuffer: true }\r\n   */\r\n  glOptions?: object;\r\n\r\n  /**\r\n   * When the canvas had a lasso selection.\r\n   */\r\n  onLasso?: (selections: string[]) => void;\r\n\r\n  /**\r\n   * When the canvas had a lasso selection end.\r\n   */\r\n  onLassoEnd?: (selections: string[]) => void;\r\n\r\n  /**\r\n   * When the canvas was clicked but didn't hit a node/edge.\r\n   */\r\n  onCanvasClick?: (event: MouseEvent) => void;\r\n\r\n  /**\r\n   * Whether to aggregate edges with the same source and target.\r\n   */\r\n  aggregateEdges?: boolean;\r\n}\r\n\r\nexport type GraphCanvasRef = Omit<GraphSceneRef, 'graph' | 'renderScene'> &\r\n  Omit<CameraControlsRef, 'controls'> & {\r\n    /**\r\n     * Get the graph object.\r\n     */\r\n    getGraph: () => Graph;\r\n\r\n    /**\r\n     * Get the camera controls.\r\n     */\r\n    getControls: () => ThreeCameraControls;\r\n\r\n    /**\r\n     * Export the canvas as a data URL.\r\n     */\r\n    exportCanvas: () => string;\r\n  };\r\n\r\nconst GL_DEFAULTS = {\r\n  alpha: true,\r\n  antialias: true\r\n};\r\n\r\n// TODO: Fix type\r\nconst CAMERA_DEFAULTS: any = {\r\n  position: [0, 0, 1000],\r\n  near: 5,\r\n  far: 50000,\r\n  fov: 10\r\n};\r\n\r\nexport const GraphCanvas = forwardRef<GraphCanvasRef, GraphCanvasProps>(\r\n  (\r\n    {\r\n      cameraMode = 'pan',\r\n      layoutType = 'forceDirected2d',\r\n      sizingType = 'default',\r\n      labelType = 'auto',\r\n      theme = lightTheme,\r\n      animated = true,\r\n      defaultNodeSize = 7,\r\n      minNodeSize = 5,\r\n      maxNodeSize = 15,\r\n      lassoType = 'none',\r\n      glOptions = {},\r\n      edges,\r\n      children,\r\n      nodes,\r\n      minDistance,\r\n      maxDistance,\r\n      minZoom,\r\n      maxZoom,\r\n      onCanvasClick,\r\n      disabled,\r\n      onLasso,\r\n      onLassoEnd,\r\n      aggregateEdges,\r\n      ...rest\r\n    },\r\n    ref: Ref<GraphCanvasRef>\r\n  ) => {\r\n    const rendererRef = useRef<GraphSceneRef | null>(null);\r\n    const controlsRef = useRef<CameraControlsRef | null>(null);\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      centerGraph: (nodeIds, opts) =>\r\n        rendererRef.current?.centerGraph(nodeIds, opts),\r\n      fitNodesInView: (nodeIds, opts) =>\r\n        rendererRef.current?.fitNodesInView(nodeIds, opts),\r\n      zoomIn: () => {\r\n        const controls = controlsRef.current?.controls;\r\n        if (!controls) return;\r\n\r\n        const currentDistance = controls.distance;\r\n        const currentZoom = controls.camera.zoom;\r\n\r\n        // Calculate what the new zoom would be has to match CameraControls logic\r\n        const newZoom = currentZoom + currentZoom / 2;\r\n        const newEffectiveDistance = currentDistance / newZoom;\r\n\r\n        // Check if zooming in would violate minDistance constraint\r\n        if (!minDistance || newEffectiveDistance >= minDistance) {\r\n          controlsRef.current?.zoomIn();\r\n        }\r\n      },\r\n      zoomOut: () => {\r\n        const controls = controlsRef.current?.controls;\r\n        if (!controls) return;\r\n\r\n        const currentDistance = controls.distance;\r\n        const currentZoom = controls.camera.zoom;\r\n\r\n        // Calculate what the new zoom would be (matches CameraControls logic)\r\n        const newZoom = currentZoom - currentZoom / 2;\r\n        const newEffectiveDistance = currentDistance / newZoom;\r\n\r\n        // Check if zooming out would violate maxDistance constraint\r\n        if (!maxDistance || newEffectiveDistance <= maxDistance) {\r\n          controlsRef.current?.zoomOut();\r\n        }\r\n      },\r\n      dollyIn: distance => controlsRef.current?.dollyIn(distance),\r\n      dollyOut: distance => controlsRef.current?.dollyOut(distance),\r\n      panLeft: () => controlsRef.current?.panLeft(),\r\n      panRight: () => controlsRef.current?.panRight(),\r\n      panDown: () => controlsRef.current?.panDown(),\r\n      panUp: () => controlsRef.current?.panUp(),\r\n      resetControls: (animated?: boolean) =>\r\n        controlsRef.current?.resetControls(animated),\r\n      getControls: () => controlsRef.current?.controls,\r\n      getGraph: () => rendererRef.current?.graph,\r\n      exportCanvas: () => {\r\n        rendererRef.current.renderScene();\r\n        return canvasRef.current.toDataURL();\r\n      },\r\n      freeze: () => controlsRef.current?.freeze(),\r\n      unFreeze: () => controlsRef.current?.unFreeze()\r\n    }));\r\n\r\n    // Defaults to pass to the store\r\n    const { selections, actives, collapsedNodeIds } = rest;\r\n\r\n    // It's pretty hard to get good animation performance with large n of edges/nodes\r\n    const finalAnimated = edges.length + nodes.length > 400 ? false : animated;\r\n\r\n    const gl = useMemo(() => ({ ...glOptions, ...GL_DEFAULTS }), [glOptions]);\r\n    // zustand/context migration (https://github.com/pmndrs/zustand/discussions/1180)\r\n    const store = useRef(\r\n      createStore({\r\n        selections,\r\n        actives,\r\n        theme,\r\n        collapsedNodeIds\r\n      })\r\n    ).current;\r\n\r\n    // Update store theme when theme prop changes\r\n    useEffect(() => {\r\n      store.getState().setTheme(theme);\r\n    }, [theme, store]);\r\n\r\n    // NOTE: The legacy/linear/flat flags are for color issues\r\n    // Reference: https://github.com/protectwise/troika/discussions/213#discussioncomment-3086666\r\n    return (\r\n      <div className={css.canvas}>\r\n        <Canvas\r\n          orthographic={cameraMode === 'orthographic'}\r\n          legacy\r\n          linear\r\n          ref={canvasRef}\r\n          flat\r\n          gl={gl}\r\n          camera={CAMERA_DEFAULTS}\r\n          onPointerMissed={onCanvasClick}\r\n        >\r\n          <Provider store={store}>\r\n            {theme.canvas?.background && (\r\n              <color attach=\"background\" args={[theme.canvas.background]} />\r\n            )}\r\n            <ambientLight intensity={1} />\r\n            {children}\r\n            {theme.canvas?.fog && (\r\n              <fog attach=\"fog\" args={[theme.canvas.fog, 4000, 9000]} />\r\n            )}\r\n            <CameraControls\r\n              mode={cameraMode}\r\n              ref={controlsRef}\r\n              disabled={disabled}\r\n              minDistance={minDistance}\r\n              maxDistance={maxDistance}\r\n              minZoom={minZoom}\r\n              maxZoom={maxZoom}\r\n              animated={animated}\r\n            >\r\n              <Lasso\r\n                disabled={disabled}\r\n                type={lassoType}\r\n                onLasso={onLasso}\r\n                onLassoEnd={onLassoEnd}\r\n              >\r\n                <Suspense>\r\n                  <GraphScene\r\n                    ref={rendererRef as any}\r\n                    disabled={disabled}\r\n                    animated={finalAnimated}\r\n                    edges={edges}\r\n                    nodes={nodes}\r\n                    layoutType={layoutType}\r\n                    sizingType={sizingType}\r\n                    labelType={labelType}\r\n                    defaultNodeSize={defaultNodeSize}\r\n                    minNodeSize={minNodeSize}\r\n                    maxNodeSize={maxNodeSize}\r\n                    aggregateEdges={aggregateEdges}\r\n                    {...rest}\r\n                  />\r\n                </Suspense>\r\n              </Lasso>\r\n            </CameraControls>\r\n          </Provider>\r\n        </Canvas>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n","import classNames from 'classnames';\r\nimport type { FC, ReactNode } from 'react';\r\nimport React from 'react';\r\n\r\nimport css from './RadialSlice.module.css';\r\n\r\nexport interface MenuItem {\r\n  /**\r\n   * Label to display on the menu item.\r\n   */\r\n  label: string;\r\n\r\n  /**\r\n   * CSS Classname to apply to the slice.\r\n   */\r\n  className?: string;\r\n\r\n  /**\r\n   * Optional icon to display on the menu item.\r\n   */\r\n  icon?: ReactNode;\r\n\r\n  /**\r\n   * Optional callback to detemine if the menu item is active.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * Optional callback to handle when the menu item is clicked.\r\n   */\r\n  onClick?: (event: React.MouseEvent<HTMLDivElement>) => void;\r\n}\r\n\r\ninterface RadialSliceProps extends MenuItem {\r\n  /**\r\n   * The starting angle of the radial slice, in degrees.\r\n   */\r\n  startAngle: number;\r\n\r\n  /**\r\n   * The ending angle of the radial slice, in degrees.\r\n   */\r\n  endAngle: number;\r\n\r\n  /**\r\n   * The skew of the radial slice.\r\n   */\r\n  skew: number;\r\n\r\n  /**\r\n   * Whether the radial slice is polar (true) or not (false).\r\n   */\r\n  polar: boolean;\r\n\r\n  /**\r\n   * The central angle of the radial slice, in degrees.\r\n   */\r\n  centralAngle: number;\r\n\r\n  /**\r\n   * The radius of the radial slice.\r\n   */\r\n  radius: number;\r\n\r\n  /**\r\n   * The inner radius of the radial slice.\r\n   */\r\n  innerRadius: number;\r\n}\r\n\r\nexport const RadialSlice: FC<RadialSliceProps> = ({\r\n  label,\r\n  centralAngle,\r\n  startAngle,\r\n  endAngle,\r\n  polar,\r\n  radius,\r\n  className,\r\n  icon,\r\n  innerRadius,\r\n  skew,\r\n  disabled,\r\n  onClick\r\n}) => (\r\n  <div\r\n    role=\"menuitem\"\r\n    className={classNames(css.container, className, {\r\n      [css.disabled]: disabled\r\n    })}\r\n    style={{\r\n      width: centralAngle > 90 ? '100%' : '50%',\r\n      height: centralAngle > 90 ? '100%' : '50%',\r\n      bottom: centralAngle > 90 ? '50%' : 'initial',\r\n      right: centralAngle > 90 ? '50%' : 'initial',\r\n      transform: `rotate(${startAngle + endAngle}deg) skew(${skew}deg)`\r\n    }}\r\n    onClick={event => {\r\n      if (!disabled) {\r\n        onClick(event);\r\n      }\r\n    }}\r\n  >\r\n    <div\r\n      className={css.contentContainer}\r\n      style={{\r\n        transform: `skew(${-skew}deg) rotate(${\r\n          (polar ? 90 : centralAngle) / 2 - 90\r\n        }deg)`\r\n      }}\r\n    >\r\n      <div\r\n        className={css.contentInner}\r\n        style={{\r\n          top: `calc((((${\r\n            centralAngle > 90 ? '50% + ' : ''\r\n          }${radius}px) - ${innerRadius}px) / 2) - 4em)`\r\n        }}\r\n      >\r\n        <div\r\n          className={css.content}\r\n          style={{\r\n            transform: `rotate(${-endAngle}deg)`\r\n          }}\r\n          title={label}\r\n        >\r\n          {icon}\r\n          {label}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n);\r\n","import type { MenuItem } from './RadialSlice';\r\n\r\nexport function calculateRadius(items: MenuItem[], startOffsetAngle: number) {\r\n  const centralAngle = 360 / items.length || 360;\r\n  const polar = centralAngle % 180 === 0;\r\n  const deltaAngle = 90 - centralAngle;\r\n  const startAngle = polar\r\n    ? 45\r\n    : startOffsetAngle + deltaAngle + centralAngle / 2;\r\n\r\n  return { centralAngle, polar, startAngle, deltaAngle };\r\n}\r\n","import classNames from 'classnames';\r\nimport type { FC } from 'react';\r\nimport React, { useLayoutEffect, useMemo, useRef } from 'react';\r\n\r\nimport css from './RadialMenu.module.css';\r\nimport type { MenuItem } from './RadialSlice';\r\nimport { RadialSlice } from './RadialSlice';\r\nimport { calculateRadius } from './utils';\r\n\r\ninterface RadialMenuProps {\r\n  /**\r\n   * An array of menu items to be displayed in the radial menu.\r\n   */\r\n  items: MenuItem[];\r\n\r\n  /**\r\n   * The radius of the radial menu.\r\n   */\r\n  radius?: number;\r\n\r\n  /**\r\n   * The inner radius of the radial menu.\r\n   */\r\n  innerRadius?: number;\r\n\r\n  /**\r\n   * The starting offset angle for the first menu item.\r\n   */\r\n  startOffsetAngle?: number;\r\n\r\n  /**\r\n   * The CSS class name for the radial menu.\r\n   */\r\n  className?: string;\r\n\r\n  /**\r\n   * A function that is called when the radial menu is closed.\r\n   * The function receives the mouse event that triggered the closure.\r\n   */\r\n  onClose?: (event: React.MouseEvent<HTMLDivElement>) => void;\r\n}\r\n\r\nexport const RadialMenu: FC<RadialMenuProps> = ({\r\n  items,\r\n  radius = 175,\r\n  className,\r\n  innerRadius = 25,\r\n  startOffsetAngle = 0,\r\n  onClose\r\n}) => {\r\n  const { centralAngle, polar, startAngle, deltaAngle } = useMemo(\r\n    () => calculateRadius(items, startOffsetAngle),\r\n    [items, startOffsetAngle]\r\n  );\r\n  const timeout = useRef<any | null>(null);\r\n\r\n  useLayoutEffect(() => {\r\n    const timer = timeout.current;\r\n    return () => clearTimeout(timer);\r\n  }, []);\r\n\r\n  if (items.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      role=\"menu\"\r\n      className={classNames(css.container, className)}\r\n      onPointerEnter={() => clearTimeout(timeout.current)}\r\n      onPointerLeave={event => {\r\n        clearTimeout(timeout.current);\r\n        timeout.current = setTimeout(() => onClose?.(event), 500);\r\n      }}\r\n    >\r\n      {items.map((slice, index) => (\r\n        <RadialSlice\r\n          key={index}\r\n          {...slice}\r\n          radius={radius}\r\n          innerRadius={innerRadius}\r\n          startAngle={startAngle}\r\n          endAngle={centralAngle * index}\r\n          skew={polar ? 0 : deltaAngle}\r\n          polar={polar}\r\n          centralAngle={centralAngle}\r\n          onClick={event => {\r\n            slice?.onClick(event);\r\n            onClose?.(event);\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n","import type { RefObject } from 'react';\r\nimport { useCallback, useEffect, useMemo, useState } from 'react';\r\n\r\nimport type { GraphCanvasRef } from '../GraphCanvas';\r\nimport type { GraphEdge, GraphNode } from '../types';\r\nimport { isNotEditableElement } from '../utils/dom';\r\nimport { findPath } from '../utils/paths';\r\nimport type { PathSelectionTypes } from './utils';\r\nimport { getAdjacents } from './utils';\r\n\r\nexport type HotkeyTypes = 'selectAll' | 'deselect' | 'delete';\r\n\r\nexport type SelectionTypes = 'single' | 'multi' | 'multiModifier';\r\n\r\nexport interface SelectionProps {\r\n  /**\r\n   * Required ref for the graph.\r\n   */\r\n  ref: RefObject<GraphCanvasRef | null>;\r\n\r\n  /**\r\n   * Current selections.\r\n   *\r\n   * Contains both nodes and edges ids.\r\n   */\r\n  selections?: string[];\r\n\r\n  /**\r\n   * Default active selections.\r\n   */\r\n  actives?: string[];\r\n\r\n  /**\r\n   * Node datas.\r\n   */\r\n  nodes?: GraphNode[];\r\n\r\n  /**\r\n   * Edge datas.\r\n   */\r\n  edges?: GraphEdge[];\r\n\r\n  /**\r\n   * Disabled or not.\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * Whether to focus on select or not.\r\n   */\r\n  focusOnSelect?: boolean | 'singleOnly';\r\n\r\n  /**\r\n   * Type of selection.\r\n   */\r\n  type?: SelectionTypes;\r\n\r\n  /**\r\n   * Type of selection.\r\n   */\r\n  pathSelectionType?: PathSelectionTypes;\r\n\r\n  /**\r\n   * Whether it should active on hover or not.\r\n   */\r\n  pathHoverType?: PathSelectionTypes;\r\n\r\n  /**\r\n   * On selection change.\r\n   */\r\n  onSelection?: (selectionIds: string[]) => void;\r\n}\r\n\r\nexport interface SelectionResult {\r\n  /**\r\n   * Selections id array (of nodes and edges).\r\n   */\r\n  selections: string[];\r\n\r\n  /**\r\n   * The nodes/edges around the selections to highlight.\r\n   */\r\n  actives: string[];\r\n\r\n  /**\r\n   * Clear selections method.\r\n   */\r\n  clearSelections: (value?: string[]) => void;\r\n\r\n  /**\r\n   * A selection method.\r\n   */\r\n  addSelection: (value: string) => void;\r\n\r\n  /**\r\n   * Get the paths between two nodes.\r\n   */\r\n  selectNodePaths: (source: string, target: string) => void;\r\n\r\n  /**\r\n   * Remove selection method.\r\n   */\r\n  removeSelection: (value: string) => void;\r\n\r\n  /**\r\n   * Toggle existing selection on/off method.\r\n   */\r\n  toggleSelection: (value: string) => void;\r\n\r\n  /**\r\n   * Set internal selections.\r\n   */\r\n  setSelections: (value: string[]) => void;\r\n\r\n  /**\r\n   * On click event pass through.\r\n   */\r\n  onNodeClick?: (data: GraphNode) => void;\r\n\r\n  /**\r\n   * On canvas click event pass through.\r\n   */\r\n  onCanvasClick?: (event: MouseEvent) => void;\r\n\r\n  /**\r\n   * When the lasso happened.\r\n   */\r\n  onLasso?: (selections: string[]) => void;\r\n\r\n  /**\r\n   * When the lasso ended.\r\n   */\r\n  onLassoEnd?: (selections: string[]) => void;\r\n\r\n  /**\r\n   * When node got a pointer over.\r\n   */\r\n  onNodePointerOver?: (node: GraphNode) => void;\r\n\r\n  /**\r\n   * When node lost pointer over.\r\n   */\r\n  onNodePointerOut?: (node: GraphNode) => void;\r\n}\r\n\r\nexport const useSelection = ({\r\n  selections = [],\r\n  nodes = [],\r\n  actives = [],\r\n  focusOnSelect = true,\r\n  type = 'single',\r\n  pathHoverType = 'out',\r\n  pathSelectionType = 'direct',\r\n  ref,\r\n  disabled,\r\n  onSelection\r\n}: SelectionProps): SelectionResult => {\r\n  const [internalHovers, setInternalHovers] = useState<string[]>([]);\r\n  const [internalActives, setInternalActives] = useState<string[]>(actives);\r\n  const [internalSelections, setInternalSelections] =\r\n    useState<string[]>(selections);\r\n  const [metaKeyDown, setMetaKeyDown] = useState<boolean>(false);\r\n  const isMulti = type === 'multi' || type === 'multiModifier';\r\n\r\n  const addSelection = useCallback(\r\n    (items: string | string[]) => {\r\n      if (!disabled && items) {\r\n        items = Array.isArray(items) ? items : [items];\r\n\r\n        const filtered = items.filter(\r\n          item => !internalSelections.includes(item)\r\n        );\r\n        if (filtered.length) {\r\n          const next = [...internalSelections, ...filtered];\r\n          onSelection?.(next);\r\n          setInternalSelections(next);\r\n        }\r\n      }\r\n    },\r\n    [disabled, internalSelections, onSelection]\r\n  );\r\n\r\n  const removeSelection = useCallback(\r\n    (items: string | string[]) => {\r\n      if (!disabled && items) {\r\n        items = Array.isArray(items) ? items : [items];\r\n\r\n        const next = internalSelections.filter(i => !items.includes(i));\r\n        onSelection?.(next);\r\n        setInternalSelections(next);\r\n      }\r\n    },\r\n    [disabled, internalSelections, onSelection]\r\n  );\r\n\r\n  const clearSelections = useCallback(\r\n    (next: string | string[] = []) => {\r\n      if (!disabled) {\r\n        next = Array.isArray(next) ? next : [next];\r\n        setInternalActives([]);\r\n        setInternalSelections(next);\r\n        onSelection?.(next);\r\n      }\r\n    },\r\n    [disabled, onSelection]\r\n  );\r\n\r\n  const toggleSelection = useCallback(\r\n    (item: string) => {\r\n      const has = internalSelections.includes(item);\r\n      if (has) {\r\n        removeSelection(item);\r\n      } else {\r\n        if (!isMulti) {\r\n          clearSelections(item);\r\n        } else {\r\n          addSelection(item);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      addSelection,\r\n      clearSelections,\r\n      internalSelections,\r\n      isMulti,\r\n      removeSelection\r\n    ]\r\n  );\r\n\r\n  const onNodeClick = useCallback(\r\n    (data: GraphNode) => {\r\n      if (isMulti) {\r\n        if (type === 'multiModifier') {\r\n          if (metaKeyDown) {\r\n            addSelection(data.id);\r\n          } else {\r\n            clearSelections(data.id);\r\n          }\r\n        } else {\r\n          addSelection(data.id);\r\n        }\r\n      } else {\r\n        clearSelections(data.id);\r\n      }\r\n\r\n      if (\r\n        focusOnSelect === true ||\r\n        (focusOnSelect === 'singleOnly' && !metaKeyDown)\r\n      ) {\r\n        if (!ref.current) {\r\n          throw new Error('No ref found for the graph canvas.');\r\n        }\r\n\r\n        const graph = ref.current.getGraph();\r\n        const { nodes: adjacents } = getAdjacents(\r\n          graph,\r\n          [data.id],\r\n          pathSelectionType\r\n        );\r\n\r\n        ref.current.fitNodesInView([data.id, ...adjacents], {\r\n          fitOnlyIfNodesNotInView: true\r\n        });\r\n      }\r\n    },\r\n    [\r\n      addSelection,\r\n      clearSelections,\r\n      focusOnSelect,\r\n      isMulti,\r\n      metaKeyDown,\r\n      pathSelectionType,\r\n      ref,\r\n      type\r\n    ]\r\n  );\r\n\r\n  const selectNodePaths = useCallback(\r\n    (source: string, target: string) => {\r\n      const graph = ref.current.getGraph();\r\n      if (!graph) {\r\n        throw new Error('Graph is not initialized');\r\n      }\r\n\r\n      const path = findPath(graph, source, target);\r\n      clearSelections([source, target]);\r\n\r\n      const result = [];\r\n      for (let i = 0; i < path.length - 1; i++) {\r\n        const from = path[i];\r\n        const to = path[i + 1];\r\n        const edge = graph.getEdgeAttributes(from, to);\r\n        if (edge) {\r\n          result.push(edge.id);\r\n        }\r\n      }\r\n\r\n      setInternalActives([...path.map(p => p as string), ...result]);\r\n    },\r\n    [clearSelections, ref]\r\n  );\r\n\r\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\r\n    const element = event.target as HTMLElement;\r\n    const isSafe = isNotEditableElement(element);\r\n    const isMeta = event.metaKey || event.ctrlKey;\r\n\r\n    if (isSafe && isMeta) {\r\n      setMetaKeyDown(true);\r\n    }\r\n  }, []);\r\n\r\n  const onKeyUp = useCallback((event: KeyboardEvent) => {\r\n    const element = event.target as HTMLElement;\r\n    const isSafe = isNotEditableElement(element);\r\n    const isMeta = ['Meta', 'Control'].includes(event.key);\r\n\r\n    if (isSafe && isMeta) {\r\n      setMetaKeyDown(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined') {\r\n      window.addEventListener('keydown', onKeyDown);\r\n      window.addEventListener('keyup', onKeyUp);\r\n    }\r\n\r\n    return () => {\r\n      if (typeof window !== 'undefined') {\r\n        window.removeEventListener('keydown', onKeyDown);\r\n        window.removeEventListener('keyup', onKeyUp);\r\n      }\r\n    };\r\n  }, [onKeyDown, onKeyUp]);\r\n\r\n  const onCanvasClick = useCallback(\r\n    (event: MouseEvent) => {\r\n      if (\r\n        event.button !== 2 &&\r\n        (internalSelections.length || internalActives.length)\r\n      ) {\r\n        clearSelections();\r\n        setMetaKeyDown(false);\r\n\r\n        // Only re-center if we have a single selection\r\n        if (focusOnSelect && internalSelections.length === 1) {\r\n          if (!ref.current) {\r\n            throw new Error('No ref found for the graph canvas.');\r\n          }\r\n\r\n          ref.current.fitNodesInView([], { fitOnlyIfNodesNotInView: true });\r\n        }\r\n      }\r\n    },\r\n    [\r\n      clearSelections,\r\n      focusOnSelect,\r\n      internalActives.length,\r\n      internalSelections.length,\r\n      ref\r\n    ]\r\n  );\r\n\r\n  const onLasso = useCallback((selections: string[]) => {\r\n    setInternalActives(selections);\r\n  }, []);\r\n\r\n  const onLassoEnd = useCallback(\r\n    (selections: string[]) => {\r\n      clearSelections(selections);\r\n    },\r\n    [clearSelections]\r\n  );\r\n\r\n  const onNodePointerOver = useCallback(\r\n    (data: GraphNode) => {\r\n      if (pathHoverType) {\r\n        const graph = ref.current.getGraph();\r\n        if (!graph) {\r\n          throw new Error('No ref found for the graph canvas.');\r\n        }\r\n\r\n        const { nodes, edges } = getAdjacents(graph, [data.id], pathHoverType);\r\n        setInternalHovers([...nodes, ...edges]);\r\n      }\r\n    },\r\n    [pathHoverType, ref]\r\n  );\r\n\r\n  const onNodePointerOut = useCallback(() => {\r\n    if (pathHoverType) {\r\n      setInternalHovers([]);\r\n    }\r\n  }, [pathHoverType]);\r\n\r\n  useEffect(() => {\r\n    if (pathSelectionType !== 'direct' && internalSelections.length > 0) {\r\n      const graph = ref.current?.getGraph();\r\n      if (graph) {\r\n        const { nodes, edges } = getAdjacents(\r\n          graph,\r\n          internalSelections,\r\n          pathSelectionType\r\n        );\r\n        setInternalActives([...nodes, ...edges]);\r\n      }\r\n    }\r\n  }, [internalSelections, pathSelectionType, ref]);\r\n\r\n  const joinedActives = useMemo(\r\n    () => [...internalActives, ...internalHovers],\r\n    [internalActives, internalHovers]\r\n  );\r\n\r\n  return {\r\n    actives: joinedActives,\r\n    onNodeClick,\r\n    onNodePointerOver,\r\n    onNodePointerOut,\r\n    onLasso,\r\n    onLassoEnd,\r\n    selectNodePaths,\r\n    onCanvasClick,\r\n    selections: internalSelections,\r\n    clearSelections,\r\n    addSelection,\r\n    removeSelection,\r\n    toggleSelection,\r\n    setSelections: setInternalSelections\r\n  };\r\n};\r\n"],"names":["nodes","BoxGeometry","Float32BufferAttribute","CatmullRomCurve3","TubeGeometry","mergeBufferGeometries","BufferGeometry","degreeCentrality","scaleLinear","n","bidirectional","Vector3","QuadraticBezierCurve3","LineCurve3","canvas","create","theme","actives","selections","id","node","createContext","useContext","useZustandStore","useShallow","MOUSE","Vector2","Vector4","Quaternion","Matrix4","Spherical","Box3","Sphere","Raycaster","MathUtils","extend","forwardRef","disabled","useRef","useThree","useState","useFrame","useEffect","useCallback","holdEvent","ref","useMemo","animated","useImperativeHandle","jsxs","jsx","useLayoutEffect","Color","useSpring","a","DoubleSide","Plane","useGesture","Ring","Fragment","Billboard","RoundedBox","Text","useCursor","ShaderMaterial","curve","Edge","arrowPosition","arrowRotation","Euler","Html","BufferAttribute","CylinderGeometry","active","inactive","draggingActive","draggingInactive","edgeMeshes","Mesh","Image","TextureLoader","LinearFilter","DreiSvg","i","links","treemap","hierarchy","forceSimulation","forceX","forceY","forceCollide","forceManyBody","forceLink","d3ForceRadial","d3ForceX","d3ForceY","d3ForceSimulation","d3ForceCenter","d3ForceLink","d3ForceManyBody","d3ForceZ","stratify","tree","drags","aggregateEdges","aggregateEdgesUtil","SelectionBox","Scene","css","Canvas","Suspense"],"mappings":"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"}