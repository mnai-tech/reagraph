{"version":3,"file":"index.js","sources":["../src/utils/animation.ts","../src/utils/arrow.ts","../src/utils/layout.ts","../src/utils/cluster.ts","../src/utils/dom.ts","../src/utils/geometry.ts","../src/sizing/attribute.ts","../src/sizing/centrality.ts","../src/sizing/pageRank.ts","../src/sizing/nodeSizeProvider.ts","../src/utils/visibility.ts","../src/utils/graph.ts","../src/utils/paths.ts","../src/utils/position.ts","../src/utils/textMeasurement.ts","../src/store.ts","../src/CameraControls/useCameraControls.ts","../src/CameraControls/CameraControls.tsx","../src/CameraControls/utils.ts","../src/collapse/utils.ts","../src/collapse/useCollapse.ts","../src/CameraControls/useCenterGraph.ts","../src/symbols/Arrow.tsx","../src/utils/useDrag.ts","../src/utils/useHoverIntent.ts","../src/symbols/clusters/Ring.tsx","../src/symbols/Label.tsx","../src/symbols/Cluster.tsx","../src/symbols/edges/SelfLoop.tsx","../src/symbols/Line.tsx","../src/symbols/Edge.tsx","../src/symbols/edges/Edge.tsx","../src/symbols/edges/useEdgeAnimations.ts","../src/symbols/edges/useEdgeEvents.ts","../src/symbols/edges/useEdgeGeometry.ts","../src/symbols/edges/Edges.tsx","../src/symbols/nodes/Badge.tsx","../src/symbols/nodes/Icon.tsx","../src/symbols/Ring.tsx","../src/symbols/nodes/Sphere.tsx","../src/symbols/nodes/SphereWithIcon.tsx","../src/symbols/nodes/Svg.tsx","../src/symbols/nodes/SphereWithSvg.tsx","../src/symbols/Node.tsx","../src/layout/layoutUtils.ts","../src/layout/circular2d.ts","../src/layout/concentric2d.ts","../src/layout/custom.ts","../src/layout/depthUtils.ts","../src/layout/forceatlas2.ts","../src/layout/forceInABox.ts","../src/layout/forceUtils.ts","../src/layout/forceDirected.ts","../src/layout/hierarchical.ts","../src/layout/concentric3d.ts","../src/layout/nooverlap.ts","../src/layout/layoutProvider.ts","../src/layout/recommender.ts","../src/useGraph.ts","../src/utils/aggregateEdges.ts","../src/GraphScene.tsx","../src/selection/utils.ts","../src/selection/Lasso.tsx","../src/themes/darkTheme.ts","../src/themes/lightTheme.ts","../src/GraphCanvas/GraphCanvas.tsx","../src/RadialMenu/RadialSlice.tsx","../src/RadialMenu/utils.ts","../src/RadialMenu/RadialMenu.tsx","../src/selection/useSelection.ts"],"sourcesContent":["export const animationConfig = {\n  mass: 10,\n  tension: 1000,\n  friction: 300,\n  // Decreasing precision to improve performance from 0.00001\n  precision: 0.1\n};\n","import type { Curve, Vector3 } from 'three';\n\nimport type { EdgeArrowPosition } from '../symbols/Arrow';\n\n// Calculate the correct position for an arrow along a curve,\n// as well as the tangent to the curve at that point.\nexport function getArrowVectors(\n  placement: EdgeArrowPosition,\n  curve: Curve<Vector3>,\n  arrowLength: number\n): [Vector3, Vector3] {\n  const curveLength = curve.getLength();\n  const absSize = placement === 'end' ? curveLength : curveLength / 2;\n  const offset = placement === 'end' ? arrowLength / 2 : 0;\n  const u = (absSize - offset) / curveLength;\n\n  const position = curve.getPointAt(u);\n  const rotation = curve.getTangentAt(u);\n\n  return [position, rotation];\n}\n\nexport function getArrowSize(size: number): [number, number] {\n  return [size + 6, 2 + size / 1.5];\n}\n","import type { InternalGraphNode } from '../types';\n\nexport interface CenterPositionVector {\n  x: number;\n  y: number;\n  z: number;\n  minX: number;\n  maxX: number;\n  minY: number;\n  maxY: number;\n  minZ: number;\n  maxZ: number;\n  height: number;\n  width: number;\n}\n\n/**\n * Given a collection of nodes, get the center point.\n */\nexport function getLayoutCenter(\n  nodes: InternalGraphNode[]\n): CenterPositionVector {\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  let minZ = Number.POSITIVE_INFINITY;\n  let maxZ = Number.NEGATIVE_INFINITY;\n\n  for (const node of nodes) {\n    minX = Math.min(minX, node.position.x);\n    maxX = Math.max(maxX, node.position.x);\n    minY = Math.min(minY, node.position.y);\n    maxY = Math.max(maxY, node.position.y);\n    minZ = Math.min(minZ, node.position.z);\n    maxZ = Math.max(maxZ, node.position.z);\n  }\n\n  return {\n    height: maxY - minY,\n    width: maxX - minX,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    x: (maxX + minX) / 2,\n    y: (maxY + minY) / 2,\n    z: (maxZ + minZ) / 2\n  };\n}\n","import type { InternalGraphNode } from '../types';\nimport type { CenterPositionVector } from './layout';\nimport { getLayoutCenter } from './layout';\n\n/**\n * Given nodes and a attribute, find all the cluster groups.\n */\nexport function buildClusterGroups(\n  nodes: InternalGraphNode[],\n  clusterAttribute?: string\n) {\n  if (!clusterAttribute) {\n    return new Map();\n  }\n\n  return nodes.reduce((entryMap, e) => {\n    const val = e.data[clusterAttribute];\n    if (val) {\n      entryMap.set(val, [...(entryMap.get(val) || []), e]);\n    }\n    return entryMap;\n  }, new Map());\n}\n\nexport interface CalculateClustersInput {\n  /**\n   * The nodes to calculate clusters for.\n   */\n  nodes: InternalGraphNode[];\n  /**\n   * The attribute to use for clustering.\n   */\n  clusterAttribute?: string;\n}\n\nexport interface ClusterGroup {\n  /**\n   * Nodes in the cluster.\n   */\n  nodes: InternalGraphNode[];\n\n  /**\n   * Center position of the cluster.\n   */\n  position: CenterPositionVector;\n\n  /**\n   * Label of the cluster.\n   */\n  label: string;\n}\n\n/**\n * Builds the cluster map.\n *\n * This function:\n *  - Builds the cluster groups\n *  - Calculates the center position of each cluster group\n *  - Creates a cluster object for each group\n */\nexport function calculateClusters({\n  nodes,\n  clusterAttribute\n}: CalculateClustersInput) {\n  const result = new Map<string, ClusterGroup>();\n\n  if (clusterAttribute) {\n    const groups = buildClusterGroups(nodes, clusterAttribute);\n    for (const [key, nodes] of groups) {\n      const position = getLayoutCenter(nodes);\n      result.set(key, {\n        label: key,\n        nodes,\n        position\n      });\n    }\n  }\n\n  return result;\n}\n","/**\n * Check if an element is not editable (input, select, textarea, contentEditable).\n * @param element - The element to check\n * @returns True if the element is not editable, false otherwise\n */\nexport const isNotEditableElement = (element: HTMLElement) => {\n  return (\n    element.tagName !== 'INPUT' &&\n    element.tagName !== 'SELECT' &&\n    element.tagName !== 'TEXTAREA' &&\n    !element.isContentEditable\n  );\n};\n","import type { Color, Curve, Vector3 } from 'three';\nimport {\n  BoxGeometry,\n  BufferGeometry,\n  CatmullRomCurve3,\n  Float32BufferAttribute,\n  TubeGeometry\n} from 'three';\nimport { mergeBufferGeometries } from 'three-stdlib';\n\n/**\n * Create a null geometry with consistent attributes\n * @returns A BufferGeometry with a null appearance\n */\nexport const createNullGeometry = (): BufferGeometry => {\n  const nullGeom = new BoxGeometry(0, 0, 0);\n  // Add color attribute to match other geometries\n  const vertexCount = nullGeom.attributes.position.count;\n  const colorArray = new Float32Array(vertexCount * 3);\n  for (let i = 0; i < vertexCount; i++) {\n    colorArray[i * 3] = 1; // white\n    colorArray[i * 3 + 1] = 1;\n    colorArray[i * 3 + 2] = 1;\n  }\n  nullGeom.setAttribute('color', new Float32BufferAttribute(colorArray, 3));\n\n  return nullGeom;\n};\n\n/**\n * Add a color attribute to a geometry\n * @param geometry - The geometry to add the color attribute to\n * @param color - The color to add to the geometry\n */\nexport const addColorAttribute = (\n  geometry: BufferGeometry,\n  color: Color\n): void => {\n  const vertexCount = geometry.attributes.position.count;\n  const colorArray = new Float32Array(vertexCount * 3);\n  for (let i = 0; i < vertexCount; i++) {\n    colorArray[i * 3] = color.r;\n    colorArray[i * 3 + 1] = color.g;\n    colorArray[i * 3 + 2] = color.b;\n  }\n  geometry.setAttribute('color', new Float32BufferAttribute(colorArray, 3));\n};\n\n/**\n * Create actual dashed geometry with gaps by making multiple small tube segments\n * @param curve - The curve to create a dashed geometry from\n * @param radius - The radius of the tube\n * @param color - The color of the tube\n * @param dashArray - The dash array [dashSize, gapSize]\n * @returns A BufferGeometry with a dashed appearance\n */\nexport const createDashedGeometry = (\n  curve: Curve<Vector3>,\n  radius: number,\n  color: Color,\n  dashArray: [number, number] = [3, 1]\n): BufferGeometry => {\n  const [dashSize, gapSize] = dashArray;\n  const totalSize = dashSize + gapSize;\n  const curveLength = curve.getLength();\n\n  // Calculate number of dashes based on curve length\n  const numDashes = Math.max(3, Math.floor(curveLength / totalSize));\n  const segments: BufferGeometry[] = [];\n\n  for (let i = 0; i < numDashes; i++) {\n    const startT = i / numDashes;\n    const endT = startT + dashSize / totalSize / numDashes;\n\n    if (endT > startT && startT < 1) {\n      // Create points for this dash segment\n      const points = [];\n      const segmentSteps = Math.max(3, Math.floor(8 * (endT - startT))); // More points for longer segments\n\n      for (let j = 0; j <= segmentSteps; j++) {\n        const t = startT + (endT - startT) * (j / segmentSteps);\n        if (t <= 1) {\n          points.push(curve.getPointAt(t));\n        }\n      }\n\n      if (points.length >= 2) {\n        // Create a curve from these points\n        const segmentCurve = new CatmullRomCurve3(points);\n        const segmentGeometry = new TubeGeometry(\n          segmentCurve,\n          Math.max(2, points.length - 1),\n          radius,\n          5,\n          false\n        );\n\n        // Add color to this segment\n        addColorAttribute(segmentGeometry, color);\n        segments.push(segmentGeometry);\n      }\n    }\n  }\n\n  return segments.length > 0\n    ? mergeBufferGeometries(segments)\n    : new BufferGeometry();\n};\n","import type { SizingStrategy, SizingStrategyInputs } from './types';\n\nexport function attributeSizing({\n  graph,\n  attribute,\n  defaultSize\n}: SizingStrategyInputs): SizingStrategy {\n  const map = new Map();\n\n  if (attribute) {\n    graph.forEachNode((id, node) => {\n      const size = node.data?.[attribute];\n      if (isNaN(size)) {\n        console.warn(`Attribute ${size} is not a number for node ${node.id}`);\n      }\n\n      map.set(id, size || 0);\n    });\n  } else {\n    console.warn('Attribute sizing configured but no attribute provided');\n  }\n\n  return {\n    getSizeForNode: (nodeId: string) => {\n      if (!attribute || !map) {\n        return defaultSize;\n      }\n\n      return map.get(nodeId);\n    }\n  };\n}\n","import { degreeCentrality } from 'graphology-metrics/centrality/degree.js';\n\nimport type { SizingStrategy, SizingStrategyInputs } from './types';\n\nexport function centralitySizing({\n  graph\n}: SizingStrategyInputs): SizingStrategy {\n  const ranks = degreeCentrality(graph);\n\n  return {\n    ranks,\n    getSizeForNode: (nodeID: string) => ranks[nodeID] * 20\n  };\n}\n","import pagerank from 'graphology-metrics/centrality/pagerank.js';\n\nimport type { SizingStrategy, SizingStrategyInputs } from './types';\n\nexport function pageRankSizing({\n  graph\n}: SizingStrategyInputs): SizingStrategy {\n  const ranks = pagerank(graph);\n\n  return {\n    ranks,\n    getSizeForNode: (nodeID: string) => ranks[nodeID] * 80\n  };\n}\n","import { scaleLinear } from 'd3-scale';\n\nimport { attributeSizing } from './attribute';\nimport { centralitySizing } from './centrality';\nimport { pageRankSizing } from './pageRank';\nimport type { SizingStrategyInputs } from './types';\n\nexport type SizingType =\n  | 'none'\n  | 'pagerank'\n  | 'centrality'\n  | 'attribute'\n  | 'default';\n\nexport interface NodeSizeProviderInputs extends SizingStrategyInputs {\n  /**\n   * The sizing strategy to use.\n   */\n  type: SizingType;\n}\n\nconst providers = {\n  pagerank: pageRankSizing,\n  centrality: centralitySizing,\n  attribute: attributeSizing,\n  none: ({ defaultSize }: SizingStrategyInputs) => ({\n    getSizeForNode: (_id: string) => defaultSize\n  })\n};\n\nexport function nodeSizeProvider({ type, ...rest }: NodeSizeProviderInputs) {\n  const provider = providers[type]?.(rest);\n  if (!provider && type !== 'default') {\n    throw new Error(`Unknown sizing strategy: ${type}`);\n  }\n\n  const { graph, minSize, maxSize } = rest;\n  const sizes = new Map();\n  let min;\n  let max;\n\n  graph.forEachNode((id, node) => {\n    let size;\n    if (type === 'default') {\n      size = node.size || rest.defaultSize;\n    } else {\n      size = provider.getSizeForNode(id);\n    }\n\n    if (min === undefined || size < min) {\n      min = size;\n    }\n\n    if (max === undefined || size > max) {\n      max = size;\n    }\n\n    sizes.set(id, size);\n  });\n\n  // Relatively scale the sizes\n  if (type !== 'none') {\n    const scale = scaleLinear()\n      .domain([min, max])\n      .rangeRound([minSize, maxSize]);\n\n    for (const [nodeId, size] of sizes) {\n      sizes.set(nodeId, scale(size));\n    }\n  }\n\n  return sizes;\n}\n","import type { PerspectiveCamera } from 'three';\n\nimport type { EdgeLabelPosition } from '../symbols';\n\nexport type LabelVisibilityType = 'all' | 'auto' | 'none' | 'nodes' | 'edges';\n\ninterface CalcLabelVisibilityArgs {\n  nodeCount: number;\n  nodePosition?: { x: number; y: number; z: number };\n  labelType: LabelVisibilityType;\n  camera?: PerspectiveCamera;\n}\n\nexport function calcLabelVisibility({\n  nodePosition,\n  labelType,\n  camera\n}: CalcLabelVisibilityArgs) {\n  return (shape: 'node' | 'edge', size: number) => {\n    const isAlwaysVisible =\n      labelType === 'all' ||\n      (labelType === 'nodes' && shape === 'node') ||\n      (labelType === 'edges' && shape === 'edge');\n\n    if (\n      !isAlwaysVisible &&\n      camera &&\n      nodePosition &&\n      camera?.position?.z / camera?.zoom - nodePosition?.z > 6000\n    ) {\n      return false;\n    }\n\n    if (isAlwaysVisible) {\n      return true;\n    } else if (labelType === 'auto' && shape === 'node') {\n      if (size > 7) {\n        return true;\n      } else if (\n        camera &&\n        nodePosition &&\n        camera.position.z / camera.zoom - nodePosition.z < 3000\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nexport function getLabelOffsetByType(\n  offset: number,\n  position: EdgeLabelPosition\n): number {\n  switch (position) {\n    case 'above':\n      return offset;\n    case 'below':\n      return -offset;\n    case 'inline':\n    case 'natural':\n    default:\n      return 0;\n  }\n}\n\nexport const isServerRender = typeof window === 'undefined';\n","import type Graph from 'graphology';\n\nimport type { LayoutStrategy } from '../layout';\nimport type { SizingType } from '../sizing';\nimport { nodeSizeProvider } from '../sizing';\nimport type {\n  GraphEdge,\n  GraphNode,\n  InternalGraphEdge,\n  InternalGraphNode\n} from '../types';\nimport type { LabelVisibilityType } from './visibility';\nimport { calcLabelVisibility } from './visibility';\n\n/**\n * Initialize the graph with the nodes/edges.\n */\nexport function buildGraph(\n  graph: Graph,\n  nodes: GraphNode[],\n  edges: GraphEdge[]\n) {\n  // TODO: We probably want to make this\n  // smarter and only add/remove nodes\n  graph.clear();\n\n  const addedNodes = new Set<string>();\n\n  for (const node of nodes) {\n    try {\n      if (!addedNodes.has(node.id)) {\n        graph.addNode(node.id, node);\n        addedNodes.add(node.id);\n      }\n    } catch (e) {\n      console.error(`[Graph] Error adding node '${node.id}`, e);\n    }\n  }\n\n  for (const edge of edges) {\n    if (!addedNodes.has(edge.source) || !addedNodes.has(edge.target)) {\n      continue;\n    }\n\n    try {\n      graph.addEdge(edge.source, edge.target, edge);\n    } catch (e) {\n      console.error(\n        `[Graph] Error adding edge '${edge.source} -> ${edge.target}`,\n        e\n      );\n    }\n  }\n\n  return graph;\n}\n\ninterface TransformGraphInput {\n  graph: Graph;\n  layout: LayoutStrategy;\n  sizingType?: SizingType;\n  labelType?: LabelVisibilityType;\n  sizingAttribute?: string;\n  minNodeSize?: number;\n  maxNodeSize?: number;\n  defaultNodeSize?: number;\n  clusterAttribute?: string;\n}\n\n/**\n * Transform the graph into a format that is easier to work with.\n */\nexport function transformGraph({\n  graph,\n  layout,\n  sizingType,\n  labelType,\n  sizingAttribute,\n  defaultNodeSize,\n  minNodeSize,\n  maxNodeSize,\n  clusterAttribute\n}: TransformGraphInput) {\n  const nodes: InternalGraphNode[] = [];\n  const edges: InternalGraphEdge[] = [];\n  const map = new Map<string, InternalGraphNode>();\n\n  const sizes = nodeSizeProvider({\n    graph,\n    type: sizingType,\n    attribute: sizingAttribute,\n    minSize: minNodeSize,\n    maxSize: maxNodeSize,\n    defaultSize: defaultNodeSize\n  });\n\n  const nodeCount = graph.nodes().length;\n  const checkVisibility = calcLabelVisibility({ nodeCount, labelType });\n\n  graph.forEachNode((id, node) => {\n    const position = layout.getNodePosition(id);\n    const { data, fill, icon, label, size, ...rest } = node;\n    const nodeSize = sizes.get(node.id);\n    const labelVisible = checkVisibility('node', nodeSize);\n\n    const nodeLinks = graph.inboundNeighbors(node.id) || [];\n    const parents = nodeLinks.map(n => graph.getNodeAttributes(n));\n\n    const n: InternalGraphNode = {\n      ...(node as any),\n      size: nodeSize,\n      labelVisible,\n      label,\n      icon,\n      fill,\n      cluster: clusterAttribute ? data[clusterAttribute] : undefined,\n      parents,\n      data: {\n        ...rest,\n        ...(data ?? {})\n      },\n      position: {\n        ...position,\n        x: position.x || 0,\n        y: position.y || 0,\n        z: position.z || 1\n      }\n    };\n\n    map.set(node.id, n);\n    nodes.push(n);\n  });\n\n  graph.forEachEdge((_id, link) => {\n    const from = map.get(link.source);\n    const to = map.get(link.target);\n\n    if (from && to) {\n      const { data, id, label, size, ...rest } = link;\n      const labelVisible = checkVisibility('edge', size);\n\n      // TODO: Fix type\n      edges.push({\n        ...link,\n        id,\n        label,\n        labelVisible,\n        size,\n        data: {\n          ...rest,\n          id,\n          ...(data || {})\n        }\n      } as any);\n    }\n  });\n\n  return {\n    nodes,\n    edges\n  };\n}\n","import type Graph from 'graphology';\nimport { bidirectional } from 'graphology-shortest-path';\n\nexport function findPath(graph: Graph, source: string, target: string) {\n  return bidirectional(graph, source, target);\n}\n","import type { EdgeSubLabelPosition } from 'symbols/Edge';\nimport type { Curve } from 'three';\nimport {\n  CatmullRomCurve3,\n  LineCurve3,\n  QuadraticBezierCurve3,\n  Vector3\n} from 'three';\n\nimport type { InternalGraphNode, InternalVector3 } from '../types';\n\nconst MULTI_EDGE_OFFSET_FACTOR = 0.7;\n\n/**\n * Get the midpoint given two points.\n */\nexport function getMidPoint(\n  from: InternalVector3,\n  to: InternalVector3,\n  offset = 0\n) {\n  const fromVector = new Vector3(from.x, from.y || 0, from.z || 0);\n  const toVector = new Vector3(to.x, to.y || 0, to.z || 0);\n  const midVector = new Vector3()\n    .addVectors(fromVector, toVector)\n    .divideScalar(2);\n\n  return midVector.setLength(midVector.length() + offset);\n}\n\n/**\n * Calculate the center for a quadratic bezier curve.\n *\n * 1) Find the point halfway between the start and end points of the desired curve\n * 2) Find the vector pependicular to that point\n * 3) Find the point 1/4 the distance between start and end along that vector.\n */\nexport function getCurvePoints(\n  from: Vector3,\n  to: Vector3,\n  offset = -1\n): [Vector3, Vector3, Vector3] {\n  const fromVector = from.clone();\n  const toVector = to.clone();\n  const v = new Vector3().subVectors(toVector, fromVector);\n  const vlen = v.length();\n  const vn = v.clone().normalize();\n  const vv = new Vector3().subVectors(toVector, fromVector).divideScalar(2);\n  const k = Math.abs(vn.x) % 1;\n  const b = new Vector3(-vn.y, vn.x - k * vn.z, k * vn.y).normalize();\n  const vm = new Vector3()\n    .add(fromVector)\n    .add(vv)\n    .add(b.multiplyScalar(vlen / 4).multiplyScalar(offset));\n\n  return [from, vm, to];\n}\n\n/**\n * Get the curve given two points.\n */\nexport function getCurve(\n  from: Vector3,\n  fromOffset: number,\n  to: Vector3,\n  toOffset: number,\n  curved: boolean,\n  curveOffset?: number\n): Curve<Vector3> {\n  const offsetFrom = getPointBetween(from, to, fromOffset);\n  const offsetTo = getPointBetween(to, from, toOffset);\n  return curved\n    ? new QuadraticBezierCurve3(\n        ...getCurvePoints(offsetFrom, offsetTo, curveOffset)\n      )\n    : new LineCurve3(offsetFrom, offsetTo);\n}\n\n/**\n * Get the curve for a self-loop.\n */\nexport function getSelfLoopCurve(from: InternalGraphNode) {\n  const nodePosition = getVector(from);\n  const loopRadius = from.size;\n  const angle = Math.PI / 2; // 90 degrees on top of the node\n\n  const loopCenter = nodePosition\n    .clone()\n    .add(\n      new Vector3(\n        loopRadius * Math.cos(angle),\n        loopRadius * 1.3 * Math.sin(angle),\n        0\n      )\n    );\n\n  // Create selfLoopCurve\n  const numPoints = 10; // Use more points for smoother curve\n  const points: Vector3[] = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    const theta = (i / numPoints) * 2 * Math.PI;\n    points.push(\n      loopCenter\n        .clone()\n        .add(\n          new Vector3(\n            loopRadius * Math.cos(theta),\n            loopRadius * Math.sin(theta),\n            0\n          )\n        )\n    );\n  }\n  const selfLoopCurve = new CatmullRomCurve3(points, true);\n\n  return selfLoopCurve;\n}\n\n/**\n * Create a threejs vector for a node.\n */\nexport function getVector(node: InternalGraphNode): Vector3 {\n  return new Vector3(node.position.x, node.position.y, node.position.z || 0);\n}\n\n/**\n * Get the point between two vectors.\n */\nfunction getPointBetween(from: Vector3, to: Vector3, offset: number): Vector3 {\n  const distance = from.distanceTo(to);\n  return from.clone().add(\n    to\n      .clone()\n      .sub(from)\n      .multiplyScalar(offset / distance)\n  );\n}\n\n/**\n * Given a node and a new vector set, update the node model.\n */\nexport function updateNodePosition(node: InternalGraphNode, offset: Vector3) {\n  return {\n    ...node,\n    position: {\n      ...node.position,\n      x: node.position.x + offset.x,\n      y: node.position.y + offset.y,\n      z: node.position.z + offset.z\n    }\n  };\n}\n\n/**\n * Calculate the curve offset for an edge.\n * This is used to offset edges that are parallel to each other (same source and same target).\n * This will return a curveOffset of null if the edge is not parallel to any other edges.\n */\nexport function calculateEdgeCurveOffset({ edge, edges, curved }) {\n  let updatedCurved = curved;\n  let curveOffset: number;\n\n  const parallelEdges = edges\n    .filter(e => e.target === edge.target && e.source === edge.source)\n    .map(e => e.id);\n\n  if (parallelEdges.length > 1) {\n    updatedCurved = true;\n    const edgeIndex = parallelEdges.indexOf(edge.id);\n\n    // Progressive distribution with unique magnitude for each edge\n    // This prevents overlapping by ensuring each edge has sufficient separation\n    const offsetMultiplier = edgeIndex === 0 ? 1 : 1 + edgeIndex * 0.8;\n    const side = edgeIndex % 2 === 0 ? 1 : -1;\n    const magnitude = MULTI_EDGE_OFFSET_FACTOR * offsetMultiplier;\n    curveOffset = side * magnitude;\n  }\n\n  if (edge.data?.isAggregated && edges.length > 1) {\n    const edgeIndex = parallelEdges.indexOf(edge.id);\n    return {\n      curved: true,\n      curveOffset:\n        edgeIndex === 0 ? MULTI_EDGE_OFFSET_FACTOR : -MULTI_EDGE_OFFSET_FACTOR\n    };\n  }\n\n  return { curved: updatedCurved, curveOffset };\n}\n\n/**\n * Calculate the offset position for a subLabel based on edge orientation and placement preference\n *\n * @param fromPosition - Position of the source node\n * @param toPosition - Position of the target node\n * @param subLabelPlacement - Whether to place the subLabel 'above' or 'below' the edge\n * @returns Object with x, y offset values for positioning the subLabel perpendicular to the edge\n *\n * The function calculates a perpendicular offset from the edge line, with the direction\n * determined by both the subLabelPlacement ('above' or 'below') and the edge direction.\n * The perpendicular angle is calculated differently based on whether the edge is going\n * left-to-right or right-to-left to maintain consistent 'above'/'below' positioning.\n */\nexport function calculateSubLabelOffset(\n  fromPosition: { x: number; y: number },\n  toPosition: { x: number; y: number },\n  subLabelPlacement?: EdgeSubLabelPosition\n): { x: number; y: number; z: number } {\n  // Calculate direction vector between nodes\n  const dx = toPosition.x - fromPosition.x;\n  const dy = toPosition.y - fromPosition.y;\n\n  // Get angle of the edge\n  const angle = Math.atan2(dy, dx);\n\n  // Calculate perpendicular angle based on edge direction and subLabelPlacement\n  const perpAngle =\n    subLabelPlacement === 'above'\n      ? dx >= 0\n        ? angle + Math.PI / 2\n        : angle - Math.PI / 2\n      : dx >= 0\n        ? angle - Math.PI / 2\n        : angle + Math.PI / 2;\n\n  // Offset distance for subLabel\n  const offsetDistance = 7;\n\n  // Calculate offset using perpendicular angle\n  const offsetX = Math.cos(perpAngle) * offsetDistance;\n  const offsetY = Math.sin(perpAngle) * offsetDistance;\n\n  return { x: offsetX, y: offsetY, z: 0 };\n}\n","export interface TextDimensions {\n  width: number;\n  height: number;\n}\n\nexport interface TextMeasurementOptions {\n  text: string;\n  fontSize: number;\n  fontWeight?: number;\n  fontFamily?: string;\n}\n\n// Cache to avoid repeated measurements\nconst measurementCache = new Map<string, TextDimensions>();\n\n// Reusable canvas context for measurements\nlet canvasContext: CanvasRenderingContext2D | null = null;\n\n/**\n * Get or create a canvas context for text measurements.\n */\nfunction getCanvasContext(): CanvasRenderingContext2D {\n  if (!canvasContext) {\n    const canvas = document.createElement('canvas');\n    canvasContext = canvas.getContext('2d');\n\n    if (!canvasContext) {\n      throw new Error('Failed to create canvas context for text measurement');\n    }\n  }\n\n  return canvasContext;\n}\n\n/**\n * Generate a cache key from measurement options.\n */\nfunction getCacheKey(options: TextMeasurementOptions): string {\n  const {\n    text,\n    fontSize,\n    fontWeight = 400,\n    fontFamily = 'sans-serif'\n  } = options;\n  return `${text}|${fontSize}|${fontWeight}|${fontFamily}`;\n}\n\n/**\n * Measure text dimensions using Canvas API.\n * Results are cached for performance.\n *\n * @param options - Text measurement options\n * @returns Text dimensions (width and height)\n */\nexport function measureText(options: TextMeasurementOptions): TextDimensions {\n  const cacheKey = getCacheKey(options);\n\n  // Return cached result if available\n  const cached = measurementCache.get(cacheKey);\n  if (cached) {\n    return cached;\n  }\n\n  const {\n    text,\n    fontSize,\n    fontWeight = 400,\n    fontFamily = 'sans-serif'\n  } = options;\n\n  try {\n    const context = getCanvasContext();\n\n    // Set font properties\n    context.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n\n    // Measure text\n    const metrics = context.measureText(text);\n\n    // Calculate dimensions\n    const dimensions: TextDimensions = {\n      width: metrics.width,\n      // Use actual bounding box height if available, otherwise estimate from font size\n      height:\n        metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent ||\n        fontSize * 1.2\n    };\n\n    // Cache the result\n    measurementCache.set(cacheKey, dimensions);\n\n    return dimensions;\n  } catch (error) {\n    console.warn('Failed to measure text, falling back to estimation:', error);\n\n    // Fallback to estimation if measurement fails\n    const fallback: TextDimensions = {\n      width: text.length * fontSize * 0.6,\n      height: fontSize * 1.2\n    };\n\n    return fallback;\n  }\n}\n\n/**\n * Clear the measurement cache.\n * Useful for testing or memory management.\n */\nexport function clearMeasurementCache(): void {\n  measurementCache.clear();\n}\n\n/**\n * Get the current cache size.\n */\nexport function getMeasurementCacheSize(): number {\n  return measurementCache.size;\n}\n","import Graph from 'graphology';\nimport type { FC, ReactNode } from 'react';\nimport { createContext, useContext } from 'react';\nimport React from 'react';\nimport type { BufferGeometry, Mesh } from 'three';\nimport { Vector3 } from 'three';\nimport type { StoreApi } from 'zustand';\nimport { create, useStore as useZustandStore } from 'zustand';\nimport { useShallow } from 'zustand/shallow';\n\nimport type { Theme } from './themes';\nimport type {\n  InternalGraphEdge,\n  InternalGraphNode,\n  InternalGraphPosition\n} from './types';\nimport type { CenterPositionVector, ClusterGroup } from './utils';\nimport { getLayoutCenter, getVector, updateNodePosition } from './utils';\nimport { isServerRender } from './utils/visibility';\n\nexport type DragReferences = {\n  [key: string]: InternalGraphNode;\n};\n\nexport interface GraphState {\n  nodes: InternalGraphNode[];\n  edges: InternalGraphEdge[];\n  graph: Graph;\n  clusters: Map<string, ClusterGroup>;\n  collapsedNodeIds?: string[];\n  centerPosition?: CenterPositionVector;\n  actives?: string[];\n  selections?: string[];\n  // The node that is currently hovered, used to disable cluster dragging\n  hoveredNodeId?: string;\n  // The edges that are currently hovered over, required for cases when animation is disabled\n  hoveredEdgeIds?: string[];\n  edgeContextMenus?: Set<string>;\n  setEdgeContextMenus: (edges: Set<string>) => void;\n  edgeMeshes: Array<Mesh<BufferGeometry>>;\n  setEdgeMeshes: (edgeMeshes: Array<Mesh<BufferGeometry>>) => void;\n  draggingIds?: string[];\n  drags?: DragReferences;\n  panning?: boolean;\n  theme: Theme;\n  setTheme: (theme: Theme) => void;\n  setClusters: (clusters: Map<string, ClusterGroup>) => void;\n  setPanning: (panning: boolean) => void;\n  setDrags: (drags: DragReferences) => void;\n  addDraggingId: (id: string) => void;\n  removeDraggingId: (id: string) => void;\n  setActives: (actives: string[]) => void;\n  setSelections: (selections: string[]) => void;\n  setHoveredNodeId: (hoveredNodeId: string | null) => void;\n  setHoveredEdgeIds: (hoveredEdgeIds: string[] | null) => void;\n  setNodes: (nodes: InternalGraphNode[]) => void;\n  setEdges: (edges: InternalGraphEdge[]) => void;\n  setNodePosition: (id: string, position: InternalGraphPosition) => void;\n  setCollapsedNodeIds: (nodeIds: string[]) => void;\n  canvasRef: HTMLCanvasElement | null;\n  setClusterPosition: (id: string, position: CenterPositionVector) => void;\n}\n\n// Create a store factory function\nexport const createStore = ({\n  actives = [],\n  selections = [],\n  collapsedNodeIds = [],\n  theme,\n  canvasRef = null\n}: Partial<GraphState>) =>\n  create<GraphState>(set => ({\n    theme: {\n      ...theme,\n      edge: {\n        ...theme?.edge,\n        label: {\n          ...theme?.edge?.label,\n          fontSize: theme?.edge?.label?.fontSize ?? 6\n        }\n      }\n    },\n    edges: [],\n    nodes: [],\n    collapsedNodeIds,\n    clusters: new Map(),\n    panning: false,\n    draggingIds: [],\n    actives,\n    hoveredEdgeIds: [],\n    edgeContextMenus: new Set(),\n    edgeMeshes: [],\n    selections,\n    hoveredNodeId: null,\n    drags: {},\n    graph: new Graph({ multi: true }),\n    setTheme: theme => set(state => ({ ...state, theme })),\n    setClusters: clusters => set(state => ({ ...state, clusters })),\n    setEdgeContextMenus: edgeContextMenus =>\n      set(state => ({\n        ...state,\n        edgeContextMenus\n      })),\n    setEdgeMeshes: edgeMeshes => set(state => ({ ...state, edgeMeshes })),\n    setPanning: panning => set(state => ({ ...state, panning })),\n    setDrags: drags => set(state => ({ ...state, drags })),\n    addDraggingId: id =>\n      set(state => ({ ...state, draggingIds: [...state.draggingIds, id] })),\n    removeDraggingId: id =>\n      set(state => ({\n        ...state,\n        draggingIds: state.draggingIds.filter(drag => drag !== id)\n      })),\n    setActives: actives => set(state => ({ ...state, actives })),\n    setSelections: selections => set(state => ({ ...state, selections })),\n    setHoveredNodeId: hoveredNodeId =>\n      set(state => ({ ...state, hoveredNodeId })),\n    setHoveredEdgeIds: hoveredEdgeIds =>\n      set(state => ({ ...state, hoveredEdgeIds })),\n    setNodes: nodes =>\n      set(state => ({\n        ...state,\n        nodes,\n        centerPosition: getLayoutCenter(nodes)\n      })),\n    setEdges: edges => set(state => ({ ...state, edges })),\n    setNodePosition: (id, position) =>\n      set(state => {\n        const node = state.nodes.find(n => n.id === id);\n        const originalVector = getVector(node);\n        const newVector = new Vector3(position.x, position.y, position.z);\n        const offset = newVector.sub(originalVector);\n        const nodes = [...state.nodes];\n\n        if (state.selections?.includes(id)) {\n          state.selections?.forEach(id => {\n            const node = state.nodes.find(n => n.id === id);\n            // Selections can contain edges:\n            if (node) {\n              const nodeIndex = state.nodes.indexOf(node);\n              nodes[nodeIndex] = updateNodePosition(node, offset);\n            }\n          });\n        } else {\n          const nodeIndex = state.nodes.indexOf(node);\n          nodes[nodeIndex] = updateNodePosition(node, offset);\n        }\n\n        return {\n          ...state,\n          drags: {\n            ...state.drags,\n            [id]: node\n          },\n          nodes\n        };\n      }),\n    setCollapsedNodeIds: (nodeIds = []) =>\n      set(state => ({ ...state, collapsedNodeIds: nodeIds })),\n    canvasRef,\n    // Update the position of a cluster with nodes inside it\n    setClusterPosition: (id, position) =>\n      set(state => {\n        const clusters = new Map<string, any>(state.clusters);\n        const cluster = clusters.get(id);\n\n        if (cluster) {\n          // Calculate the offset between old and new position\n          const oldPos = cluster.position;\n          const offset = new Vector3(\n            position.x - oldPos.x,\n            position.y - oldPos.y,\n            position.z - (oldPos.z ?? 0)\n          );\n\n          // Update all nodes in the cluster\n          const nodes: InternalGraphNode[] = [...state.nodes];\n          const drags: DragReferences = { ...state.drags };\n          nodes.forEach((node, index) => {\n            if (node.cluster === id) {\n              nodes[index] = {\n                ...node,\n                position: {\n                  ...node.position,\n                  x: node.position.x + offset.x,\n                  y: node.position.y + offset.y,\n                  z: node.position.z + (offset.z ?? 0)\n                } as InternalGraphPosition\n              };\n              // Update node in drag reference\n              drags[node.id] = node;\n            }\n          });\n\n          const clusterNodes: InternalGraphNode[] = nodes.filter(\n            node => node.cluster === id\n          );\n          const newClusterPosition = getLayoutCenter(clusterNodes);\n          // Update cluster position\n          clusters.set(id, {\n            ...cluster,\n            position: newClusterPosition\n          });\n\n          return {\n            ...state,\n            drags: {\n              ...drags,\n              [id]: cluster\n            },\n            clusters,\n            nodes\n          };\n        }\n\n        return state;\n      })\n  }));\n\nconst defaultStore = createStore({});\nconst StoreContext = isServerRender\n  ? null\n  : createContext<StoreApi<GraphState>>(defaultStore);\n\nexport const Provider: FC<{\n  children: ReactNode;\n  store?: StoreApi<GraphState>;\n}> = ({ children, store = defaultStore }) => {\n  if (isServerRender) {\n    return children;\n  }\n\n  return React.createElement(StoreContext.Provider, { value: store }, children);\n};\n\nexport const useStore = <T>(selector: (state: GraphState) => T): T => {\n  const store = useContext(StoreContext);\n  // use the useShallow hook, which will return a stable reference (https://zustand.docs.pmnd.rs/migrations/migrating-to-v5)\n  return useZustandStore(store, useShallow(selector));\n};\n","import type CameraControls from 'camera-controls';\nimport { createContext, useContext } from 'react';\n\nexport interface CameraControlsContextProps {\n  /**\n   * The camera controls object.\n   */\n  controls: CameraControls | null;\n\n  /**\n   * A function that resets the camera controls.\n   * If the optional `animated` argument is true, the reset is animated.\n   */\n  resetControls: (animated?: boolean) => void;\n\n  /**\n   * A function that zooms in the camera.\n   */\n  zoomIn: () => void;\n\n  /**\n   * A function that zooms out the camera.\n   */\n  zoomOut: () => void;\n\n  /**\n   * A function that dollies in the camera.\n   */\n  dollyIn: (distance?: number) => void;\n\n  /**\n   * A function that dollies out the camera.\n   */\n  dollyOut: (distance?: number) => void;\n\n  /**\n   * A function that pans the camera to the left.\n   */\n  panLeft: () => void;\n\n  /**\n   * A function that pans the camera to the right.\n   */\n  panRight: () => void;\n\n  /**\n   * A function that pans the camera upwards.\n   */\n  panUp: () => void;\n\n  /**\n   * A function that pans the camera downwards.\n   */\n  panDown: () => void;\n\n  /**\n   * A function that freezes the camera.\n   */\n  freeze: () => void;\n\n  /**\n   * A function that unfreezes the camera.\n   */\n  unFreeze: () => void;\n}\n\nexport const CameraControlsContext = createContext<CameraControlsContextProps>({\n  controls: null,\n  resetControls: () => undefined,\n  zoomIn: () => undefined,\n  zoomOut: () => undefined,\n  dollyIn: () => undefined,\n  dollyOut: () => undefined,\n  panLeft: () => undefined,\n  panRight: () => undefined,\n  panUp: () => undefined,\n  panDown: () => undefined,\n  freeze: () => undefined,\n  unFreeze: () => undefined\n});\n\nexport const useCameraControls = () => {\n  const context = useContext(CameraControlsContext);\n\n  if (context === undefined) {\n    throw new Error(\n      '`useCameraControls` hook must be used within a `ControlsProvider` component'\n    );\n  }\n\n  return context;\n};\n","import { extend, useFrame, useThree } from '@react-three/fiber';\nimport ThreeCameraControls from 'camera-controls';\nimport * as holdEvent from 'hold-event';\nimport type { ReactNode, Ref } from 'react';\nimport React, {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState\n} from 'react';\nimport {\n  Box3,\n  MathUtils,\n  Matrix4,\n  MOUSE,\n  Quaternion,\n  Raycaster,\n  Sphere,\n  Spherical,\n  Vector2,\n  Vector3,\n  Vector4\n} from 'three';\n\nimport { useStore } from '../store';\nimport { isServerRender } from '../utils/visibility';\nimport type { CameraControlsContextProps } from './useCameraControls';\nimport { CameraControlsContext } from './useCameraControls';\n\n// Install the camera controls\n// Use a subset for better three shaking\nThreeCameraControls.install({\n  THREE: {\n    MOUSE: MOUSE,\n    Vector2: Vector2,\n    Vector3: Vector3,\n    Vector4: Vector4,\n    Quaternion: Quaternion,\n    Matrix4: Matrix4,\n    Spherical: Spherical,\n    Box3: Box3,\n    Sphere: Sphere,\n    Raycaster: Raycaster,\n    MathUtils: {\n      DEG2RAD: MathUtils?.DEG2RAD,\n      clamp: MathUtils?.clamp\n    }\n  }\n});\n\n// Extend r3f with the new controls\nextend({ ThreeCameraControls });\n\nexport type CameraMode = 'pan' | 'rotate' | 'orbit' | 'orthographic';\n\nexport interface CameraControlsProps {\n  /**\n   * Mode of the camera.\n   */\n  mode?: CameraMode;\n\n  /**\n   * Children symbols.\n   */\n  children?: ReactNode;\n\n  /**\n   * Animate transitions to centering.\n   */\n  animated?: boolean;\n\n  /**\n   * Whether the controls are enabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * The maximum distance for the camera (perspective mode).\n   */\n  maxDistance?: number;\n\n  /**\n   * The minimum distance for the camera (perspective mode).\n   */\n  minDistance?: number;\n\n  /**\n   * The maximum zoom level for orthographic cameras.\n   */\n  maxZoom?: number;\n\n  /**\n   * The minimum zoom level for orthographic cameras.\n   */\n  minZoom?: number;\n}\n\nexport type CameraControlsRef = CameraControlsContextProps;\n\nexport const CameraControls = forwardRef<\n  CameraControlsRef,\n  CameraControlsProps\n>(\n  (\n    {\n      mode = 'rotate',\n      children,\n      animated,\n      disabled,\n      minDistance = 1000,\n      maxDistance = 50000,\n      minZoom = 1,\n      maxZoom = 100\n    },\n    ref: Ref<CameraControlsRef>\n  ) => {\n    const cameraRef = useRef<ThreeCameraControls | null>(null);\n    const camera = useThree(state => state.camera);\n    const gl = useThree(state => state.gl);\n    const isOrbiting = mode === 'orbit';\n    const setPanning = useStore(state => state.setPanning);\n    const isDragging = useStore(state => state.draggingIds.length > 0);\n    const cameraSpeedRef = useRef(0);\n    const [controlMounted, setControlMounted] = useState<boolean>(false);\n\n    useFrame((_state, delta) => {\n      if (cameraRef.current?.enabled) {\n        cameraRef.current?.update(delta);\n      }\n\n      if (isOrbiting) {\n        cameraRef.current.azimuthAngle += 20 * delta * MathUtils.DEG2RAD;\n      }\n    }, -1);\n\n    useEffect(() => () => cameraRef.current?.dispose(), []);\n\n    const zoomIn = useCallback(() => {\n      cameraRef.current?.zoom(camera.zoom / 2, animated);\n    }, [animated, camera.zoom]);\n\n    const zoomOut = useCallback(() => {\n      cameraRef.current?.zoom(-camera.zoom / 2, animated);\n    }, [animated, camera.zoom]);\n\n    const dollyIn = useCallback(\n      distance => {\n        cameraRef.current?.dolly(distance, animated);\n      },\n      [animated]\n    );\n\n    const dollyOut = useCallback(\n      distance => {\n        cameraRef.current?.dolly(distance, animated);\n      },\n      [animated]\n    );\n\n    const panRight = useCallback(\n      event => {\n        if (!isOrbiting) {\n          cameraRef.current?.truck(-0.03 * event.deltaTime, 0, animated);\n        }\n      },\n      [animated, isOrbiting]\n    );\n\n    const panLeft = useCallback(\n      event => {\n        if (!isOrbiting) {\n          cameraRef.current?.truck(0.03 * event.deltaTime, 0, animated);\n        }\n      },\n      [animated, isOrbiting]\n    );\n\n    const panUp = useCallback(\n      event => {\n        if (!isOrbiting) {\n          cameraRef.current?.truck(0, 0.03 * event.deltaTime, animated);\n        }\n      },\n      [animated, isOrbiting]\n    );\n\n    const panDown = useCallback(\n      event => {\n        if (!isOrbiting) {\n          cameraRef.current?.truck(0, -0.03 * event.deltaTime, animated);\n        }\n      },\n      [animated, isOrbiting]\n    );\n\n    const onKeyDown = useCallback(\n      event => {\n        if (event.code === 'Space') {\n          if (mode === 'rotate') {\n            cameraRef.current.mouseButtons.left =\n              ThreeCameraControls.ACTION.TRUCK;\n          } else {\n            cameraRef.current.mouseButtons.left =\n              ThreeCameraControls.ACTION.ROTATE;\n          }\n        }\n      },\n      [mode]\n    );\n\n    const onKeyUp = useCallback(\n      event => {\n        if (event.code === 'Space') {\n          if (mode === 'rotate') {\n            cameraRef.current.mouseButtons.left =\n              ThreeCameraControls.ACTION.ROTATE;\n          } else {\n            cameraRef.current.mouseButtons.left =\n              ThreeCameraControls.ACTION.TRUCK;\n          }\n        }\n      },\n      [mode]\n    );\n\n    const [keyControls, setKeyControls] = useState<{\n      leftKey: holdEvent.KeyboardKeyHold;\n      rightKey: holdEvent.KeyboardKeyHold;\n      upKey: holdEvent.KeyboardKeyHold;\n      downKey: holdEvent.KeyboardKeyHold;\n    } | null>(null);\n\n    useEffect(() => {\n      // Only initialize on client side\n      if (!isServerRender) {\n        setKeyControls({\n          leftKey: new holdEvent.KeyboardKeyHold('ArrowLeft', 100),\n          rightKey: new holdEvent.KeyboardKeyHold('ArrowRight', 100),\n          upKey: new holdEvent.KeyboardKeyHold('ArrowUp', 100),\n          downKey: new holdEvent.KeyboardKeyHold('ArrowDown', 100)\n        });\n      }\n    }, []);\n\n    useEffect(() => {\n      if (!disabled && keyControls) {\n        keyControls.leftKey.addEventListener('holding', panLeft);\n        keyControls.rightKey.addEventListener('holding', panRight);\n        keyControls.upKey.addEventListener('holding', panUp);\n        keyControls.downKey.addEventListener('holding', panDown);\n\n        window.addEventListener('keydown', onKeyDown);\n        window.addEventListener('keyup', onKeyUp);\n      }\n\n      return () => {\n        if (keyControls) {\n          keyControls.leftKey.removeEventListener('holding', panLeft);\n          keyControls.rightKey.removeEventListener('holding', panRight);\n          keyControls.upKey.removeEventListener('holding', panUp);\n          keyControls.downKey.removeEventListener('holding', panDown);\n\n          window.removeEventListener('keydown', onKeyDown);\n          window.removeEventListener('keyup', onKeyUp);\n        }\n      };\n    }, [\n      disabled,\n      onKeyDown,\n      onKeyUp,\n      panDown,\n      panLeft,\n      panRight,\n      panUp,\n      keyControls\n    ]);\n\n    useEffect(() => {\n      const isOrthographic = mode === 'orthographic';\n\n      if (disabled) {\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.NONE;\n        cameraRef.current.mouseButtons.middle = ThreeCameraControls.ACTION.NONE;\n        cameraRef.current.mouseButtons.wheel = ThreeCameraControls.ACTION.NONE;\n      } else {\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.TRUCK;\n        cameraRef.current.mouseButtons.middle =\n          ThreeCameraControls.ACTION.TRUCK;\n        cameraRef.current.mouseButtons.wheel = isOrthographic\n          ? ThreeCameraControls.ACTION.ZOOM\n          : ThreeCameraControls.ACTION.DOLLY;\n      }\n\n      // For orthographic cameras, use dedicated zoom props\n      if (isOrthographic && cameraRef.current) {\n        cameraRef.current.maxZoom = maxZoom;\n        cameraRef.current.minZoom = minZoom;\n      }\n    }, [disabled, mode, minZoom, maxZoom]);\n\n    useEffect(() => {\n      const onControl = () => setPanning(true);\n      const onControlEnd = () => setPanning(false);\n\n      const ref = cameraRef.current;\n      if (ref) {\n        ref.addEventListener('control', onControl);\n        ref.addEventListener('controlend', onControlEnd);\n      }\n\n      return () => {\n        if (ref) {\n          ref.removeEventListener('control', onControl);\n          ref.removeEventListener('controlend', onControlEnd);\n        }\n      };\n    }, [cameraRef, setPanning]);\n\n    useEffect(() => {\n      // If a node is being dragged, disable the camera controls\n      if (isDragging) {\n        cameraRef.current.mouseButtons.left = ThreeCameraControls.ACTION.NONE;\n        cameraRef.current.touches.one = ThreeCameraControls.ACTION.NONE;\n      } else {\n        if (mode === 'rotate') {\n          cameraRef.current.mouseButtons.left =\n            ThreeCameraControls.ACTION.ROTATE;\n          cameraRef.current.touches.one =\n            ThreeCameraControls.ACTION.TOUCH_ROTATE;\n        } else {\n          cameraRef.current.touches.one =\n            ThreeCameraControls.ACTION.TOUCH_TRUCK;\n          cameraRef.current.mouseButtons.left =\n            ThreeCameraControls.ACTION.TRUCK;\n        }\n      }\n    }, [isDragging, mode]);\n\n    const values = useMemo(\n      () => ({\n        controls: cameraRef.current,\n        zoomIn: () => zoomIn(),\n        zoomOut: () => zoomOut(),\n        dollyIn: (distance = 1000) => dollyIn(distance),\n        dollyOut: (distance = -1000) => dollyOut(distance),\n        panLeft: (deltaTime = 100) => panLeft({ deltaTime }),\n        panRight: (deltaTime = 100) => panRight({ deltaTime }),\n        panDown: (deltaTime = 100) => panDown({ deltaTime }),\n        panUp: (deltaTime = 100) => panUp({ deltaTime }),\n        resetControls: (animated?: boolean) =>\n          cameraRef.current?.normalizeRotations().reset(animated),\n        freeze: () => {\n          // Save the current speed\n          if (cameraRef.current.truckSpeed) {\n            cameraSpeedRef.current = cameraRef.current.truckSpeed;\n          }\n          cameraRef.current.truckSpeed = 0;\n        },\n        unFreeze: () => (cameraRef.current.truckSpeed = cameraSpeedRef.current)\n      }),\n      // eslint-disable-next-line\n      [zoomIn, zoomOut, panLeft, panRight, panDown, panUp, cameraRef.current]\n    );\n\n    useImperativeHandle(ref, () => values);\n\n    return (\n      <CameraControlsContext.Provider value={values}>\n        <threeCameraControls\n          ref={controls => {\n            cameraRef.current = controls;\n            if (!controlMounted) {\n              // Update the state when the controls are mounted to notify about it component that using that controls\n              setControlMounted(true);\n            }\n          }}\n          args={[camera, gl.domElement]}\n          smoothTime={0.1}\n          minDistance={minDistance}\n          dollyToCursor\n          maxDistance={maxDistance}\n        />\n        {children}\n      </CameraControlsContext.Provider>\n    );\n  }\n);\n","import type { PerspectiveCamera } from 'three';\n\nimport type { InternalGraphPosition } from '../types';\n\n/**\n * Get the visible height at the z depth.\n * Ref: https://discourse.threejs.org/t/functions-to-calculate-the-visible-width-height-at-a-given-z-depth-from-a-perspective-camera/269\n */\nfunction visibleHeightAtZDepth(depth: number, camera: PerspectiveCamera) {\n  // compensate for cameras not positioned at z=0\n  const cameraOffset = camera.position.z;\n  if (depth < cameraOffset) depth -= cameraOffset;\n  else depth += cameraOffset;\n\n  // vertical fov in radians\n  const vFOV = ((camera.fov / camera.zoom) * Math.PI) / 180;\n\n  // Math.abs to ensure the result is always positive\n  return 2 * Math.tan(vFOV / 2) * Math.abs(depth);\n}\n\n/**\n * Get the visible width at the z depth.\n */\nfunction visibleWidthAtZDepth(depth: number, camera: PerspectiveCamera) {\n  const height = visibleHeightAtZDepth(depth, camera);\n  return height * camera.aspect;\n}\n\n/**\n * Returns whether the node is in view of the camera.\n */\nexport function isNodeInView(\n  camera: PerspectiveCamera,\n  nodePosition: InternalGraphPosition\n): boolean {\n  const visibleWidth = visibleWidthAtZDepth(1, camera);\n  const visibleHeight = visibleHeightAtZDepth(1, camera);\n\n  // The boundary coordinates of the area visible to the camera relative to the scene\n  const visibleArea = {\n    x0: camera?.position?.x - visibleWidth / 2,\n    x1: camera?.position?.x + visibleWidth / 2,\n    y0: camera?.position?.y - visibleHeight / 2,\n    y1: camera?.position?.y + visibleHeight / 2\n  };\n\n  return (\n    nodePosition?.x > visibleArea.x0 &&\n    nodePosition?.x < visibleArea.x1 &&\n    nodePosition?.y > visibleArea.y0 &&\n    nodePosition?.y < visibleArea.y1\n  );\n}\n\n/**\n * Get the closest axis to a given angle.\n */\nexport function getClosestAxis(angle: number, axes: number[]) {\n  return axes.reduce((prev, curr) =>\n    Math.abs(curr - (angle % Math.PI)) < Math.abs(prev - (angle % Math.PI))\n      ? curr\n      : prev\n  );\n}\n\n/**\n * Get how far an angle is from the closest 2D axis in radians.\n */\nexport function getDegreesToClosest2dAxis(\n  horizontalAngle: number,\n  verticalAngle: number\n) {\n  const closestHorizontalAxis = getClosestAxis(horizontalAngle, [0, Math.PI]);\n  const closestVerticalAxis = getClosestAxis(verticalAngle, [\n    Math.PI / 2,\n    (3 * Math.PI) / 2\n  ]);\n\n  return {\n    horizontalRotation: closestHorizontalAxis - (horizontalAngle % Math.PI),\n    verticalRotation: closestVerticalAxis - (verticalAngle % Math.PI)\n  };\n}\n","import type { GraphEdge, GraphNode } from '../types';\n\ninterface GetHiddenChildrenInput {\n  nodeId: string;\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  currentHiddenNodes: GraphNode[];\n  currentHiddenEdges: GraphEdge[];\n}\n\ninterface GetVisibleIdsInput {\n  collapsedIds: string[];\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n\ninterface GetExpandPathInput {\n  nodeId: string;\n  edges: GraphEdge[];\n  visibleEdgeIds: string[];\n}\n\n/**\n * Get the children of a node id that is hidden.\n */\nfunction getHiddenChildren({\n  nodeId,\n  nodes,\n  edges,\n  currentHiddenNodes,\n  currentHiddenEdges\n}: GetHiddenChildrenInput) {\n  const hiddenNodes: GraphNode[] = [];\n  const hiddenEdges: GraphEdge[] = [];\n  const curHiddenNodeIds = currentHiddenNodes.map(n => n.id);\n  const curHiddenEdgeIds = currentHiddenEdges.map(e => e.id);\n\n  const outboundEdges = edges.filter(l => l.source === nodeId);\n  const outboundEdgeNodeIds = outboundEdges.map(l => l.target);\n\n  hiddenEdges.push(...outboundEdges);\n  for (const outboundEdgeNodeId of outboundEdgeNodeIds) {\n    const incomingEdges = edges.filter(\n      l => l.target === outboundEdgeNodeId && l.source !== nodeId\n    );\n    let hideNode = false;\n\n    // Check to see if any other edge is coming into this node\n    if (incomingEdges.length === 0) {\n      hideNode = true;\n    } else if (\n      incomingEdges.length > 0 &&\n      !curHiddenNodeIds.includes(outboundEdgeNodeId)\n    ) {\n      // If all inbound links are hidden, hide this node as well\n      const inboundNodeLinkIds = incomingEdges.map(l => l.id);\n      if (inboundNodeLinkIds.every(i => curHiddenEdgeIds.includes(i))) {\n        hideNode = true;\n      }\n    }\n    if (hideNode) {\n      // Need to hide this node and any children of this node\n      const node = nodes.find(n => n.id === outboundEdgeNodeId);\n      if (node) {\n        hiddenNodes.push(node);\n      }\n      const nested = getHiddenChildren({\n        nodeId: outboundEdgeNodeId,\n        nodes,\n        edges,\n        currentHiddenEdges: hiddenEdges,\n        currentHiddenNodes: hiddenNodes\n      });\n      hiddenEdges.push(...nested.hiddenEdges);\n      hiddenNodes.push(...nested.hiddenNodes);\n    }\n  }\n\n  const uniqueEdges: GraphEdge[] = Object.values(\n    hiddenEdges.reduce(\n      (acc, next) => ({\n        ...acc,\n        [next.id]: next\n      }),\n      {}\n    )\n  );\n\n  const uniqueNodes: GraphNode[] = Object.values(\n    hiddenNodes.reduce(\n      (acc, next) => ({\n        ...acc,\n        [next.id]: next\n      }),\n      {}\n    )\n  );\n\n  return {\n    hiddenEdges: uniqueEdges,\n    hiddenNodes: uniqueNodes\n  };\n}\n\n/**\n * Get the visible nodes and edges given a collapsed set of ids.\n */\nexport const getVisibleEntities = ({\n  collapsedIds,\n  nodes,\n  edges\n}: GetVisibleIdsInput) => {\n  const curHiddenNodes = [];\n  const curHiddenEdges = [];\n\n  for (const collapsedId of collapsedIds) {\n    const { hiddenEdges, hiddenNodes } = getHiddenChildren({\n      nodeId: collapsedId,\n      nodes,\n      edges,\n      currentHiddenEdges: curHiddenEdges,\n      currentHiddenNodes: curHiddenNodes\n    });\n\n    curHiddenNodes.push(...hiddenNodes);\n    curHiddenEdges.push(...hiddenEdges);\n  }\n\n  const hiddenNodeIds = curHiddenNodes.map(n => n.id);\n  const hiddenEdgeIds = curHiddenEdges.map(e => e.id);\n  const visibleNodes = nodes.filter(n => !hiddenNodeIds.includes(n.id));\n  const visibleEdges = edges.filter(e => !hiddenEdgeIds.includes(e.id));\n\n  return {\n    visibleNodes,\n    visibleEdges\n  };\n};\n\n/**\n * Get the path to expand a node.\n */\nexport const getExpandPath = ({\n  nodeId,\n  edges,\n  visibleEdgeIds\n}: GetExpandPathInput) => {\n  const parentIds = [];\n  const inboundEdges = edges.filter(l => l.target === nodeId);\n  const inboundEdgeIds = inboundEdges.map(e => e.id);\n  const hasVisibleInboundEdge = inboundEdgeIds.some(id =>\n    visibleEdgeIds.includes(id)\n  );\n\n  if (hasVisibleInboundEdge) {\n    // If there is a visible edge to this node, that means the node is\n    // visible so no parents need to be expanded\n    return parentIds;\n  }\n\n  const inboundEdgeNodeIds = inboundEdges.map(l => l.source);\n  let addedParent = false;\n\n  for (const inboundNodeId of inboundEdgeNodeIds) {\n    if (!addedParent) {\n      // Only want to expand a single path to the node, so if there\n      // are multiple hidden incoming edges, only expand the first\n      // to reduce how many nodes are expanded to get to the node\n      parentIds.push(\n        ...[\n          inboundNodeId,\n          ...getExpandPath({ nodeId: inboundNodeId, edges, visibleEdgeIds })\n        ]\n      );\n      addedParent = true;\n    }\n  }\n\n  return parentIds;\n};\n","import { useCallback } from 'react';\n\nimport type { GraphEdge, GraphNode } from '../types';\nimport { getExpandPath, getVisibleEntities } from './utils';\n\nexport interface UseCollapseProps {\n  /**\n   * Current collapsed node ids.\n   */\n  collapsedNodeIds?: string[];\n\n  /**\n   * Node data.\n   */\n  nodes?: GraphNode[];\n\n  /**\n   * Edge data.\n   */\n  edges?: GraphEdge[];\n}\n\nexport interface CollpaseResult {\n  /**\n   * Determine if a node is currently collapsed\n   */\n  getIsCollapsed: (nodeId: string) => boolean;\n\n  /**\n   * Return a list of ids required to expand in order to view the provided node\n   */\n  getExpandPathIds: (nodeId: string) => string[];\n}\n\nexport const useCollapse = ({\n  collapsedNodeIds = [],\n  nodes = [],\n  edges = []\n}: UseCollapseProps): CollpaseResult => {\n  const getIsCollapsed = useCallback(\n    (nodeId: string) => {\n      const { visibleNodes } = getVisibleEntities({\n        nodes,\n        edges,\n        collapsedIds: collapsedNodeIds\n      });\n      const visibleNodeIds = visibleNodes.map(n => n.id);\n\n      return !visibleNodeIds.includes(nodeId);\n    },\n    [collapsedNodeIds, edges, nodes]\n  );\n\n  const getExpandPathIds = useCallback(\n    (nodeId: string) => {\n      const { visibleEdges } = getVisibleEntities({\n        nodes,\n        edges,\n        collapsedIds: collapsedNodeIds\n      });\n      const visibleEdgeIds = visibleEdges.map(e => e.id);\n\n      return getExpandPath({ nodeId, edges, visibleEdgeIds });\n    },\n    [collapsedNodeIds, edges, nodes]\n  );\n\n  return {\n    getIsCollapsed,\n    getExpandPathIds\n  };\n};\n","import { useThree } from '@react-three/fiber';\nimport { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport type { PerspectiveCamera } from 'three';\nimport { Box3, Vector3 } from 'three';\n\nimport { useCameraControls } from '../CameraControls/useCameraControls';\nimport {\n  getDegreesToClosest2dAxis,\n  isNodeInView\n} from '../CameraControls/utils';\nimport type { LayoutTypes } from '../layout/types';\nimport { useStore } from '../store';\nimport type { InternalGraphNode } from '../types';\nimport { getLayoutCenter } from '../utils/layout';\n\nconst PADDING = 50;\n\nexport interface CenterNodesParams {\n  animated?: boolean;\n  centerOnlyIfNodesNotInView?: boolean;\n}\n\nexport interface FitNodesParams {\n  animated?: boolean;\n  fitOnlyIfNodesNotInView?: boolean;\n}\n\nexport interface CenterGraphInput {\n  /**\n   * Whether the animate the transition or not.\n   */\n  animated?: boolean;\n\n  /**\n   * Whether the center graph function is disabled or not.\n   */\n  disabled?: boolean;\n\n  /**\n   * The layout type of the graph used to determine rotation logic.\n   */\n  layoutType: LayoutTypes;\n}\n\nexport interface CenterGraphOutput {\n  /**\n   * Centers the graph on a specific node or list of nodes.\n   *\n   * @param nodes - An array of `InternalGraphNode` objects to center the graph on. If this parameter is omitted,\n   * the graph will be centered on all nodes.\n   *\n   * @param animated - A boolean flag that determines whether the centering action should be animated.\n   *\n   * @param centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\n   * only be centered if the nodes specified by `nodes` are not currently in view. If this\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\n   * specified by `nodes` are not currently visible in the viewport. If this parameter is\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\n   * are currently in view.\n   */\n  centerNodes: (nodes: InternalGraphNode[], opts: CenterNodesParams) => void;\n\n  /**\n   * Centers the graph on a specific node or list of nodes.\n   *\n   * @param nodeIds - An array of node IDs to center the graph on. If this parameter is omitted,\n   * the graph will be centered on all nodes.\n   *\n   * @param opts.centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\n   * only be centered if the nodes specified by `ids` are not currently in view. If this\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\n   * specified by `ids` are not currently in view. If this parameter is\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\n   * are currently in view.\n   */\n  centerNodesById: (nodeIds: string[], opts?: CenterNodesParams) => void;\n\n  /**\n   * Fit all the given nodes into view of the camera.\n   *\n   * @param nodeIds - An array of node IDs to fit the view on. If this parameter is omitted,\n   * the view will fit to all nodes.\n   *\n   * @param opts.fitOnlyIfNodesNotInView - A boolean flag that determines whether the view should\n   * only be fit if the nodes specified by `ids` are not currently in view. If this\n   * parameter is `true`, the view will only be fit if one or more of the nodes\n   * specified by `ids` are not currently visible in the viewport. If this parameter is\n   * `false` or omitted, the view will be fit regardless of whether the nodes\n   * are currently in view.\n   */\n  fitNodesInViewById: (nodeIds: string[], opts?: FitNodesParams) => void;\n\n  /**\n   * Whether the graph is centered or not.\n   */\n  isCentered?: boolean;\n}\n\nexport const useCenterGraph = ({\n  animated,\n  disabled,\n  layoutType\n}: CenterGraphInput): CenterGraphOutput => {\n  const nodes = useStore(state => state.nodes);\n  const [isCentered, setIsCentered] = useState<boolean>(false);\n  const invalidate = useThree(state => state.invalidate);\n  const { controls } = useCameraControls();\n  const camera = useThree(state => state.camera) as PerspectiveCamera;\n  const mounted = useRef<boolean>(false);\n\n  const centerNodes = useCallback(\n    async (nodes, opts?: CenterNodesParams) => {\n      const animated = opts?.animated !== undefined ? opts?.animated : true;\n      const centerOnlyIfNodesNotInView =\n        opts?.centerOnlyIfNodesNotInView !== undefined\n          ? opts?.centerOnlyIfNodesNotInView\n          : false;\n\n      if (\n        !mounted.current ||\n        !centerOnlyIfNodesNotInView ||\n        (centerOnlyIfNodesNotInView &&\n          nodes?.some(node => !isNodeInView(camera, node.position)))\n      ) {\n        // Centers the graph based on the central most node\n        const { x, y, z } = getLayoutCenter(nodes);\n\n        await controls.normalizeRotations().setTarget(x, y, z, animated);\n\n        if (!isCentered) {\n          setIsCentered(true);\n        }\n\n        invalidate();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [invalidate, controls, nodes]\n  );\n\n  const fitNodesInView = useCallback(\n    async (\n      nodes,\n      opts: FitNodesParams = { animated: true, fitOnlyIfNodesNotInView: false }\n    ) => {\n      const { fitOnlyIfNodesNotInView } = opts;\n\n      if (\n        !fitOnlyIfNodesNotInView ||\n        (fitOnlyIfNodesNotInView &&\n          nodes?.some(node => !isNodeInView(camera, node.position)))\n      ) {\n        const { minX, maxX, minY, maxY, minZ, maxZ } = getLayoutCenter(nodes);\n\n        if (!layoutType.includes('3d')) {\n          // fitToBox will auto rotate to the closest axis including the z axis,\n          // which is not desired for 2D graphs\n          // So get the rotation to the closest flat axis for 2D graphs\n          const { horizontalRotation, verticalRotation } =\n            getDegreesToClosest2dAxis(\n              controls?.azimuthAngle,\n              controls?.polarAngle\n            );\n\n          void controls?.rotate(horizontalRotation, verticalRotation, true);\n        }\n\n        await controls?.zoomTo(1, opts?.animated);\n\n        await controls?.fitToBox(\n          new Box3(\n            new Vector3(minX, minY, minZ),\n            new Vector3(maxX, maxY, maxZ)\n          ),\n          opts?.animated,\n          {\n            cover: false,\n            paddingLeft: PADDING,\n            paddingRight: PADDING,\n            paddingBottom: PADDING,\n            paddingTop: PADDING\n          }\n        );\n      }\n    },\n    [camera, controls, layoutType]\n  );\n\n  const getNodesById = useCallback(\n    (nodeIds: string[]) => {\n      let mappedNodes: InternalGraphNode[] | null = null;\n\n      if (nodeIds?.length) {\n        // Map the node ids to the actual nodes\n        mappedNodes = nodeIds.reduce((acc, id) => {\n          const node = nodes.find(n => n.id === id);\n          if (node) {\n            acc.push(node);\n          } else {\n            throw new Error(\n              `Attempted to center ${id} but it was not found in the nodes`\n            );\n          }\n\n          return acc;\n        }, []);\n      }\n\n      return mappedNodes;\n    },\n    [nodes]\n  );\n\n  const centerNodesById = useCallback(\n    (nodeIds: string[], opts: CenterNodesParams) => {\n      const mappedNodes = getNodesById(nodeIds);\n\n      centerNodes(mappedNodes || nodes, {\n        animated,\n        centerOnlyIfNodesNotInView: opts?.centerOnlyIfNodesNotInView\n      });\n    },\n    [animated, centerNodes, getNodesById, nodes]\n  );\n\n  const fitNodesInViewById = useCallback(\n    async (nodeIds: string[], opts: FitNodesParams) => {\n      const mappedNodes = getNodesById(nodeIds);\n\n      await fitNodesInView(mappedNodes || nodes, { animated, ...opts });\n    },\n    [animated, fitNodesInView, getNodesById, nodes]\n  );\n\n  useLayoutEffect(() => {\n    async function load() {\n      // Once we've loaded controls and we have nodes, let's recenter\n      if (controls && nodes?.length) {\n        if (!mounted.current) {\n          // Center the graph once nodes are loaded on mount\n          await centerNodes(nodes, { animated: false });\n          await fitNodesInView(nodes, { animated: false });\n          mounted.current = true;\n        }\n      }\n    }\n\n    load();\n  }, [controls, centerNodes, nodes, animated, camera, fitNodesInView]);\n\n  return { centerNodes, centerNodesById, fitNodesInViewById, isCentered };\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { FC } from 'react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport type { ColorRepresentation, Mesh } from 'three';\nimport { Color, DoubleSide, Vector3 } from 'three';\n\nimport { useStore } from '../store';\nimport { animationConfig } from '../utils';\n\nexport type EdgeArrowPosition = 'none' | 'mid' | 'end';\n\nexport interface ArrowProps {\n  /**\n   * Whether the arrow should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * The color of the arrow.\n   */\n  color?: ColorRepresentation;\n\n  /**\n   * The length of the arrow.\n   */\n  length: number;\n\n  /**\n   * The opacity of the arrow.\n   */\n  opacity?: number;\n\n  /**\n   * The position of the arrow in 3D space.\n   */\n  position: Vector3;\n\n  /**\n   * The rotation of the arrow in 3D space.\n   */\n  rotation: Vector3;\n\n  /**\n   * The size of the arrow.\n   */\n  size: number;\n\n  /**\n   * A function that is called when the arrow is right-clicked.\n   */\n  onContextMenu?: () => void;\n\n  /**\n   * A function that is called when the arrow is selected or deselected.\n   */\n  onActive?: (state: boolean) => void;\n}\n\nexport const Arrow: FC<ArrowProps> = ({\n  animated,\n  color = '#D8E6EA',\n  length,\n  opacity = 0.5,\n  position,\n  rotation,\n  size = 1,\n  onActive,\n  onContextMenu\n}) => {\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n  const meshRef = useRef<Mesh | null>(null);\n  const isDragging = useStore(state => state.draggingIds.length > 0);\n  const center = useStore(state => state.centerPosition);\n\n  const [{ pos, arrowOpacity }] = useSpring(\n    () => ({\n      from: {\n        pos: center ? [center.x, center.y, center.z] : [0, 0, 0],\n        arrowOpacity: 0\n      },\n      to: {\n        pos: [position.x, position.y, position.z],\n        arrowOpacity: opacity\n      },\n      config: {\n        ...animationConfig,\n        duration: animated && !isDragging ? undefined : 0\n      }\n    }),\n    [animated, isDragging, opacity, position]\n  );\n\n  const setQuaternion = useCallback(() => {\n    const axis = new Vector3(0, 1, 0);\n    meshRef.current?.quaternion.setFromUnitVectors(axis, rotation);\n  }, [rotation, meshRef]);\n\n  useEffect(() => setQuaternion(), [setQuaternion]);\n\n  return (\n    <a.mesh\n      position={pos as any}\n      ref={meshRef}\n      scale={[1, 1, 1]}\n      onPointerOver={() => onActive(true)}\n      onPointerOut={() => onActive(false)}\n      // context menu controls\n      onPointerDown={event => {\n        if (event.nativeEvent.buttons === 2) {\n          event.stopPropagation();\n        }\n      }}\n      onContextMenu={event => {\n        event.nativeEvent.preventDefault();\n        event.stopPropagation();\n        onContextMenu();\n      }}\n    >\n      <cylinderGeometry\n        args={[0, size, length, 20, 1, true]}\n        attach=\"geometry\"\n      />\n      <a.meshBasicMaterial\n        attach=\"material\"\n        color={normalizedColor}\n        depthTest={false}\n        opacity={arrowOpacity}\n        transparent={true}\n        side={DoubleSide}\n        fog={true}\n      />\n    </a.mesh>\n  );\n};\n","import { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\nimport { useMemo } from 'react';\nimport { Plane, Vector2, Vector3 } from 'three';\n\nimport type { InternalGraphPosition } from '../types';\nimport type { CenterPositionVector } from '../utils/layout';\n\ninterface DragParams {\n  draggable: boolean;\n  position: InternalGraphPosition;\n  bounds?: CenterPositionVector;\n  set: (position: Vector3) => void;\n  onDragStart: () => void;\n  onDragEnd: () => void;\n}\n\nexport const useDrag = ({\n  draggable,\n  set,\n  position,\n  bounds,\n  onDragStart,\n  onDragEnd\n}: DragParams) => {\n  const camera = useThree(state => state.camera);\n  const raycaster = useThree(state => state.raycaster);\n  const size = useThree(state => state.size);\n  const gl = useThree(state => state.gl);\n\n  // Reference: https://codesandbox.io/s/react-three-draggable-cxu37\n  const { mouse2D, mouse3D, offset, normal, plane } = useMemo(\n    () => ({\n      // Normalized 2D screen space mouse coords\n      mouse2D: new Vector2(),\n      // 3D world space mouse coords\n      mouse3D: new Vector3(),\n      // Drag point offset from object origin\n      offset: new Vector3(),\n      // Normal of the drag plane\n      normal: new Vector3(),\n      // Drag plane\n      plane: new Plane()\n    }),\n    []\n  );\n\n  const clientRect = useMemo(\n    () => gl.domElement.getBoundingClientRect(),\n    // Size dependency ensures the clientRect updates when container dimensions change.\n    // Without it, drag calculations would use stale positioning data from the previous container size.\n    [gl.domElement, size]\n  );\n\n  return useGesture(\n    {\n      onDragStart: ({ event }) => {\n        // @ts-ignore\n        const { eventObject, point } = event;\n\n        // Save the offset of click point from object origin\n        offset.setFromMatrixPosition(eventObject.matrixWorld).sub(point);\n\n        // Set initial 3D cursor position (needed for onDrag plane calculation)\n        mouse3D.copy(point);\n\n        // Run user callback\n        onDragStart();\n      },\n      onDrag: ({ xy, buttons, cancel }) => {\n        // If the left mouse button is not pressed, cancel the drag\n        if (buttons !== 1) {\n          cancel();\n          return;\n        }\n        // Compute normalized mouse coordinates (screen space)\n        const nx = ((xy[0] - (clientRect?.left ?? 0)) / size.width) * 2 - 1;\n        const ny = -((xy[1] - (clientRect?.top ?? 0)) / size.height) * 2 + 1;\n\n        // Unlike the mouse from useThree, this works offscreen\n        mouse2D.set(nx, ny);\n\n        // Update raycaster (otherwise it doesn't track offscreen)\n        raycaster.setFromCamera(mouse2D, camera);\n\n        // The drag plane is normal to the camera view\n        camera.getWorldDirection(normal).negate();\n\n        // Find the plane that's normal to the camera and contains our drag point\n        plane.setFromNormalAndCoplanarPoint(normal, mouse3D);\n\n        // Find the point of intersection\n        raycaster.ray.intersectPlane(plane, mouse3D);\n\n        // Update the object position with the original offset\n        const updated = new Vector3(position.x, position.y, position.z)\n          .copy(mouse3D)\n          .add(offset);\n\n        // If there's a cluster, clamp the position within its circular bounds\n        if (bounds) {\n          const center = new Vector3(\n            (bounds.minX + bounds.maxX) / 2,\n            (bounds.minY + bounds.maxY) / 2,\n            (bounds.minZ + bounds.maxZ) / 2\n          );\n          const radius = (bounds.maxX - bounds.minX) / 2;\n\n          // Calculate direction from center to updated position\n          const direction = updated.clone().sub(center);\n          const distance = direction.length();\n\n          // If outside the circle, clamp to the circle's edge\n          if (distance > radius) {\n            direction.normalize().multiplyScalar(radius);\n            updated.copy(center).add(direction);\n          }\n        }\n\n        return set(updated);\n      },\n      onDragEnd\n    },\n    { drag: { enabled: draggable, threshold: 10 } }\n  );\n};\n","import type { ThreeEvent } from '@react-three/fiber';\nimport { useCallback, useRef } from 'react';\n\nexport interface HoverIntentOptions {\n  interval?: number;\n  sensitivity?: number;\n  timeout?: number;\n  disabled?: boolean;\n  onPointerOver: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerOut: (event: ThreeEvent<PointerEvent>) => void;\n}\n\nexport interface HoverIntentResult {\n  pointerOut: (event: ThreeEvent<PointerEvent>) => void;\n  pointerOver: (event: ThreeEvent<PointerEvent>) => void;\n}\n\n/**\n * Hover intent identifies if the user actually is\n * intending to over by measuring the position of the mouse\n * once a pointer enters and determining if in a duration if\n * the mouse moved inside a certain threshold and fires the events.\n */\nexport const useHoverIntent = ({\n  sensitivity = 7,\n  interval = 50,\n  timeout = 0,\n  disabled,\n  onPointerOver,\n  onPointerOut\n}: HoverIntentOptions | undefined): HoverIntentResult => {\n  const mouseOver = useRef<boolean>(false);\n  const timer = useRef<any | null>(null);\n  const state = useRef<number>(0);\n  const coords = useRef({\n    x: null,\n    y: null,\n    px: null,\n    py: null\n  });\n\n  const onMouseMove = useCallback((event: MouseEvent) => {\n    coords.current.x = event.clientX;\n    coords.current.y = event.clientY;\n  }, []);\n\n  const comparePosition = useCallback(\n    (event: ThreeEvent<PointerEvent>) => {\n      timer.current = clearTimeout(timer.current);\n      const { px, x, py, y } = coords.current;\n\n      if (Math.abs(px - x) + Math.abs(py - y) < sensitivity) {\n        state.current = 1;\n        onPointerOver(event);\n      } else {\n        coords.current.px = x;\n        coords.current.py = y;\n        timer.current = setTimeout(() => comparePosition(event), interval);\n      }\n    },\n    [interval, onPointerOver, sensitivity]\n  );\n\n  const cleanup = useCallback(() => {\n    clearTimeout(timer.current);\n    if (typeof window !== 'undefined') {\n      document.removeEventListener('mousemove', onMouseMove, false);\n    }\n  }, [onMouseMove]);\n\n  const pointerOver = useCallback(\n    (event: ThreeEvent<PointerEvent>) => {\n      if (!disabled) {\n        mouseOver.current = true;\n        cleanup();\n\n        if (state.current !== 1) {\n          coords.current.px = event.pointer.x;\n          coords.current.py = event.pointer.y;\n\n          if (typeof window !== 'undefined') {\n            document.addEventListener('mousemove', onMouseMove, false);\n          }\n\n          timer.current = setTimeout(() => comparePosition(event), timeout);\n        }\n      }\n    },\n    [cleanup, comparePosition, disabled, onMouseMove, timeout]\n  );\n\n  const delay = useCallback(\n    (event: ThreeEvent<PointerEvent>) => {\n      timer.current = clearTimeout(timer.current);\n      state.current = 0;\n      onPointerOut(event);\n    },\n    [onPointerOut]\n  );\n\n  const pointerOut = useCallback(\n    (event: ThreeEvent<PointerEvent>) => {\n      mouseOver.current = false;\n      cleanup();\n\n      if (state.current === 1) {\n        timer.current = setTimeout(() => delay(event), timeout);\n      }\n    },\n    [cleanup, delay, timeout]\n  );\n\n  return {\n    pointerOver,\n    pointerOut\n  };\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { FC } from 'react';\nimport React from 'react';\nimport type { Color } from 'three';\nimport { DoubleSide } from 'three';\n\nimport type { Theme } from '../../themes';\nimport { animationConfig } from '../../utils';\n\nexport interface RingProps {\n  outerRadius: number;\n  innerRadius: number;\n  padding: number;\n  normalizedFill: Color;\n  normalizedStroke: Color;\n  opacity: number;\n  animated: boolean;\n  theme: Theme;\n}\n\nexport const Ring: FC<RingProps> = ({\n  outerRadius,\n  innerRadius,\n  padding,\n  normalizedFill,\n  normalizedStroke,\n  opacity,\n  animated,\n  theme\n}) => {\n  const { opacity: springOpacity } = useSpring({\n    from: { opacity: 0 },\n    to: { opacity },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  return (\n    <>\n      <mesh>\n        <ringGeometry attach=\"geometry\" args={[outerRadius, 0, 128]} />\n        <a.meshBasicMaterial\n          attach=\"material\"\n          color={normalizedFill}\n          transparent={true}\n          depthTest={false}\n          opacity={theme.cluster?.fill ? springOpacity : 0}\n          side={DoubleSide}\n          fog={true}\n        />\n      </mesh>\n      <mesh>\n        <ringGeometry\n          attach=\"geometry\"\n          args={[outerRadius, innerRadius + padding, 128]}\n        />\n        <a.meshBasicMaterial\n          attach=\"material\"\n          color={normalizedStroke}\n          transparent={true}\n          depthTest={false}\n          opacity={springOpacity}\n          side={DoubleSide}\n          fog={true}\n        />\n      </mesh>\n    </>\n  );\n};\n","import { Billboard, RoundedBox, Text } from '@react-three/drei';\nimport ellipsize from 'ellipsize';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport type { ColorRepresentation, Euler } from 'three';\nimport { Color } from 'three';\n\nexport interface LabelProps {\n  /**\n   * Text to render.\n   */\n  text: string;\n\n  /**\n   * Font URL.\n   * Reference: https://github.com/reaviz/reagraph/issues/23\n   */\n  fontUrl?: string;\n\n  /**\n   * Size of the font.\n   */\n  fontSize?: number;\n\n  /**\n   * Color of the text.\n   */\n  color?: ColorRepresentation;\n\n  /**\n   * Stroke of the text.\n   */\n  stroke?: ColorRepresentation;\n\n  /**\n   * Background color of the label.\n   */\n  backgroundColor?: ColorRepresentation;\n\n  /**\n   * Opacity of the background.\n   */\n  backgroundOpacity?: number;\n\n  /**\n   * Padding around the text for background sizing.\n   */\n  padding?: number;\n\n  /**\n   * Color of the background stroke/border.\n   */\n  strokeColor?: ColorRepresentation;\n\n  /**\n   * Size of the background stroke/border.\n   */\n  strokeWidth?: number;\n\n  /**\n   * Corner radius of the background.\n   */\n  radius?: number;\n\n  /**\n   * Opacity for the label.\n   */\n  opacity?: number;\n\n  /**\n   * The lenth of which to start the ellipsis.\n   */\n  ellipsis?: number;\n\n  /**\n   * Whether the label is active ( dragging, hover, focus ).\n   */\n  active?: boolean;\n\n  /**\n   * Rotation of the label.\n   */\n  rotation?: Euler | [number, number, number];\n\n  /**\n   * Maximum width of the label.\n   */\n  maxWidth?: number;\n\n  /**\n   * Border radius of the label.\n   */\n  borderRadius?: number;\n\n  /**\n   * Type of the label.\n   */\n  type?: 'node' | 'edge';\n\n  /**\n   * label visible or not\n   */\n  labelVisible?: boolean;\n}\n\nexport const Label: FC<LabelProps> = ({\n  text,\n  fontSize = 7,\n  fontUrl,\n  color,\n  opacity = 1,\n  stroke,\n  backgroundColor,\n  backgroundOpacity = 1,\n  padding = 1,\n  strokeColor,\n  strokeWidth = 0,\n  radius = 0.1,\n  active,\n  rotation,\n  maxWidth = 100,\n  ellipsis = 100,\n  borderRadius,\n  labelVisible = true\n}) => {\n  const shortText = ellipsis && !active ? ellipsize(text, ellipsis) : text;\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n  const normalizedStroke = useMemo(\n    () => (stroke ? new Color(stroke) : undefined),\n    [stroke]\n  );\n  const normalizedBackgroundColor = useMemo(\n    () => (backgroundColor ? new Color(backgroundColor) : null),\n    [backgroundColor]\n  );\n  const normalizedStrokeColor = useMemo(\n    () => (strokeColor ? new Color(strokeColor) : null),\n    [strokeColor]\n  );\n  // Normalize the radius to be between 0 and 3\n  const normalizedRadius = Math.min(radius * fontSize, 3);\n\n  // Calculate background dimensions based on text and fontSize\n  const charCount = shortText.length;\n  const estimatedWidth = charCount * fontSize * 0.6 + padding * 2;\n  const estimatedHeight = fontSize * 1.2 + padding * 2;\n\n  const backgroundDimensions = {\n    width: estimatedWidth,\n    height: estimatedHeight\n  };\n\n  // Dynamic z-position based on active state\n  const zPosition = active ? 2 : 1;\n\n  return (\n    <Billboard position={[0, 0, zPosition]} renderOrder={1}>\n      {/* Stroke layer - rendered behind the background */}\n      {strokeWidth > 0 &&\n        normalizedStrokeColor &&\n        normalizedBackgroundColor && (\n          <mesh position={[0, 0, 10]}>\n            <RoundedBox\n              args={[\n                backgroundDimensions.width + strokeWidth,\n                backgroundDimensions.height + strokeWidth,\n                0.1\n              ]}\n              radius={normalizedRadius}\n              smoothness={8}\n              material-color={normalizedStrokeColor}\n              material-transparent={true}\n              material-opacity={backgroundOpacity}\n            />\n          </mesh>\n        )}\n      {/* Background layer */}\n      {normalizedBackgroundColor && (\n        <mesh position={[0, 0, 10]}>\n          <RoundedBox\n            args={[\n              backgroundDimensions.width,\n              backgroundDimensions.height,\n              0.1\n            ]}\n            radius={normalizedRadius}\n            smoothness={8}\n            material-color={normalizedBackgroundColor}\n            material-transparent={true}\n            material-opacity={backgroundOpacity}\n          />\n        </mesh>\n      )}\n      <Text\n        position={[0, 0, 11]}\n        font={fontUrl}\n        fontSize={fontSize}\n        color={normalizedColor}\n        fillOpacity={opacity}\n        textAlign=\"center\"\n        outlineWidth={stroke ? 1 : 0}\n        outlineColor={normalizedStroke}\n        depthOffset={0}\n        maxWidth={maxWidth}\n        overflowWrap=\"break-word\"\n        rotation={rotation}\n      >\n        {shortText}\n      </Text>\n    </Billboard>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport { useCursor } from '@react-three/drei';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport type { FC } from 'react';\nimport React, { useMemo, useState } from 'react';\nimport type { Vector3 } from 'three';\nimport { Color } from 'three';\n\nimport { useCameraControls } from '../CameraControls/useCameraControls';\nimport { useStore } from '../store';\nimport type { ClusterRenderer } from '../types';\nimport type { ClusterGroup } from '../utils';\nimport { animationConfig } from '../utils';\nimport { useDrag } from '../utils/useDrag';\nimport { useHoverIntent } from '../utils/useHoverIntent';\nimport { Ring } from './clusters/Ring';\nimport { Label } from './Label';\n\nexport type ClusterEventArgs = Omit<ClusterGroup, 'position'>;\n\nexport interface ClusterProps extends ClusterGroup {\n  /**\n   * Whether the circle should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * The radius of the circle. Default 1.\n   */\n  radius?: number;\n\n  /**\n   * The padding of the circle. Default 20.\n   */\n  padding?: number;\n\n  /**\n   * The url for the label font.\n   */\n  labelFontUrl?: string;\n\n  /**\n   * Whether the node is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * When the cluster was clicked.\n   */\n  onClick?: (cluster: ClusterEventArgs, event: ThreeEvent<MouseEvent>) => void;\n\n  /**\n   * When a cluster receives a pointer over event.\n   */\n  onPointerOver?: (\n    cluster: ClusterEventArgs,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * When cluster receives a pointer leave event.\n   */\n  onPointerOut?: (\n    cluster: ClusterEventArgs,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * Whether the cluster is draggable\n   */\n  draggable?: boolean;\n\n  /**\n   * Triggered after a cluster was dragged\n   */\n  onDragged?: (cluster: ClusterEventArgs) => void;\n\n  /**\n   * Render a custom cluster label\n   */\n  onRender?: ClusterRenderer;\n}\n\nexport const Cluster: FC<ClusterProps> = ({\n  animated,\n  position,\n  padding = 40,\n  labelFontUrl,\n  disabled,\n  radius = 2,\n  nodes,\n  label,\n  onClick,\n  onPointerOver,\n  onPointerOut,\n  draggable = false,\n  onDragged,\n  onRender\n}) => {\n  const theme = useStore(state => state.theme);\n  const rad = Math.max(position.width, position.height) / 2;\n  const offset = rad - radius + padding;\n  const [active, setActive] = useState<boolean>(false);\n  const center = useStore(state => state.centerPosition);\n  const nodesState = useStore(state => state.nodes);\n  const cameraControls = useCameraControls();\n  const draggingIds = useStore(state => state.draggingIds);\n  const isDraggingCurrent = draggingIds.includes(label);\n  const isDragging = draggingIds.length > 0;\n\n  const isActive = useStore(state =>\n    state.actives?.some(id => nodes.some(n => n.id === id))\n  );\n  const hoveredNodeId = useStore(state => state.hoveredNodeId);\n\n  const isSelected = useStore(state =>\n    state.selections?.some(id => nodes.some(n => n.id === id))\n  );\n\n  const hasSelections = useStore(state => state.selections?.length > 0);\n\n  const opacity = hasSelections\n    ? isSelected || active || isActive\n      ? theme.cluster?.selectedOpacity\n      : theme.cluster?.inactiveOpacity\n    : theme.cluster?.opacity;\n\n  const labelPosition: [number, number, number] = useMemo(() => {\n    const defaultPosition: [number, number, number] = [0, -offset, 2];\n    const themeOffset = theme.cluster?.label?.offset;\n    if (themeOffset) {\n      return [\n        defaultPosition[0] - themeOffset[0],\n        defaultPosition[1] - themeOffset[1],\n        defaultPosition[2] - themeOffset[2]\n      ];\n    }\n\n    return defaultPosition;\n  }, [offset, theme.cluster?.label?.offset]);\n\n  const { circlePosition } = useSpring({\n    from: {\n      circlePosition: [center.x, center.y, -1] as [number, number, number]\n    },\n    to: {\n      circlePosition: position\n        ? ([position.x, position.y, -1] as [number, number, number])\n        : ([0, 0, -1] as [number, number, number])\n    },\n    config: {\n      ...animationConfig,\n      duration: animated && !isDragging ? undefined : 0\n    }\n  });\n\n  const normalizedStroke = useMemo(\n    () => new Color(theme.cluster?.stroke),\n    [theme.cluster?.stroke]\n  );\n\n  const normalizedFill = useMemo(\n    () => new Color(theme.cluster?.fill),\n    [theme.cluster?.fill]\n  );\n\n  const addDraggingId = useStore(state => state.addDraggingId);\n  const removeDraggingId = useStore(state => state.removeDraggingId);\n  const setClusterPosition = useStore(state => state.setClusterPosition);\n\n  // Define the drag event handlers for the cluster\n  const bind = useDrag({\n    draggable: draggable && !hoveredNodeId,\n    position: {\n      x: position.x,\n      y: position.y,\n      z: -1\n    } as any,\n    set: (pos: Vector3) => setClusterPosition(label, pos as any),\n    onDragStart: () => {\n      addDraggingId(label);\n      setActive(true);\n    },\n    onDragEnd: () => {\n      removeDraggingId(label);\n      setActive(false);\n      // Get nodes from store with updated position after dragging\n      const updatedClusterNodes = nodesState.filter(n => n.cluster === label);\n      onDragged?.({ nodes: updatedClusterNodes, label });\n    }\n  });\n\n  // Set the cursor to pointer when the cluster is active and not dragging\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\n  // Set the cursor to grab when the cluster is active and draggable\n  useCursor(\n    active && draggable && !isDraggingCurrent && onClick === undefined,\n    'grab'\n  );\n  // Set the cursor to grabbing when the cluster is dragging\n  useCursor(isDraggingCurrent, 'grabbing');\n\n  const { pointerOver, pointerOut } = useHoverIntent({\n    disabled,\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\n      setActive(true);\n      cameraControls.freeze();\n      onPointerOver?.(\n        {\n          nodes,\n          label\n        },\n        event\n      );\n    },\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\n      setActive(false);\n      cameraControls.unFreeze();\n      onPointerOut?.(\n        {\n          nodes,\n          label\n        },\n        event\n      );\n    }\n  });\n\n  const cluster = useMemo(\n    () =>\n      theme.cluster && (\n        <a.group\n          userData={{ id: label, type: 'cluster' }}\n          position={circlePosition as any}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n          onClick={(event: ThreeEvent<MouseEvent>) => {\n            if (!disabled && !isDraggingCurrent) {\n              onClick?.({ nodes, label }, event);\n            }\n          }}\n          {...(bind() as any)}\n        >\n          {onRender ? (\n            onRender({\n              label: {\n                position: labelPosition,\n                text: label,\n                opacity: opacity,\n                fontUrl: labelFontUrl\n              },\n              opacity,\n              outerRadius: offset,\n              innerRadius: rad,\n              padding,\n              theme\n            })\n          ) : (\n            <>\n              <Ring\n                outerRadius={offset}\n                innerRadius={rad}\n                padding={padding}\n                normalizedFill={normalizedFill}\n                normalizedStroke={normalizedStroke}\n                opacity={opacity}\n                animated={animated}\n                theme={theme}\n              />\n              {theme.cluster?.label && (\n                <a.group position={labelPosition}>\n                  <Label\n                    text={label}\n                    opacity={opacity}\n                    fontUrl={labelFontUrl}\n                    stroke={theme.cluster.label.stroke}\n                    active={false}\n                    color={theme.cluster?.label.color}\n                    fontSize={theme.cluster?.label.fontSize ?? 12}\n                    ellipsis={theme.cluster.label.ellipsis}\n                    backgroundColor={theme.cluster.label.backgroundColor}\n                    borderRadius={theme.cluster.label.borderRadius}\n                  />\n                </a.group>\n              )}\n            </>\n          )}\n        </a.group>\n      ),\n    [\n      theme,\n      circlePosition,\n      pointerOver,\n      pointerOut,\n      offset,\n      normalizedFill,\n      rad,\n      padding,\n      normalizedStroke,\n      labelPosition,\n      label,\n      opacity,\n      labelFontUrl,\n      disabled,\n      onClick,\n      nodes,\n      bind,\n      isDraggingCurrent,\n      onRender,\n      animated\n    ]\n  );\n\n  return cluster;\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport type { ColorRepresentation } from 'three';\nimport { Color } from 'three';\nimport { animationConfig } from 'utils/animation';\n\nexport interface SelfLoopProps {\n  /**\n   * The unique identifier of the edge.\n   */\n  id: string;\n\n  /**\n   * The color of the edge.\n   */\n  curve: any;\n\n  /**\n   * The size of the edge.\n   */\n  size: number;\n\n  /**\n   * The color of the edge.\n   */\n  color?: ColorRepresentation;\n\n  /**\n   * The opacity of the edge.\n   */\n  opacity: number;\n\n  /**\n   * Whether the edge is animated.\n   */\n  animated?: boolean;\n\n  /**\n   * A function that is called when the mouse pointer is moved over the line.\n   */\n  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;\n\n  /**\n   * A function that is called when the mouse pointer is moved out of the line.\n   */\n  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;\n\n  /**\n   * A function that is called when the line is clicked.\n   */\n  onClick?: (event: ThreeEvent<MouseEvent>) => void;\n\n  /**\n   * A function that is called when the line is right-clicked.\n   */\n  onContextMenu?: () => void;\n}\n\nexport const SelfLoop: FC<SelfLoopProps> = ({\n  id,\n  curve,\n  opacity = 1,\n  size = 1,\n  color = '#000',\n  animated,\n  onPointerOver,\n  onPointerOut,\n  onClick,\n  onContextMenu\n}) => {\n  const { scale, loopOpacity } = useSpring({\n    from: {\n      // Note: This prevents incorrect scaling w/ 0\n      scale: [0.00001, 0.00001, 0.00001],\n      loopOpacity: 0\n    },\n    to: {\n      scale: [size, size, size],\n      loopOpacity: opacity\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n\n  return (\n    <a.mesh\n      userData={{ id, type: 'edge' }}\n      renderOrder={-1}\n      onPointerOver={onPointerOver}\n      onPointerOut={onPointerOut}\n      onClick={onClick}\n      onPointerDown={event => {\n        if (event.nativeEvent.buttons === 2) {\n          event.nativeEvent.preventDefault();\n          event.stopPropagation();\n          onContextMenu();\n        }\n      }}\n      scale={scale as any}\n    >\n      <tubeGeometry attach=\"geometry\" args={[curve, 128, size / 2, 8, true]} />\n      <a.meshBasicMaterial\n        attach=\"material\"\n        opacity={loopOpacity}\n        fog={true}\n        transparent={true}\n        depthTest={false}\n        color={normalizedColor}\n      />\n    </a.mesh>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport type { FC } from 'react';\nimport React, { useEffect, useMemo, useRef } from 'react';\nimport type { ColorRepresentation, Curve } from 'three';\nimport { Color, ShaderMaterial, TubeGeometry, Vector3 } from 'three';\n\nimport { useStore } from '../store';\nimport { animationConfig, getCurve } from '../utils';\n\nexport interface LineProps {\n  /**\n   * Whether the line should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * The color of the line.\n   */\n  color?: ColorRepresentation;\n\n  /**\n   * Whether the line should be curved.\n   */\n  curved: boolean;\n\n  /**\n   * The curve of the line in 3D space.\n   */\n  curve: Curve<Vector3>;\n\n  /**\n   * Whether the line should be dashed.\n   */\n  dashed?: boolean;\n\n  /**\n   * Dash pattern for the line: [dashSize, gapSize]\n   */\n  dashArray?: [number, number];\n\n  /**\n   * The unique identifier of the line.\n   */\n  id: string;\n\n  /**\n   * The opacity of the line.\n   */\n  opacity?: number;\n\n  /**\n   * The size of the line.\n   */\n  size?: number;\n\n  /**\n   * The render order of the line. Useful when edges are rendered on top of each other.\n   */\n  renderOrder?: number;\n\n  /**\n   * A function that is called when the line is clicked.\n   */\n  onClick?: (event: ThreeEvent<MouseEvent>) => void;\n\n  /**\n   * A function that is called when the line is right-clicked.\n   */\n  onContextMenu?: () => void;\n\n  /**\n   * A function that is called when the mouse pointer is moved over the line.\n   */\n  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;\n\n  /**\n   * A function that is called when the mouse pointer is moved out of the line.\n   */\n  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;\n\n  /**\n   * The offset of the curve.\n   */\n  curveOffset?: number;\n}\n\n// Dashed line shader for tube geometry\nconst dashedVertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst dashedFragmentShader = `\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float dashSize;\n  uniform float gapSize;\n  uniform float lineLength;\n  varying vec2 vUv;\n\n  void main() {\n    float totalSize = dashSize + gapSize;\n    float position = mod(vUv.x * lineLength, totalSize);\n\n    if (position > dashSize) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color, opacity);\n  }\n`;\n\nexport const Line: FC<LineProps> = ({\n  curveOffset,\n  animated,\n  color = '#000',\n  curve,\n  curved = false,\n  dashed = false,\n  dashArray = [3, 1],\n  id,\n  opacity = 1,\n  size = 1,\n  renderOrder = -1,\n  onContextMenu,\n  onClick,\n  onPointerOver,\n  onPointerOut\n}) => {\n  const tubeRef = useRef<TubeGeometry | null>(null);\n  const isDragging = useStore(state => state.draggingIds.length > 0);\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n  const center = useStore(state => state.centerPosition);\n  const mounted = useRef<boolean>(false);\n\n  // Create dashed material\n  const dashedMaterial = useMemo(() => {\n    if (!dashed) return null;\n    const [dashSize, dashGap] = dashArray;\n\n    return new ShaderMaterial({\n      uniforms: {\n        color: { value: normalizedColor },\n        opacity: { value: opacity },\n        dashSize: { value: dashSize },\n        gapSize: { value: dashGap },\n        lineLength: { value: curve.getLength() }\n      },\n      vertexShader: dashedVertexShader,\n      fragmentShader: dashedFragmentShader,\n      transparent: true,\n      depthTest: false\n    });\n  }, [dashed, normalizedColor, opacity, curve, dashArray]);\n\n  // Do opacity seperate from vertices for perf\n  const { lineOpacity } = useSpring({\n    from: {\n      lineOpacity: 0\n    },\n    to: {\n      lineOpacity: opacity\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  useSpring(() => {\n    const from = curve.getPoint(0);\n    const to = curve.getPoint(1);\n    return {\n      from: {\n        // Animate from center first time, then from the actual from point\n        fromVertices: !mounted.current\n          ? [center?.x, center?.y, center?.z || 0]\n          : [to?.x, to?.y, to?.z || 0],\n        toVertices: [from?.x, from?.y, from?.z || 0]\n      },\n      to: {\n        fromVertices: [from?.x, from?.y, from?.z || 0],\n        toVertices: [to?.x, to?.y, to?.z || 0]\n      },\n      onChange: event => {\n        const { fromVertices, toVertices } = event.value;\n        const fromVector = new Vector3(...fromVertices);\n        const toVector = new Vector3(...toVertices);\n\n        const curve = getCurve(fromVector, 0, toVector, 0, curved, curveOffset);\n\n        if (tubeRef.current) {\n          // Use slightly smaller radius for dashed lines for visual distinction\n          const radius = dashed ? size * 0.4 : size / 2;\n          tubeRef.current.copy(new TubeGeometry(curve, 20, radius, 5, false));\n        }\n      },\n      config: {\n        ...animationConfig,\n        duration: animated && !isDragging ? undefined : 0\n      }\n    };\n  }, [animated, isDragging, curve, size, dashed, curved, curveOffset]);\n\n  useEffect(() => {\n    // Handle mount operation for initial render\n    mounted.current = true;\n  }, []);\n\n  return (\n    <mesh\n      userData={{ id, type: 'edge' }}\n      renderOrder={renderOrder}\n      onPointerOver={onPointerOver}\n      onPointerOut={onPointerOut}\n      onClick={onClick}\n      // context menu controls\n      onPointerDown={event => {\n        if (event.nativeEvent.buttons === 2) {\n          event.stopPropagation();\n        }\n      }}\n      onContextMenu={event => {\n        event.nativeEvent.preventDefault();\n        event.stopPropagation();\n        onContextMenu();\n      }}\n    >\n      <tubeGeometry attach=\"geometry\" ref={tubeRef} />\n      {dashed ? (\n        <primitive attach=\"material\" object={dashedMaterial} />\n      ) : (\n        <a.meshBasicMaterial\n          attach=\"material\"\n          opacity={lineOpacity}\n          fog={true}\n          transparent={true}\n          color={normalizedColor}\n        />\n      )}\n    </mesh>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport { Html, useCursor } from '@react-three/drei';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport type { FC } from 'react';\nimport React, { useMemo, useState } from 'react';\nimport { Euler, Vector3 } from 'three';\n\nimport { useStore } from '../store';\nimport type { ContextMenuEvent, InternalGraphEdge } from '../types';\nimport {\n  animationConfig,\n  calculateEdgeCurveOffset,\n  getArrowSize,\n  getArrowVectors,\n  getCurve,\n  getLabelOffsetByType,\n  getMidPoint,\n  getVector\n} from '../utils';\nimport { calculateSubLabelOffset, getSelfLoopCurve } from '../utils/position';\nimport { useHoverIntent } from '../utils/useHoverIntent';\nimport type { EdgeArrowPosition } from './Arrow';\nimport { Arrow } from './Arrow';\nimport { SelfLoop } from './edges/SelfLoop';\nimport { Label } from './Label';\nimport { Line } from './Line';\n\n/**\n * Label positions relatively edge.\n *\n * - below: show label under the edge line\n * - above: show label above the edge line\n * - inline: show label along the edge line\n * - natural: normal text positions\n */\nexport type EdgeLabelPosition = 'below' | 'above' | 'inline' | 'natural';\n\n/**\n * SubLabel positions relatively to the main label.\n *\n * - below: show subLabel below the main label\n * - above: show subLabel above the main label\n */\nexport type EdgeSubLabelPosition = 'below' | 'above';\n\n/**\n * Type of edge interpolation.\n *\n * - Linear is straight\n * - Curved is curved\n */\nexport type EdgeInterpolation = 'linear' | 'curved';\n\nexport interface EdgeProps {\n  /**\n   * The url for the label font.\n   */\n  labelFontUrl?: string;\n\n  /**\n   * The unique identifier of the edge.\n   */\n  id: string;\n\n  /**\n   * Whether the edge should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * Whether the edge should be disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * The placement of the edge label.\n   */\n  labelPlacement?: EdgeLabelPosition;\n\n  /**\n   * The placement of the edge subLabel relative to the main label.\n   */\n  subLabelPlacement?: EdgeSubLabelPosition;\n\n  /**\n   * The placement of the edge arrow.\n   */\n  arrowPlacement?: EdgeArrowPosition;\n\n  /**\n   * The type of interpolation used to draw the edge.\n   */\n  interpolation: EdgeInterpolation;\n\n  /**\n   * A function that returns the context menu for the edge.\n   */\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\n\n  /**\n   * A function that is called when the edge is clicked.\n   */\n  onClick?: (edge: InternalGraphEdge, event: ThreeEvent<MouseEvent>) => void;\n\n  /**\n   * A function that is called when the edge is right-clicked.\n   */\n  onContextMenu?: (edge?: InternalGraphEdge) => void;\n\n  /**\n   * A function that is called when the mouse pointer is moved over the edge.\n   */\n  onPointerOver?: (\n    edge: InternalGraphEdge,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * A function that is called when the mouse pointer is moved out of the edge.\n   */\n  onPointerOut?: (\n    edge: InternalGraphEdge,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n}\n\nconst LABEL_PLACEMENT_OFFSET = 3;\n\nexport const Edge: FC<EdgeProps> = ({\n  animated,\n  arrowPlacement = 'end',\n  contextMenu,\n  disabled,\n  labelPlacement = 'inline',\n  id,\n  interpolation,\n  labelFontUrl,\n  onContextMenu,\n  onClick,\n  onPointerOver,\n  onPointerOut,\n  subLabelPlacement = 'below'\n}) => {\n  const theme = useStore(state => state.theme);\n  const isDragging = useStore(state => state.draggingIds.length > 0);\n\n  // UI states\n  const [active, setActive] = useState<boolean>(false);\n  const [menuVisible, setMenuVisible] = useState<boolean>(false);\n\n  // Edge data\n  const edges = useStore(state => state.edges);\n  const edge = edges.find(e => e.id === id);\n  const {\n    target,\n    source,\n    label,\n    subLabel,\n    labelVisible = false,\n    size = 1,\n    fill,\n    dashed = false,\n    dashArray = [3, 1]\n  } = edge;\n\n  // Use subLabelPlacement from edge data if available, otherwise use the prop value\n  const effectiveSubLabelPlacement =\n    edge.subLabelPlacement || subLabelPlacement;\n\n  const from = useStore(store => store.nodes.find(node => node.id === source));\n  const to = useStore(store => store.nodes.find(node => node.id === target));\n\n  // Detect self-loop\n  const isSelfLoop = from.id === to.id;\n\n  // Edge properties\n  const labelOffset = (size + theme.edge.label.fontSize) / 2;\n  const [arrowLength, arrowSize] = useMemo(() => getArrowSize(size), [size]);\n\n  // Use edge-specific interpolation if available, otherwise use global interpolation\n  const effectiveInterpolation = edge.interpolation || interpolation;\n\n  // Use edge-specific arrow placement if available, otherwise use global arrow placement\n  const effectiveArrowPlacement = edge.arrowPlacement || arrowPlacement;\n\n  const { curveOffset, curved } = useMemo(\n    () =>\n      calculateEdgeCurveOffset({\n        edge,\n        edges,\n        curved: effectiveInterpolation === 'curved'\n      }),\n    [edge, edges, effectiveInterpolation]\n  );\n\n  const [curve, arrowPosition, arrowRotation] = useMemo(() => {\n    const fromVector = getVector(from);\n    const fromOffset = from.size;\n    const toVector = getVector(to);\n    const toOffset = to.size;\n\n    let curve = getCurve(\n      fromVector,\n      fromOffset,\n      toVector,\n      toOffset,\n      curved,\n      curveOffset\n    );\n\n    const [arrowPosition, arrowRotation] = getArrowVectors(\n      effectiveArrowPlacement,\n      curve,\n      arrowLength\n    );\n\n    if (effectiveArrowPlacement === 'end') {\n      curve = getCurve(\n        fromVector,\n        fromOffset,\n        arrowPosition,\n        0,\n        curved,\n        curveOffset\n      );\n    }\n\n    return [curve, arrowPosition, arrowRotation];\n  }, [from, to, curved, curveOffset, effectiveArrowPlacement, arrowLength]);\n\n  const midPoint = useMemo(() => {\n    let newMidPoint = getMidPoint(\n      from.position,\n      to.position,\n      getLabelOffsetByType(labelOffset, labelPlacement)\n    );\n\n    if (curved) {\n      // Offset the label to the mid point of the curve\n      const offset = new Vector3().subVectors(newMidPoint, curve.getPoint(0.5));\n      switch (labelPlacement) {\n        case 'above':\n          offset.y = offset.y - LABEL_PLACEMENT_OFFSET;\n          break;\n        case 'below':\n          offset.y = offset.y + LABEL_PLACEMENT_OFFSET;\n          break;\n      }\n      newMidPoint = newMidPoint.sub(offset);\n    }\n\n    return newMidPoint;\n  }, [from.position, to.position, labelOffset, labelPlacement, curved, curve]);\n\n  const center = useStore(state => state.centerPosition);\n\n  const isSelected = useStore(state => state.selections?.includes(id));\n  const hasSelections = useStore(state => state.selections?.length);\n  const isActive = useStore(state => state.actives?.includes(id));\n  const isActiveState = active || isActive || isSelected;\n\n  const selectionOpacity = hasSelections\n    ? isSelected || isActive\n      ? theme.edge.selectedOpacity\n      : theme.edge.inactiveOpacity\n    : theme.edge.opacity;\n\n  // Calculate subLabel position based on edge orientation and subLabelPlacement\n  const subLabelOffset = useMemo(() => {\n    return calculateSubLabelOffset(\n      from.position,\n      to.position,\n      effectiveSubLabelPlacement\n    );\n  }, [from.position, to.position, effectiveSubLabelPlacement]);\n\n  const [{ labelPosition }] = useSpring(\n    () => ({\n      from: {\n        labelPosition: center ? [center.x, center.y, center.z] : [0, 0, 0]\n      },\n      to: {\n        labelPosition: [midPoint.x, midPoint.y, midPoint.z]\n      },\n      config: {\n        ...animationConfig,\n        duration: animated && !isDragging ? undefined : 0\n      }\n    }),\n    [midPoint, animated, isDragging]\n  );\n\n  const labelRotation = useMemo(\n    () =>\n      new Euler(\n        0,\n        0,\n        labelPlacement === 'natural'\n          ? 0\n          : Math.atan(\n              (to.position.y - from.position.y) /\n                (to.position.x - from.position.x)\n            )\n      ),\n    [\n      to.position.x,\n      to.position.y,\n      from.position.x,\n      from.position.y,\n      labelPlacement\n    ]\n  );\n\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\n\n  const { pointerOver, pointerOut } = useHoverIntent({\n    disabled,\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\n      setActive(true);\n      onPointerOver?.(edge, event);\n    },\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\n      setActive(false);\n      onPointerOut?.(edge, event);\n    }\n  });\n\n  const selfLoopCurve = useMemo(() => getSelfLoopCurve(from), [from]);\n\n  const arrowComponent = useMemo(() => {\n    if (effectiveArrowPlacement === 'none') return null;\n\n    let position: Vector3;\n    let rotation: Vector3;\n\n    if (isSelfLoop && selfLoopCurve) {\n      // Arrow for self-loop\n      const uEnd = 0.58;\n      const uMid = 0.25;\n      if (effectiveArrowPlacement === 'mid') {\n        position = selfLoopCurve.getPointAt(uMid);\n        rotation = selfLoopCurve.getTangentAt(uMid);\n      } else {\n        // end is default\n        position = selfLoopCurve.getPointAt(uEnd);\n        rotation = selfLoopCurve.getTangentAt(uEnd);\n      }\n    } else {\n      // Arrow for normal edge\n      position = arrowPosition;\n      rotation = arrowRotation;\n    }\n\n    return (\n      <Arrow\n        animated={animated}\n        color={\n          isActiveState ? theme.arrow.activeFill : fill || theme.arrow.fill\n        }\n        length={arrowLength}\n        opacity={selectionOpacity}\n        position={position}\n        rotation={rotation}\n        size={arrowSize}\n        onActive={setActive}\n        onContextMenu={() => {\n          if (!disabled) {\n            setMenuVisible(true);\n            onContextMenu?.(edge);\n          }\n        }}\n      />\n    );\n  }, [\n    fill,\n    animated,\n    arrowLength,\n    effectiveArrowPlacement,\n    arrowPosition,\n    arrowRotation,\n    arrowSize,\n    disabled,\n    edge,\n    isActiveState,\n    onContextMenu,\n    selectionOpacity,\n    theme.arrow.activeFill,\n    theme.arrow.fill,\n    isSelfLoop,\n    selfLoopCurve\n  ]);\n\n  const labelComponent = useMemo(\n    () =>\n      labelVisible &&\n      label && (\n        <a.group\n          position={labelPosition as any}\n          onContextMenu={() => {\n            if (!disabled) {\n              setMenuVisible(true);\n              onContextMenu?.(edge);\n            }\n          }}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n        >\n          <Label\n            text={label}\n            ellipsis={15}\n            fontUrl={labelFontUrl}\n            stroke={theme.edge.label.stroke}\n            color={\n              isActiveState\n                ? theme.edge.label.activeColor\n                : theme.edge.label.color\n            }\n            opacity={selectionOpacity}\n            fontSize={theme.edge.label.fontSize}\n            rotation={labelRotation}\n            active={isActiveState}\n          />\n\n          {subLabel && (\n            <group position={[subLabelOffset.x, subLabelOffset.y, 0]}>\n              <Label\n                text={subLabel}\n                ellipsis={15}\n                fontUrl={labelFontUrl}\n                stroke={theme.edge.subLabel?.stroke || theme.edge.label.stroke}\n                active={isActiveState}\n                color={\n                  isActiveState\n                    ? theme.edge.subLabel?.activeColor ||\n                      theme.edge.label.activeColor\n                    : theme.edge.subLabel?.color || theme.edge.label.color\n                }\n                opacity={selectionOpacity}\n                fontSize={\n                  theme.edge.subLabel?.fontSize ||\n                  theme.edge.label.fontSize * 0.8\n                }\n                rotation={labelRotation}\n              />\n            </group>\n          )}\n        </a.group>\n      ),\n    [\n      disabled,\n      edge,\n      isActiveState,\n      label,\n      subLabel,\n      labelFontUrl,\n      labelPosition,\n      subLabelOffset,\n      labelRotation,\n      labelVisible,\n      onContextMenu,\n      pointerOut,\n      pointerOver,\n      selectionOpacity,\n      theme.edge.label.activeColor,\n      theme.edge.label.color,\n      theme.edge.label.fontSize,\n      theme.edge.label.stroke,\n      theme.edge.subLabel?.stroke,\n      theme.edge.subLabel?.activeColor,\n      theme.edge.subLabel?.color,\n      theme.edge.subLabel?.fontSize\n    ]\n  );\n\n  const menuComponent = useMemo(\n    () =>\n      menuVisible &&\n      contextMenu && (\n        <Html prepend={true} center={true} position={midPoint}>\n          {contextMenu({ data: edge, onClose: () => setMenuVisible(false) })}\n        </Html>\n      ),\n    [menuVisible, contextMenu, midPoint, edge]\n  );\n\n  return (\n    <group position={[0, 0, isActiveState ? 1 : 0]}>\n      {isSelfLoop && selfLoopCurve ? (\n        <SelfLoop\n          id={id}\n          curve={selfLoopCurve}\n          size={size}\n          animated={animated}\n          color={\n            isActiveState ? theme.edge.activeFill : fill || theme.edge.fill\n          }\n          opacity={selectionOpacity}\n          onClick={event => {\n            if (!disabled) {\n              onClick?.(edge, event);\n            }\n          }}\n          onContextMenu={() => {\n            if (!disabled) {\n              setMenuVisible(true);\n              onContextMenu?.(edge);\n            }\n          }}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n        />\n      ) : (\n        <Line\n          curveOffset={curveOffset}\n          animated={animated}\n          color={\n            isActiveState ? theme.edge.activeFill : fill || theme.edge.fill\n          }\n          curve={curve}\n          curved={curved}\n          dashed={dashed}\n          dashArray={dashArray}\n          id={id}\n          opacity={selectionOpacity}\n          size={size}\n          renderOrder={isActiveState ? 0 : -1}\n          onClick={event => {\n            if (!disabled) {\n              onClick?.(edge, event);\n            }\n          }}\n          onPointerOver={pointerOver}\n          onPointerOut={pointerOut}\n          onContextMenu={() => {\n            if (!disabled) {\n              setMenuVisible(true);\n              onContextMenu?.(edge);\n            }\n          }}\n        />\n      )}\n      {arrowComponent}\n      {labelComponent}\n      {menuComponent}\n    </group>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport { Html } from '@react-three/drei';\nimport type { FC } from 'react';\nimport React, { useCallback, useMemo } from 'react';\nimport type { ColorRepresentation } from 'three';\nimport { Euler } from 'three';\n\nimport { useStore } from '../../store';\nimport type { ContextMenuEvent, InternalGraphEdge } from '../../types';\nimport {\n  animationConfig,\n  getLabelOffsetByType,\n  getMidPoint\n} from '../../utils';\nimport { Label } from '../Label';\n\n/**\n * Label positions relatively edge\n *\n * below: show label under the edge line\n * above: show label above the edge line\n * inline: show label along the edge line\n * natural: normal text positions\n */\nexport type EdgeLabelPosition = 'below' | 'above' | 'inline' | 'natural';\n\nexport type EdgeArrowPosition = 'none' | 'mid' | 'end';\n\nexport interface EdgeProps {\n  /**\n   * Whether the edge should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * Whether the edge should be disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * The color of the edge.\n   */\n  color: ColorRepresentation;\n\n  /**\n   * A function that returns the context menu for the edge.\n   */\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\n\n  /**\n   * The edge object.\n   */\n  edge: InternalGraphEdge;\n\n  /**\n   * The URL of the font for the edge label.\n   */\n  labelFontUrl?: string;\n\n  /**\n   * The placement of the edge label.\n   */\n  labelPlacement?: EdgeLabelPosition;\n\n  /**\n   * The opacity of the edge.\n   */\n  opacity?: number;\n\n  /**\n   * Whether the edge is active.\n   */\n  active?: boolean;\n}\n\nexport const Edge: FC<EdgeProps> = ({\n  animated,\n  color,\n  contextMenu,\n  edge,\n  labelFontUrl,\n  labelPlacement = 'inline',\n  opacity,\n  active\n}) => {\n  const theme = useStore(state => state.theme);\n  const { target, source, label, labelVisible = false, size = 1 } = edge;\n\n  const nodes = useStore(store => store.nodes);\n  const [from, to] = useMemo(\n    () => [\n      nodes.find(node => node.id === source),\n      nodes.find(node => node.id === target)\n    ],\n    [nodes, source, target]\n  );\n  const isDragging = useStore(state => state.draggingIds.length > 0);\n\n  const labelOffset = useMemo(\n    () => (size + theme.edge.label.fontSize) / 2,\n    [size, theme.edge.label.fontSize]\n  );\n\n  const midPoint = useMemo(\n    () =>\n      getMidPoint(\n        from.position,\n        to.position,\n        getLabelOffsetByType(labelOffset, labelPlacement)\n      ),\n    [from.position, to.position, labelOffset, labelPlacement]\n  );\n\n  const edgeContextMenus = useStore(state => state.edgeContextMenus);\n  const setEdgeContextMenus = useStore(state => state.setEdgeContextMenus);\n\n  const [{ labelPosition }] = useSpring(\n    () => ({\n      from: {\n        labelPosition: [0, 0, 0]\n      },\n      to: {\n        labelPosition: [midPoint.x, midPoint.y, midPoint.z]\n      },\n      config: {\n        ...animationConfig,\n        duration: animated && !isDragging ? undefined : 0\n      }\n    }),\n    [midPoint, animated, isDragging]\n  );\n\n  const removeContextMenu = useCallback(\n    (edgeId: string) => {\n      const newEdgeContextMenus = new Set(edgeContextMenus);\n      newEdgeContextMenus.delete(edgeId);\n      setEdgeContextMenus(newEdgeContextMenus);\n    },\n    [edgeContextMenus, setEdgeContextMenus]\n  );\n\n  const labelRotation = useMemo(\n    () =>\n      new Euler(\n        0,\n        0,\n        labelPlacement === 'natural'\n          ? 0\n          : Math.atan(\n              (to.position.y - from.position.y) /\n                (to.position.x - from.position.x)\n            )\n      ),\n    [\n      to.position.x,\n      to.position.y,\n      from.position.x,\n      from.position.y,\n      labelPlacement\n    ]\n  );\n\n  const htmlProps = useMemo(\n    () => ({\n      prepend: true,\n      center: true,\n      position: midPoint\n    }),\n    [midPoint]\n  );\n\n  const labelProps = useMemo(\n    () => ({\n      text: label,\n      ellipsis: 15,\n      fontUrl: labelFontUrl,\n      stroke: theme.edge.label.stroke,\n      color,\n      opacity,\n      fontSize: theme.edge.label.fontSize,\n      rotation: labelRotation,\n      active\n    }),\n    [\n      label,\n      labelFontUrl,\n      theme.edge.label.stroke,\n      color,\n      opacity,\n      theme.edge.label.fontSize,\n      labelRotation,\n      active\n    ]\n  );\n\n  return (\n    <group>\n      {labelVisible && label && (\n        <a.group position={labelPosition as any}>\n          <Label\n            text={label}\n            fontUrl={labelFontUrl}\n            stroke={theme.edge.label.stroke}\n            color={color}\n            opacity={opacity}\n            fontSize={theme.edge.label.fontSize}\n            maxWidth={theme.edge.label.maxWidth}\n            ellipsis={theme.edge.label.ellipsis}\n            rotation={labelRotation}\n            backgroundColor={theme.edge.label.backgroundColor}\n            borderRadius={theme.edge.label.borderRadius}\n          />\n        </a.group>\n      )}\n      {contextMenu && edgeContextMenus.has(edge.id) && (\n        <Html {...htmlProps}>\n          {contextMenu({\n            data: edge,\n            onClose: () => removeContextMenu(edge.id)\n          })}\n        </Html>\n      )}\n    </group>\n  );\n};\n","import type { SpringValue } from '@react-spring/three';\nimport { useSpring } from '@react-spring/three';\nimport { useCallback, useEffect, useRef } from 'react';\nimport type { BufferGeometry } from 'three';\nimport { BufferAttribute } from 'three';\n\nimport type { Theme } from '../../themes';\nimport { animationConfig } from '../../utils';\n\nexport function useEdgePositionAnimation(\n  geometry: BufferGeometry,\n  animated: boolean\n): void {\n  const geometryRef = useRef<BufferGeometry>(geometry);\n  const bufferPool = useRef<Float32Array | null>(null);\n\n  useEffect(() => {\n    geometryRef.current = geometry;\n    const positions = geometry.getAttribute('position');\n    bufferPool.current = new Float32Array(positions.array.length);\n  }, [geometry]);\n\n  const getAnimationPositions = useCallback(() => {\n    const positions = geometryRef.current.getAttribute('position');\n    const from = new Float32Array(positions.array.length);\n    return {\n      from,\n      to: positions.array\n    };\n  }, []);\n\n  const updateGeometryPosition = useCallback((positions: Array<number>) => {\n    const buffer = bufferPool.current!;\n    buffer.set(positions);\n    const newPosition = new BufferAttribute(buffer, 3, false);\n    geometryRef.current.setAttribute('position', newPosition);\n    newPosition.needsUpdate = true;\n  }, []);\n\n  useSpring(() => {\n    if (!animated) {\n      return null;\n    }\n\n    const animationPositions = getAnimationPositions();\n\n    return {\n      from: {\n        positions: animationPositions.from\n      },\n      to: {\n        positions: animationPositions.to\n      },\n      onChange: event => {\n        updateGeometryPosition(event.value.positions);\n      },\n      config: {\n        ...animationConfig,\n        duration: animated ? undefined : 0\n      }\n    };\n  }, [animated, getAnimationPositions, updateGeometryPosition]);\n}\n\nexport type UseEdgeOpacityAnimations = {\n  activeOpacity: SpringValue<number>;\n  inactiveOpacity: SpringValue<number>;\n};\n\nexport function useEdgeOpacityAnimation(\n  animated: boolean,\n  hasSelections: boolean,\n  theme: Theme\n): UseEdgeOpacityAnimations {\n  const [{ activeOpacity, inactiveOpacity }] = useSpring(() => {\n    return {\n      from: {\n        activeOpacity: 0,\n        inactiveOpacity: 0\n      },\n      to: {\n        activeOpacity: hasSelections\n          ? theme.edge.selectedOpacity\n          : theme.edge.opacity,\n        inactiveOpacity: hasSelections\n          ? theme.edge.inactiveOpacity\n          : theme.edge.opacity\n      },\n      config: {\n        ...animationConfig,\n        duration: animated ? undefined : 0\n      }\n    };\n  }, [animated, hasSelections, theme]);\n\n  return { activeOpacity, inactiveOpacity };\n}\n","import { useCallback, useEffect, useRef } from 'react';\n\nimport { useStore } from '../../store';\nimport type { InternalGraphEdge } from '../../types';\n\nexport type EdgeEvents = {\n  onClick?: (edge: InternalGraphEdge) => void;\n  onContextMenu?: (edge?: InternalGraphEdge) => void;\n  onPointerOver?: (edge: InternalGraphEdge) => void;\n  onPointerOut?: (edge: InternalGraphEdge) => void;\n};\n\nexport function useEdgeEvents(\n  events: EdgeEvents,\n  contextMenu,\n  disabled: boolean\n) {\n  const memoizedEvents = useRef(events);\n  useEffect(() => {\n    memoizedEvents.current = events;\n  }, [events]);\n\n  const edgeContextMenus = useStore(state => state.edgeContextMenus);\n  const setEdgeContextMenus = useStore(\n    useCallback(state => state.setEdgeContextMenus, [])\n  );\n  const setHoveredEdgeIds = useStore(\n    useCallback(state => state.setHoveredEdgeIds, [])\n  );\n\n  const clickRef = useRef(false);\n  const handleClick = useCallback(() => {\n    clickRef.current = true;\n  }, []);\n\n  const contextMenuEventRef = useRef(false);\n  const handleContextMenu = useCallback(() => {\n    contextMenuEventRef.current = true;\n  }, []);\n\n  const handleIntersections = useCallback(\n    (\n      previous: Array<InternalGraphEdge>,\n      intersected: Array<InternalGraphEdge>\n    ) => {\n      const { onClick, onContextMenu, onPointerOver, onPointerOut } =\n        memoizedEvents.current;\n\n      if (onClick && clickRef.current && !disabled) {\n        clickRef.current = false;\n        for (const edge of intersected) {\n          onClick(edge);\n        }\n      }\n\n      if (\n        (contextMenu || onContextMenu) &&\n        contextMenuEventRef.current &&\n        !disabled\n      ) {\n        contextMenuEventRef.current = false;\n        const newEdges = new Set(edgeContextMenus);\n        let hasChanges = false;\n\n        for (const edge of intersected) {\n          if (!edgeContextMenus.has(edge.id)) {\n            newEdges.add(edge.id);\n            hasChanges = true;\n            onContextMenu?.(edge);\n          }\n        }\n\n        if (hasChanges) {\n          setEdgeContextMenus(newEdges);\n        }\n      }\n\n      const hoveredIds =\n        intersected.length > 0 ? intersected.map(edge => edge.id) : [];\n      setHoveredEdgeIds(hoveredIds);\n\n      if (onPointerOver) {\n        const over = intersected.filter(index => !previous.includes(index));\n        over.forEach(edge => {\n          onPointerOver(edge);\n        });\n      }\n\n      if (onPointerOut) {\n        const out = previous.filter(index => !intersected.includes(index));\n        out.forEach(edge => {\n          onPointerOut(edge);\n        });\n      }\n    },\n    [\n      contextMenu,\n      disabled,\n      edgeContextMenus,\n      setEdgeContextMenus,\n      setHoveredEdgeIds\n    ]\n  );\n\n  return {\n    handleClick,\n    handleContextMenu,\n    handleIntersections\n  };\n}\n","import { useCallback, useRef } from 'react';\nimport type { BufferGeometry, Curve } from 'three';\nimport {\n  Color,\n  CylinderGeometry,\n  Quaternion,\n  TubeGeometry,\n  Vector3\n} from 'three';\nimport { mergeBufferGeometries } from 'three-stdlib';\n\nimport type { GraphState } from '../../store';\nimport { useStore } from '../../store';\nimport type { InternalGraphEdge } from '../../types';\nimport {\n  addColorAttribute,\n  createDashedGeometry,\n  createNullGeometry,\n  getArrowSize,\n  getArrowVectors,\n  getCurve,\n  getSelfLoopCurve,\n  getVector\n} from '../../utils';\nimport type { EdgeArrowPosition } from '../Arrow';\nimport type { EdgeInterpolation } from '../Edge';\n\nexport type UseEdgeGeometry = {\n  getGeometries(edges: Array<InternalGraphEdge>): Array<BufferGeometry>;\n  getGeometry(\n    active: Array<InternalGraphEdge>,\n    inactive: Array<InternalGraphEdge>\n  ): BufferGeometry;\n};\n\nconst NULL_GEOMETRY = createNullGeometry();\n\nexport function useEdgeGeometry(\n  arrowPlacement: EdgeArrowPosition,\n  interpolation: EdgeInterpolation\n): UseEdgeGeometry {\n  // We don't want to rerun everything when the state changes,\n  // but we do want to use the most recent nodes whenever `getGeometries`\n  // or `getGeometry` is run, so we store it in a ref:\n  const stateRef = useRef<GraphState | null>(null);\n  const theme = useStore(state => state.theme);\n  useStore(state => {\n    stateRef.current = state;\n  });\n\n  const geometryCacheRef = useRef(new Map<string, BufferGeometry>());\n\n  // Add memoized geometry for arrows\n  const baseArrowGeometryRef = useRef<CylinderGeometry | null>(null);\n\n  const getGeometries = useCallback(\n    (edges: Array<InternalGraphEdge>): Array<BufferGeometry> => {\n      const geometries: Array<BufferGeometry> = [];\n      const cache = geometryCacheRef.current;\n\n      // Pre-compute values outside the loop\n      const { nodes } = stateRef.current;\n      const nodesMap = new Map(nodes.map(node => [node.id, node]));\n\n      // Initialize base arrow geometry if needed\n      if (arrowPlacement !== 'none' && !baseArrowGeometryRef.current) {\n        baseArrowGeometryRef.current = new CylinderGeometry(\n          0,\n          1,\n          1,\n          20,\n          1,\n          true\n        );\n      }\n\n      edges.forEach(edge => {\n        const { target, source, size = 1 } = edge;\n        const from = nodesMap.get(source);\n        const to = nodesMap.get(target);\n\n        if (!from || !to) {\n          return;\n        }\n        // Improved hash function to include size\n        const hash = `${from.position.x},${from.position.y},${to.position.x},${to.position.y},${size}`;\n\n        // Detect self-loop\n        const isSelfLoop = from.id === to.id;\n        // Determine interpolation for this specific edge\n        const edgeInterpolation = edge.interpolation || interpolation;\n        const curved = edgeInterpolation === 'curved';\n\n        // Determine arrow placement for this specific edge\n        const edgeArrowPlacement = edge.arrowPlacement || arrowPlacement;\n\n        if (cache.has(hash)) {\n          geometries.push(cache.get(hash));\n          return;\n        }\n        const fromVector = getVector(from);\n        const fromOffset = from.size;\n        const toVector = getVector(to);\n        const toOffset = to.size;\n\n        let curve: Curve<Vector3>;\n        if (isSelfLoop) {\n          // Self-loop curve\n          curve = getSelfLoopCurve(from);\n        } else {\n          // Regular edge curve\n          curve = getCurve(fromVector, fromOffset, toVector, toOffset, curved);\n        }\n\n        // Use smaller radius for dashed edges to match Line.tsx behavior\n        const isDashedEdge = edge.dashed;\n        const radius = isDashedEdge ? size * 0.4 : size / 2;\n\n        let edgeGeometry: BufferGeometry;\n        if (isDashedEdge) {\n          edgeGeometry = createDashedGeometry(\n            curve,\n            radius,\n            new Color(edge.fill ?? theme.edge.fill),\n            edge.dashArray\n          );\n        } else {\n          edgeGeometry = new TubeGeometry(curve, 20, radius, 5, false);\n        }\n\n        if (edgeArrowPlacement === 'none') {\n          // Add color to edge geometry for edges without arrows (only if not dashed, dashed already have colors)\n          if (!isDashedEdge) {\n            const edgeOnlyColor = new Color(edge.fill ?? theme.edge.fill);\n            addColorAttribute(edgeGeometry, edgeOnlyColor);\n          }\n\n          geometries.push(edgeGeometry);\n          cache.set(hash, edgeGeometry);\n          return;\n        }\n\n        // Reuse base arrow geometry and scale/rotate as needed\n        const [arrowLength, arrowSize] = getArrowSize(size);\n        const arrowGeometry = baseArrowGeometryRef.current.clone();\n        arrowGeometry.scale(arrowSize, arrowLength, arrowSize);\n\n        let arrowPosition: Vector3;\n        let arrowRotation: Vector3;\n\n        if (isSelfLoop) {\n          // Arrow positioning for self-loop\n          const uEnd = 0.58;\n          const uMid = 0.25;\n          if (edgeArrowPlacement === 'mid') {\n            arrowPosition = curve.getPointAt(uMid);\n            arrowRotation = curve.getTangentAt(uMid);\n          } else {\n            // end is default\n            arrowPosition = curve.getPointAt(uEnd);\n            arrowRotation = curve.getTangentAt(uEnd);\n          }\n        } else {\n          // Regular arrow positioning\n          [arrowPosition, arrowRotation] = getArrowVectors(\n            edgeArrowPlacement,\n            curve,\n            arrowLength\n          );\n        }\n\n        const quaternion = new Quaternion();\n        quaternion.setFromUnitVectors(new Vector3(0, 1, 0), arrowRotation);\n        arrowGeometry.applyQuaternion(quaternion);\n        arrowGeometry.translate(\n          arrowPosition.x,\n          arrowPosition.y,\n          arrowPosition.z\n        );\n\n        // Move edge so it doesn't stick through the arrow:\n        if (edgeArrowPlacement && edgeArrowPlacement === 'end' && !isSelfLoop) {\n          const adjustedCurve = getCurve(\n            fromVector,\n            fromOffset,\n            arrowPosition,\n            0,\n            curved\n          );\n\n          if (isDashedEdge) {\n            edgeGeometry = createDashedGeometry(\n              adjustedCurve,\n              radius,\n              new Color(edge.fill ?? theme.edge.fill),\n              edge.dashArray\n            );\n          } else {\n            edgeGeometry = new TubeGeometry(\n              adjustedCurve,\n              20,\n              radius,\n              5,\n              false\n            );\n          }\n        }\n\n        // Add color attributes to both geometries (only for non-dashed, dashed already have colors)\n        const finalColor = new Color(edge.fill ?? theme.edge.fill);\n\n        if (!isDashedEdge) {\n          addColorAttribute(edgeGeometry, finalColor);\n        }\n        addColorAttribute(arrowGeometry, finalColor);\n\n        const merged = mergeBufferGeometries([edgeGeometry, arrowGeometry]);\n        merged.userData = { ...merged.userData, type: 'edge' };\n        geometries.push(merged);\n        cache.set(hash, merged);\n      });\n      return geometries;\n    },\n    [arrowPlacement, interpolation, theme.edge.fill]\n  );\n\n  const getGeometry = useCallback(\n    (\n      active: Array<InternalGraphEdge>,\n      inactive: Array<InternalGraphEdge>\n    ): BufferGeometry => {\n      const activeGeometries = getGeometries(active);\n      const inactiveGeometries = getGeometries(inactive);\n\n      return mergeBufferGeometries(\n        [\n          inactiveGeometries.length\n            ? mergeBufferGeometries(inactiveGeometries)\n            : NULL_GEOMETRY,\n          activeGeometries.length\n            ? mergeBufferGeometries(activeGeometries)\n            : NULL_GEOMETRY\n        ],\n        true\n      );\n    },\n    [getGeometries]\n  );\n\n  return {\n    getGeometries,\n    getGeometry\n  };\n}\n","import { a } from '@react-spring/three';\nimport { useFrame } from '@react-three/fiber';\nimport type { FC } from 'react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport type { Raycaster, TubeGeometry } from 'three';\nimport { DoubleSide, Mesh } from 'three';\n\nimport { useStore } from '../../store';\nimport type { ContextMenuEvent, InternalGraphEdge } from '../../types';\nimport type { EdgeArrowPosition } from '../Arrow';\nimport type { EdgeInterpolation, EdgeLabelPosition } from '../Edge';\nimport { Edge } from './Edge';\nimport {\n  useEdgeOpacityAnimation,\n  useEdgePositionAnimation\n} from './useEdgeAnimations';\nimport type { EdgeEvents } from './useEdgeEvents';\nimport { useEdgeEvents } from './useEdgeEvents';\nimport { useEdgeGeometry } from './useEdgeGeometry';\n\nexport type EdgesProps = {\n  /**\n   * Whether the edge should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * The placement of the edge arrow.\n   */\n  arrowPlacement?: EdgeArrowPosition;\n\n  /**\n   * A function that returns the context menu for the edge.\n   */\n  contextMenu?: (event: Partial<ContextMenuEvent>) => React.ReactNode;\n\n  /**\n   * Whether the edge should be disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * The array of edge objects.\n   */\n  edges: Array<InternalGraphEdge>;\n\n  /**\n   * The URL of the font for the edge label.\n   */\n  labelFontUrl?: string;\n\n  /**\n   * The placement of the edge label.\n   */\n  labelPlacement?: EdgeLabelPosition;\n\n  /**\n   * The type of interpolation used to draw the edge.\n   */\n  interpolation?: EdgeInterpolation;\n} & EdgeEvents;\n\n/**\n * Three.js rendering starts to get slower if you have an individual mesh for each edge\n * and a high number of edges.\n *\n * Instead, we take the edges and split them into their different render states:\n *\n *  * - Active (any edges that are marked as \"selected\" or \"active\" in the state)\n *  * - Dragging (any edges that are connected to a node that is being dragged)\n *  * - Intersecting (any edges that are currently intersected by the ray from the mouse position)\n *  * - Inactive (any edges that aren't active, dragging, or intersected)\n *\n * We generate the geometry for each edge in each of these groups, and then merge them\n * into a single geometry for each group. This merged mesh is rendered as one object\n * which gives much better performance. This means that we only need to update geometry\n * and positions when edges move between the different states, rather than updating all\n * edges whenever any other edge changes.\n *\n * To get this all working, we have to do a few things outside the @react-three/fiber world,\n * specifically:\n *\n *  * manually create edge/arrow geometries (see `useEdgeGeometry`)\n *  * manually track mouse/edge interactions and fire events (see `useEdgeEvents`)\n *  * manually update edge/arrow positions during aniamations (see `useEdgeAnimations`)\n */\nexport const Edges: FC<EdgesProps> = ({\n  interpolation = 'linear',\n  arrowPlacement = 'end',\n  labelPlacement = 'inline',\n  animated,\n  contextMenu,\n  disabled,\n  edges,\n  labelFontUrl,\n  onClick,\n  onContextMenu,\n  onPointerOut,\n  onPointerOver\n}) => {\n  const theme = useStore(state => state.theme);\n  const { getGeometries, getGeometry } = useEdgeGeometry(\n    arrowPlacement,\n    interpolation\n  );\n\n  const draggingIds = useStore(state => state.draggingIds);\n  const edgeMeshes = useStore(state => state.edgeMeshes);\n  const setEdgeMeshes = useStore(state => state.setEdgeMeshes);\n  const actives = useStore(state => state.actives || []);\n  const selections = useStore(state => state.selections || []);\n  const hoveredEdgeIds = useStore(state => state.hoveredEdgeIds || []);\n\n  const [active, inactive, draggingActive, draggingInactive] = useMemo(() => {\n    const active: Array<InternalGraphEdge> = [];\n    const inactive: Array<InternalGraphEdge> = [];\n    const draggingActive: Array<InternalGraphEdge> = [];\n    const draggingInactive: Array<InternalGraphEdge> = [];\n    edges.forEach(edge => {\n      if (\n        draggingIds.includes(edge.source) ||\n        draggingIds.includes(edge.target)\n      ) {\n        if (\n          selections.includes(edge.id) ||\n          actives.includes(edge.id) ||\n          hoveredEdgeIds.includes(edge.id)\n        ) {\n          draggingActive.push(edge);\n        } else {\n          draggingInactive.push(edge);\n        }\n        return;\n      }\n\n      if (\n        selections.includes(edge.id) ||\n        actives.includes(edge.id) ||\n        hoveredEdgeIds.includes(edge.id)\n      ) {\n        active.push(edge);\n      } else {\n        inactive.push(edge);\n      }\n    });\n    return [active, inactive, draggingActive, draggingInactive];\n  }, [edges, actives, selections, draggingIds, hoveredEdgeIds]);\n\n  const hasSelections = !!selections.length;\n\n  const staticEdgesGeometry = useMemo(\n    () => getGeometry(active, inactive),\n    [getGeometry, active, inactive]\n  );\n\n  const { activeOpacity, inactiveOpacity } = useEdgeOpacityAnimation(\n    animated,\n    hasSelections,\n    theme\n  );\n\n  useEdgePositionAnimation(staticEdgesGeometry, animated);\n\n  useEffect(() => {\n    if (draggingIds.length === 0) {\n      const edgeGeometries = getGeometries(edges);\n      const edgeMeshes = edgeGeometries.map(edge => new Mesh(edge));\n      setEdgeMeshes(edgeMeshes);\n    }\n  }, [getGeometries, setEdgeMeshes, edges, draggingIds.length]);\n\n  const staticEdgesRef = useRef(new Mesh());\n  const dynamicEdgesRef = useRef(new Mesh());\n\n  const intersect = useCallback(\n    (raycaster: Raycaster): Array<InternalGraphEdge> => {\n      // Handle initial raycaster state:\n      if (!raycaster.camera) {\n        return [];\n      }\n      const intersections =\n        raycaster.intersectObjects<Mesh<TubeGeometry>>(edgeMeshes);\n      if (!intersections.length) {\n        return [];\n      }\n      return intersections.map(\n        intersection => edges[edgeMeshes.indexOf(intersection.object)]\n      );\n    },\n    [edgeMeshes, edges]\n  );\n\n  const { handleClick, handleContextMenu, handleIntersections } = useEdgeEvents(\n    {\n      onClick,\n      onContextMenu,\n      onPointerOut,\n      onPointerOver\n    },\n    contextMenu,\n    disabled\n  );\n\n  const draggingIdRef = useRef<string[]>([]);\n  const intersectingRef = useRef<Array<InternalGraphEdge>>([]);\n\n  useFrame(state => {\n    staticEdgesRef.current.geometry = staticEdgesGeometry;\n\n    if (disabled) {\n      return;\n    }\n\n    const previousDraggingId = draggingIdRef.current;\n    if (\n      draggingIds.length ||\n      (draggingIds.length === 0 && previousDraggingId !== null)\n    ) {\n      dynamicEdgesRef.current.geometry = getGeometry(\n        draggingActive,\n        draggingInactive\n      );\n    }\n\n    draggingIdRef.current = draggingIds;\n    if (draggingIds.length) {\n      return;\n    }\n\n    const previousIntersecting = intersectingRef.current;\n    const intersecting = intersect(state.raycaster);\n    handleIntersections(previousIntersecting, intersecting);\n\n    if (intersecting.join() !== previousIntersecting.join()) {\n      dynamicEdgesRef.current.geometry = getGeometry(intersecting, []);\n    }\n\n    intersectingRef.current = intersecting;\n  });\n\n  return (\n    <group onClick={handleClick} onContextMenu={handleContextMenu}>\n      {/* Static edges */}\n      <mesh ref={staticEdgesRef}>\n        <a.meshBasicMaterial\n          attach=\"material-0\"\n          color={theme.edge.fill}\n          depthTest={true}\n          fog={true}\n          opacity={inactiveOpacity}\n          side={DoubleSide}\n          transparent={true}\n          vertexColors={true}\n        />\n        <a.meshBasicMaterial\n          attach=\"material-1\"\n          color={theme.edge.activeFill}\n          depthTest={true}\n          fog={true}\n          opacity={activeOpacity}\n          side={DoubleSide}\n          transparent={true}\n        />\n      </mesh>\n      {/* Dynamic edges */}\n      <mesh ref={dynamicEdgesRef}>\n        <a.meshBasicMaterial\n          attach=\"material-0\"\n          color={theme.edge.fill}\n          depthTest={true}\n          fog={true}\n          opacity={inactiveOpacity}\n          side={DoubleSide}\n          transparent={true}\n        />\n        <a.meshBasicMaterial\n          attach=\"material-1\"\n          color={theme.edge.activeFill}\n          depthTest={true}\n          fog={true}\n          opacity={activeOpacity}\n          side={DoubleSide}\n          transparent={true}\n        />\n      </mesh>\n      {edges.map(edge => {\n        const isSelected = selections.includes(edge.id);\n        const isActive = actives.includes(edge.id);\n        const isHovered = hoveredEdgeIds.includes(edge.id);\n\n        return (\n          <Edge\n            animated={animated}\n            contextMenu={contextMenu}\n            color={\n              isSelected || isActive || isHovered\n                ? theme.edge.label.activeColor\n                : theme.edge.label.color\n            }\n            disabled={disabled}\n            edge={edge}\n            key={edge.id}\n            labelFontUrl={labelFontUrl}\n            labelPlacement={labelPlacement}\n            active={isSelected || isActive || isHovered}\n          />\n        );\n      })}\n    </group>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport { Billboard, Image, RoundedBox, Text } from '@react-three/drei';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport { Color } from 'three';\n\nimport type { NodeRendererProps } from '../../types';\nimport { animationConfig } from '../../utils';\nimport { measureText } from '../../utils/textMeasurement';\n\nexport type BadgePosition =\n  | 'top-right'\n  | 'top-left'\n  | 'bottom-right'\n  | 'bottom-left'\n  | 'center';\n\nexport type IconPosition = 'start' | 'end';\n\nexport interface BadgeProps extends Omit<NodeRendererProps, 'opacity'> {\n  /**\n   * The text to display in the badge.\n   */\n  label: string;\n\n  /**\n   * Background color of the badge.\n   */\n  backgroundColor?: string;\n\n  /**\n   * Opacity of the badge background and stroke (0-1).\n   * Default: 1\n   */\n  opacity?: number;\n\n  /**\n   * Text color of the badge.\n   */\n  textColor?: string;\n\n  /**\n   * Stroke color of the badge border.\n   */\n  strokeColor?: string;\n\n  /**\n   * Size of the badge border stroke.\n   */\n  strokeWidth?: number;\n\n  /**\n   * Corner radius of the badge.\n   */\n  radius?: number;\n\n  /**\n   * Size multiplier for the badge relative to the node size.\n   */\n  badgeSize?: number;\n\n  /**\n   * Position offset from the node center or preset position.\n   */\n  position?: [number, number, number] | BadgePosition;\n\n  /**\n   * Padding around the badge text.\n   * Default: 0.15\n   */\n  padding?: number;\n\n  /**\n   * SVG icon path or URL to display in the badge.\n   */\n  icon?: string;\n\n  /**\n   * Size of the icon in the badge.\n   */\n  iconSize?: number;\n\n  /**\n   * Position of the icon relative to the text or custom coordinates [x, y].\n   * - 'start': Icon appears before the text (left side)\n   * - 'end': Icon appears after the text (right side)\n   * - [x, y]: Custom coordinates within the badge. When using custom coordinates,\n   *   the text remains centered and only the icon moves to the specified position.\n   */\n  iconPosition?: IconPosition | [number, number];\n\n  /**\n   * Font size for the badge text.\n   */\n  fontSize?: number;\n\n  /**\n   * Font weight for the badge text (100-900).\n   * Values outside this range will be clamped to the nearest valid value.\n   * Common values: 400 (normal), 700 (bold), 900 (extra bold).\n   */\n  fontWeight?: number;\n\n  /**\n   * Gap between icon and text.\n   * Default: 0.01\n   */\n  iconTextGap?: number;\n}\n\nconst DEFAULT_FONT_SIZE = 0.3;\n\nexport const Badge: FC<BadgeProps> = ({\n  label,\n  size,\n  opacity = 1,\n  animated,\n  backgroundColor = '#ffffff',\n  textColor = '#000000',\n  strokeColor,\n  strokeWidth = 0,\n  radius = 0.12,\n  badgeSize = 1.5,\n  position = 'top-right',\n  padding = 0.15,\n  icon,\n  iconSize = 0.35,\n  iconPosition = 'start',\n  fontSize = DEFAULT_FONT_SIZE,\n  fontWeight,\n  iconTextGap = 0.01\n}) => {\n  const normalizedBgColor = useMemo(\n    () => new Color(backgroundColor),\n    [backgroundColor]\n  );\n  const normalizedTextColor = useMemo(() => new Color(textColor), [textColor]);\n  const normalizedStrokeColor = useMemo(\n    () => (strokeColor ? new Color(strokeColor) : null),\n    [strokeColor]\n  );\n  // Guard for radius\n  const normalizedRadius = Math.min(radius, 0.2);\n\n  // Normalize fontWeight to valid CSS font-weight values (100-900 in increments of 100)\n  const normalizedFontWeight = useMemo(() => {\n    if (fontWeight === undefined) return undefined;\n    // Round to nearest hundred and clamp to 100-900 range\n    return Math.max(100, Math.min(900, Math.round(fontWeight / 100) * 100));\n  }, [fontWeight]);\n\n  // Calculate position based on preset or custom coordinates\n  const badgePosition = useMemo((): [number, number, number] => {\n    if (Array.isArray(position)) {\n      return position;\n    }\n\n    const offset = size * 0.65;\n    switch (position) {\n      case 'top-right':\n        return [offset, offset, 11];\n      case 'top-left':\n        return [-offset, offset, 11];\n      case 'bottom-right':\n        return [offset, -offset, 11];\n      case 'bottom-left':\n        return [-offset, -offset, 11];\n      case 'center':\n        return [0, 0, 11];\n      default:\n        return [offset, offset, 11];\n    }\n  }, [position, size]);\n\n  // Shared text size calculations (used by both badgeDimensions and contentLayout)\n  const textSizeCalculations = useMemo(() => {\n    const fontSizeScale = fontSize / DEFAULT_FONT_SIZE;\n    const fontWeightMultiplier = (normalizedFontWeight ?? 0) >= 700 ? 1.1 : 1;\n\n    // Use Canvas measureText for accurate width when charWidthEstimate is not provided\n    const measured = measureText({\n      text: label,\n      fontSize,\n      fontWeight: normalizedFontWeight\n    });\n    const estimatedTextWidth = measured.width;\n\n    return {\n      fontSizeScale,\n      fontWeightMultiplier,\n      estimatedTextWidth\n    };\n  }, [fontSize, normalizedFontWeight, label]);\n\n  // Calculate dynamic badge dimensions based on text length and icon\n  const badgeDimensions = useMemo(() => {\n    const baseWidth = 0.5;\n    const baseHeight = 0.5;\n    const minWidth = baseWidth;\n    const minHeight = baseHeight;\n\n    const { fontSizeScale, estimatedTextWidth } = textSizeCalculations;\n\n    // Calculate content width (text + icon + gap, no padding yet)\n    let contentWidth = estimatedTextWidth;\n    if (icon) {\n      contentWidth += iconSize + iconTextGap;\n    }\n\n    // Add padding to total width (padding on both left and right sides)\n    const estimatedWidth = Math.max(minWidth, contentWidth + padding * 2);\n\n    // Scale height based on fontSize\n    const charCount = label?.length;\n    const estimatedHeight = Math.max(\n      minHeight,\n      Math.min(\n        charCount * 0.05 * fontSizeScale + padding * 0.5,\n        0.8 * fontSizeScale + padding * 0.5\n      )\n    );\n\n    return {\n      width: estimatedWidth,\n      height: estimatedHeight\n    };\n  }, [\n    textSizeCalculations,\n    label?.length,\n    padding,\n    icon,\n    iconSize,\n    iconTextGap\n  ]);\n\n  const { scale } = useSpring({\n    from: {\n      scale: [0.00001, 0.00001, 0.00001]\n    },\n    to: {\n      scale: [size * badgeSize, size * badgeSize, size * badgeSize]\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  // Calculate content layout positions for icon and text\n  const contentLayout = useMemo(() => {\n    if (!icon) {\n      return {\n        textX: 0,\n        textY: 0,\n        iconX: 0,\n        iconY: 0\n      };\n    }\n\n    // If custom position is provided as an array\n    if (Array.isArray(iconPosition)) {\n      return {\n        iconX: iconPosition[0],\n        iconY: iconPosition[1],\n        textX: 0,\n        textY: 0\n      };\n    }\n\n    const { estimatedTextWidth } = textSizeCalculations;\n    const totalContentWidth = iconSize + iconTextGap + estimatedTextWidth;\n    const startX = -totalContentWidth / 2;\n\n    if (iconPosition === 'start') {\n      return {\n        iconX: startX + iconSize / 2,\n        iconY: 0,\n        textX: startX + iconSize + iconTextGap + estimatedTextWidth / 2,\n        textY: 0\n      };\n    } else {\n      return {\n        textX: startX + estimatedTextWidth / 2,\n        textY: 0,\n        iconX: startX + estimatedTextWidth + iconTextGap + iconSize / 2,\n        iconY: 0\n      };\n    }\n  }, [textSizeCalculations, icon, iconSize, iconPosition, iconTextGap]);\n\n  return (\n    <Billboard position={badgePosition}>\n      <a.group scale={scale as any} renderOrder={2}>\n        {/* Stroke layer */}\n        {strokeWidth > 0 && normalizedStrokeColor && (\n          <a.mesh position={[0, 0, 0.9]}>\n            <RoundedBox\n              args={[\n                badgeDimensions.width + strokeWidth,\n                badgeDimensions.height + strokeWidth,\n                0.01\n              ]}\n              radius={normalizedRadius}\n              smoothness={8}\n              material-color={normalizedStrokeColor}\n              material-transparent={true}\n              material-opacity={opacity}\n            />\n          </a.mesh>\n        )}\n        {/* Main background layer */}\n        <a.mesh position={[0, 0, 1]}>\n          <RoundedBox\n            args={[badgeDimensions.width, badgeDimensions.height, 0.01]} // dynamic width, height, depth\n            radius={normalizedRadius} // corner radius\n            smoothness={8}\n            material-color={normalizedBgColor}\n            material-transparent={true}\n            material-opacity={opacity}\n          />\n        </a.mesh>\n        {/* Icon */}\n        {icon && (\n          <Image\n            url={icon}\n            position={[contentLayout.iconX, contentLayout.iconY, 1.1]}\n            scale={[iconSize, iconSize]}\n            transparent\n            material-depthTest={false}\n            material-depthWrite={false}\n          />\n        )}\n        {/* Text */}\n        <Text\n          position={[contentLayout.textX, contentLayout.textY, 1.1]}\n          fontSize={fontSize}\n          fontWeight={normalizedFontWeight}\n          color={normalizedTextColor}\n          anchorX=\"center\"\n          anchorY=\"middle\"\n          textAlign=\"center\"\n          material-depthTest={false}\n          material-depthWrite={false}\n        >\n          {label}\n        </Text>\n      </a.group>\n    </Billboard>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport { DoubleSide, LinearFilter, TextureLoader } from 'three';\n\nimport type { NodeRendererProps } from '../../types';\nimport { animationConfig } from '../../utils';\n\nexport interface IconProps extends NodeRendererProps {\n  /**\n   * The image to display on the icon.\n   */\n  image: string;\n}\n\nexport const Icon: FC<IconProps> = ({\n  image,\n  id,\n  size,\n  opacity = 1,\n  animated\n}) => {\n  const texture = useMemo(() => new TextureLoader().load(image), [image]);\n\n  const { scale, spriteOpacity } = useSpring({\n    from: {\n      scale: [0.00001, 0.00001, 0.00001],\n      spriteOpacity: 0\n    },\n    to: {\n      scale: [size, size, size],\n      spriteOpacity: opacity\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  return (\n    <a.sprite userData={{ id, type: 'node' }} scale={scale as any}>\n      <a.spriteMaterial\n        attach=\"material\"\n        opacity={spriteOpacity}\n        fog={true}\n        depthTest={false}\n        transparent={true}\n        side={DoubleSide}\n      >\n        <primitive attach=\"map\" object={texture} minFilter={LinearFilter} />\n      </a.spriteMaterial>\n    </a.sprite>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport { Billboard } from '@react-three/drei';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport type { ColorRepresentation } from 'three';\nimport { Color, DoubleSide } from 'three';\n\nimport { animationConfig } from '../utils/animation';\n\nexport interface RingProps {\n  /**\n   * The color of the ring.\n   */\n  color?: ColorRepresentation;\n\n  /**\n   * Whether the ring should be animated.\n   */\n  animated?: boolean;\n\n  /**\n   * The size of the ring.\n   */\n  size?: number;\n\n  /**\n   * The opacity of the ring.\n   */\n  opacity?: number;\n\n  /**\n   * The stroke width of the ring.\n   */\n  strokeWidth?: number;\n\n  /**\n   * The inner radius of the ring.\n   * Default value: 4\n   */\n  innerRadius?: number;\n\n  /**\n   * The number of segments in the ring geometry.\n   * Default value: 25\n   */\n  segments?: number;\n}\n\nexport const Ring: FC<RingProps> = ({\n  color = '#D8E6EA',\n  size = 1,\n  opacity = 0.5,\n  animated,\n  strokeWidth,\n  innerRadius = 2,\n  segments = 50\n}) => {\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n\n  const { ringSize, ringOpacity } = useSpring({\n    from: {\n      ringOpacity: 0,\n      ringSize: [0.00001, 0.00001, 0.00001]\n    },\n    to: {\n      ringOpacity: opacity,\n      ringSize: [size / 2, size / 2, 1]\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  const strokeWidthFraction = strokeWidth / 10;\n  const outerRadius = innerRadius + strokeWidthFraction;\n\n  return (\n    <Billboard position={[0, 0, 1]}>\n      <a.mesh\n        scale={ringSize as any}\n        // Disabling raycast/pointer events when ring is invisible (opacity = 0)\n        // This prevents invisible rings highlighting parent nodes when hovered over\n        raycast={opacity > 0 ? undefined : () => []}\n      >\n        <ringGeometry\n          attach=\"geometry\"\n          args={[innerRadius, outerRadius, segments]}\n        />\n        <a.meshBasicMaterial\n          attach=\"material\"\n          color={normalizedColor}\n          transparent={true}\n          depthTest={true}\n          opacity={ringOpacity}\n          side={DoubleSide}\n          fog={true}\n        />\n      </a.mesh>\n    </Billboard>\n  );\n};\n","import { a, useSpring } from '@react-spring/three';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport { Color, DoubleSide } from 'three';\n\nimport { useStore } from '../../store';\nimport type { NodeRendererProps } from '../../types';\nimport { animationConfig } from '../../utils/animation';\nimport { Ring } from '../Ring';\n\nexport const Sphere: FC<NodeRendererProps> = ({\n  color,\n  id,\n  size,\n  selected,\n  active,\n  opacity,\n  animated,\n  showRing\n}) => {\n  const { scale, nodeOpacity } = useSpring({\n    from: {\n      // Note: This prevents incorrect scaling w/ 0\n      scale: [0.00001, 0.00001, 0.00001],\n      nodeOpacity: 0\n    },\n    to: {\n      scale: active\n        ? [size * 1.05, size * 1.05, size * 1.05]\n        : [size, size, size],\n      nodeOpacity: opacity\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n  const theme = useStore(state => state.theme);\n\n  return (\n    <>\n      <a.mesh userData={{ id, type: 'node' }} scale={scale as any}>\n        <sphereGeometry attach=\"geometry\" args={[1, 25, 25]} />\n        <a.meshPhongMaterial\n          attach=\"material\"\n          side={DoubleSide}\n          transparent={true}\n          fog={true}\n          opacity={nodeOpacity}\n          color={normalizedColor}\n          emissive={normalizedColor}\n          emissiveIntensity={0.7}\n        />\n      </a.mesh>\n      {(showRing || selected || active) && (\n        <a.mesh position={[0, 0, 0]}>\n          <Ring\n            opacity={1}\n            size={size / 1}\n            animated={animated}\n            color={theme.ring.activeFill}\n            strokeWidth={5}\n          />\n        </a.mesh>\n      )}\n    </>\n  );\n};\n","import type { FC } from 'react';\nimport React from 'react';\n\nimport type { NodeRendererProps } from '../../types';\nimport { Icon } from './Icon';\nimport { Sphere } from './Sphere';\n\nexport interface SphereWithIconProps extends NodeRendererProps {\n  /**\n   * The image to display on the icon.\n   */\n  image: string;\n}\n\nexport const SphereWithIcon: FC<SphereWithIconProps> = ({\n  color,\n  id,\n  size,\n  opacity = 1,\n  node,\n  active = false,\n  animated,\n  image,\n  selected\n}) => (\n  <>\n    <Sphere\n      id={id}\n      selected={selected}\n      size={size}\n      opacity={opacity}\n      animated={animated}\n      color={color}\n      node={node}\n      active={active}\n      showRing={node.showRing}\n    />\n    <Icon\n      id={id}\n      image={image}\n      selected={selected}\n      size={size + 8}\n      opacity={opacity}\n      animated={animated}\n      color={color}\n      node={node}\n      active={active}\n    />\n  </>\n);\n","import { a, useSpring } from '@react-spring/three';\nimport type { SvgProps as DreiSvgProps } from '@react-three/drei';\nimport { Billboard, Svg as DreiSvg } from '@react-three/drei';\nimport type { FC } from 'react';\nimport React, { useMemo } from 'react';\nimport { Color, DoubleSide } from 'three';\n\nimport type { NodeRendererProps } from '../../types';\nimport { animationConfig } from '../../utils';\n\nexport type SvgProps = NodeRendererProps &\n  Omit<DreiSvgProps, 'src' | 'id'> & {\n    /**\n     * The image to display on the icon.\n     */\n    image: string;\n  };\n\nexport const Svg: FC<SvgProps> = ({\n  id,\n  image,\n  color,\n  size,\n  opacity = 1,\n  animated,\n  ...rest\n}) => {\n  const normalizedSize = size / 25;\n\n  const { scale } = useSpring({\n    from: {\n      scale: [0.00001, 0.00001, 0.00001]\n    },\n    to: {\n      scale: [normalizedSize, normalizedSize, normalizedSize]\n    },\n    config: {\n      ...animationConfig,\n      duration: animated ? undefined : 0\n    }\n  });\n\n  const normalizedColor = useMemo(() => new Color(color), [color]);\n\n  return (\n    <a.group userData={{ id, type: 'node' }} scale={scale as any}>\n      <Billboard position={[0, 0, 1]}>\n        <DreiSvg\n          {...rest}\n          src={image}\n          fillMaterial={{\n            fog: true,\n            depthTest: false,\n            transparent: true,\n            color: normalizedColor,\n            opacity,\n            side: DoubleSide,\n            ...(rest.fillMaterial || {})\n          }}\n          fillMeshProps={{\n            // Note: This is a hack to get the svg to\n            // render in the correct position.\n            position: [-25, -25, 1],\n            ...(rest.fillMeshProps || {})\n          }}\n        />\n      </Billboard>\n    </a.group>\n  );\n};\n","import type { FC } from 'react';\nimport React from 'react';\nimport type { ColorRepresentation } from 'three';\n\nimport { Sphere } from './Sphere';\nimport type { SvgProps } from './Svg';\nimport { Svg } from './Svg';\n\nexport interface SphereWithSvgProps extends SvgProps {\n  /**\n   * The image to display on the icon.\n   */\n  image: string;\n\n  /**\n   * The color of the svg fill.\n   */\n  svgFill?: ColorRepresentation;\n}\n\nexport const SphereWithSvg: FC<SphereWithSvgProps> = ({\n  color,\n  id,\n  size,\n  opacity = 1,\n  node,\n  svgFill,\n  active = false,\n  animated,\n  image,\n  selected,\n  ...rest\n}) => (\n  <>\n    <Sphere\n      id={id}\n      selected={selected}\n      size={size}\n      opacity={opacity}\n      animated={animated}\n      color={color}\n      node={node}\n      active={active}\n    />\n    <Svg\n      {...rest}\n      id={id}\n      selected={selected}\n      image={image}\n      size={size}\n      opacity={opacity}\n      animated={animated}\n      color={svgFill}\n      node={node}\n      active={active}\n    />\n  </>\n);\n","import { a, useSpring } from '@react-spring/three';\nimport { Html, useCursor } from '@react-three/drei';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport type { FC, ReactNode } from 'react';\nimport React, { useCallback, useMemo, useRef, useState } from 'react';\nimport type { Group } from 'three';\n\nimport { useCameraControls } from '../CameraControls/useCameraControls';\nimport { useStore } from '../store';\nimport type {\n  CollapseProps,\n  ContextMenuEvent,\n  InternalGraphNode,\n  NodeContextMenuProps,\n  NodeRenderer\n} from '../types';\nimport { animationConfig } from '../utils';\nimport { useDrag } from '../utils/useDrag';\nimport { useHoverIntent } from '../utils/useHoverIntent';\nimport { Label } from './Label';\nimport { Icon } from './nodes';\nimport { Sphere } from './nodes/Sphere';\n\nexport interface NodeProps {\n  /**\n   * The unique identifier for the node.\n   */\n  id: string;\n\n  /**\n   * The parent nodes of the node.\n   */\n  parents?: string[];\n\n  /**\n   * Whether the node is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether the node is animated.\n   */\n  animated?: boolean;\n\n  /**\n   * Whether the node is draggable.\n   */\n  draggable?: boolean;\n\n  /**\n   * Constrain dragging to the cluster bounds.\n   */\n  constrainDragging?: boolean;\n\n  /**\n   * The url for the label font.\n   */\n  labelFontUrl?: string;\n\n  /**\n   * The function to use to render the node.\n   */\n  renderNode?: NodeRenderer;\n\n  /**\n   * The context menu for the node.\n   */\n  contextMenu?: (event: ContextMenuEvent) => ReactNode;\n\n  /**\n   * The function to call when the pointer is over the node.\n   */\n  onPointerOver?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * The function to call when the pointer is out of the node.\n   */\n  onPointerOut?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * The function to call when the node is clicked.\n   */\n  onClick?: (\n    node: InternalGraphNode,\n    props?: CollapseProps,\n    event?: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * The function to call when the node is double clicked.\n   */\n  onDoubleClick?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * The function to call when the node is right clicked.\n   */\n  onContextMenu?: (\n    node?: InternalGraphNode,\n    props?: NodeContextMenuProps\n  ) => void;\n\n  /**\n   * Triggered after a node was dragged.\n   */\n  onDragged?: (node: InternalGraphNode) => void;\n}\n\nexport const Node: FC<NodeProps> = ({\n  animated,\n  disabled,\n  id,\n  draggable = false,\n  labelFontUrl,\n  contextMenu,\n  onClick,\n  onDoubleClick,\n  onPointerOver,\n  onDragged,\n  onPointerOut,\n  onContextMenu,\n  renderNode,\n  constrainDragging\n}) => {\n  const cameraControls = useCameraControls();\n  const theme = useStore(state => state.theme);\n  const node = useStore(state => state.nodes.find(n => n.id === id));\n  const edges = useStore(state => state.edges);\n  const draggingIds = useStore(state => state.draggingIds);\n  const collapsedNodeIds = useStore(state => state.collapsedNodeIds);\n  const addDraggingId = useStore(state => state.addDraggingId);\n  const removeDraggingId = useStore(state => state.removeDraggingId);\n  const setHoveredNodeId = useStore(state => state.setHoveredNodeId);\n  const setNodePosition = useStore(state => state.setNodePosition);\n  const setCollapsedNodeIds = useStore(state => state.setCollapsedNodeIds);\n  const isCollapsed = useStore(state => state.collapsedNodeIds.includes(id));\n  const isActive = useStore(state => state.actives?.includes(id));\n  const isSelected = useStore(state => state.selections?.includes(id));\n  const hasSelections = useStore(state => state.selections?.length > 0);\n  const center = useStore(state => state.centerPosition);\n  const cluster = useStore(state => state.clusters.get(node.cluster));\n\n  const isDraggingCurrent = draggingIds.includes(id);\n  const isDragging = draggingIds.length > 0;\n\n  const {\n    position,\n    label,\n    subLabel,\n    size: nodeSize = 7,\n    labelVisible = true\n  } = node;\n\n  const group = useRef<Group | null>(null);\n  const [active, setActive] = useState<boolean>(false);\n  const [menuVisible, setMenuVisible] = useState<boolean>(false);\n\n  const shouldHighlight = active || isSelected || isActive;\n\n  const selectionOpacity = hasSelections\n    ? shouldHighlight\n      ? theme.node.selectedOpacity\n      : theme.node.inactiveOpacity\n    : theme.node.opacity;\n\n  const canCollapse = useMemo(() => {\n    // If the node has outgoing edges, it can collapse via context menu\n    const outboundLinks = edges.filter(l => l.source === id);\n\n    return outboundLinks.length > 0 || isCollapsed;\n  }, [edges, id, isCollapsed]);\n\n  const onCollapse = useCallback(() => {\n    if (canCollapse) {\n      if (isCollapsed) {\n        setCollapsedNodeIds(collapsedNodeIds.filter(p => p !== id));\n      } else {\n        setCollapsedNodeIds([...collapsedNodeIds, id]);\n      }\n    }\n  }, [canCollapse, collapsedNodeIds, id, isCollapsed, setCollapsedNodeIds]);\n\n  const [{ nodePosition, labelPosition }] = useSpring(\n    () => ({\n      from: {\n        nodePosition: center ? [center.x, center.y, 0] : [0, 0, 0],\n        labelPosition: [0, -(nodeSize + 4), 2],\n        subLabelPosition: [0, -(nodeSize + 14), 2]\n      },\n      to: {\n        nodePosition: position\n          ? [\n              position.x,\n              position.y,\n              shouldHighlight ? position.z + 50 : position.z\n            ]\n          : [0, 0, 0],\n        labelPosition: [0, -(nodeSize + 4), 2],\n        subLabelPosition: [0, -(nodeSize + 14), 2]\n      },\n      config: {\n        ...animationConfig,\n        duration: animated && !isDragging ? undefined : 0\n      }\n    }),\n    [isDraggingCurrent, position, animated, nodeSize, shouldHighlight]\n  );\n\n  const bind = useDrag({\n    draggable,\n    position,\n    // If dragging is constrained to the cluster, use the cluster's position as the bounds\n    bounds: constrainDragging ? cluster?.position : undefined,\n    // @ts-ignore\n    set: pos => setNodePosition(id, pos),\n    onDragStart: () => {\n      addDraggingId(id);\n      setActive(true);\n    },\n    onDragEnd: () => {\n      removeDraggingId(id);\n      onDragged?.(node);\n    }\n  });\n\n  useCursor(active && !isDragging && onClick !== undefined, 'pointer');\n  useCursor(\n    active && draggable && !isDraggingCurrent && onClick === undefined,\n    'grab'\n  );\n  useCursor(isDraggingCurrent, 'grabbing');\n\n  const combinedActiveState = shouldHighlight || isDraggingCurrent;\n  const color = combinedActiveState\n    ? node.activeFill || theme.node.activeFill\n    : node.fill || theme.node.fill;\n\n  const actualShowRing = node.showRing;\n  const { pointerOver, pointerOut } = useHoverIntent({\n    disabled: disabled || isDraggingCurrent,\n    onPointerOver: (event: ThreeEvent<PointerEvent>) => {\n      cameraControls.freeze();\n      setActive(true);\n      onPointerOver?.(node, event);\n      setHoveredNodeId(id);\n    },\n    onPointerOut: (event: ThreeEvent<PointerEvent>) => {\n      cameraControls.unFreeze();\n      setActive(false);\n      onPointerOut?.(node, event);\n      setHoveredNodeId(null);\n    }\n  });\n\n  const nodeComponent = useMemo(\n    () =>\n      renderNode ? (\n        renderNode({\n          id,\n          color,\n          size: nodeSize,\n          active: combinedActiveState,\n          opacity: selectionOpacity,\n          animated,\n          selected: isSelected,\n          node\n        })\n      ) : (\n        <>\n          {node.icon ? (\n            <Icon\n              id={id}\n              image={node.icon || ''}\n              size={nodeSize + 8}\n              opacity={selectionOpacity}\n              animated={animated}\n              color={color}\n              node={node}\n              active={combinedActiveState}\n              selected={isSelected}\n            />\n          ) : (\n            <Sphere\n              id={id}\n              size={nodeSize}\n              opacity={selectionOpacity}\n              animated={animated}\n              color={color}\n              node={node}\n              active={combinedActiveState}\n              selected={isSelected}\n              showRing={actualShowRing}\n            />\n          )}\n        </>\n      ),\n    [\n      renderNode,\n      id,\n      color,\n      nodeSize,\n      combinedActiveState,\n      selectionOpacity,\n      animated,\n      isSelected,\n      node,\n      actualShowRing\n    ]\n  );\n\n  const labelComponent = useMemo(\n    () =>\n      label && (\n        <>\n          <a.group position={labelPosition as any}>\n            <Label\n              text={label}\n              fontUrl={labelFontUrl}\n              opacity={selectionOpacity}\n              stroke={theme.node.label.stroke}\n              maxWidth={theme.node.label.maxWidth}\n              ellipsis={theme.node.label.ellipsis}\n              backgroundColor={theme.node.label.backgroundColor}\n              borderRadius={theme.node.label.borderRadius}\n              active={isSelected || active || isDragging || isActive}\n              color={\n                isSelected || active || isDragging || isActive\n                  ? theme.node.label.activeColor\n                  : theme.node.label.color\n              }\n              type=\"node\"\n              labelVisible={labelVisible}\n            />\n          </a.group>\n          {subLabel && (\n            <group position={[0, -(nodeSize - 3), 0]}>\n              <Label\n                text={subLabel}\n                fontUrl={labelFontUrl}\n                fontSize={theme.node.label.fontSize}\n                maxWidth={theme.node.label.maxWidth}\n                ellipsis={theme.node.label.ellipsis}\n                backgroundColor={theme.node.label.backgroundColor}\n                borderRadius={theme.node.label.borderRadius}\n                opacity={selectionOpacity}\n                stroke={theme.node.subLabel?.stroke}\n                active={isSelected || active || isDraggingCurrent || isActive}\n                color={\n                  isSelected || active || isDraggingCurrent || isActive\n                    ? theme.node.subLabel?.activeColor\n                    : theme.node.subLabel?.color\n                }\n                labelVisible={labelVisible}\n              />\n            </group>\n          )}\n        </>\n      ),\n    [\n      active,\n      isActive,\n      isDraggingCurrent,\n      isSelected,\n      label,\n      labelFontUrl,\n      labelPosition,\n      labelVisible,\n      nodeSize,\n      selectionOpacity,\n      subLabel,\n      theme.node.label.activeColor,\n      theme.node.label.color,\n      theme.node.label.stroke,\n      theme.node.label.backgroundColor,\n      theme.node.label.backgroundOpacity,\n      theme.node.label.padding,\n      theme.node.label.strokeColor,\n      theme.node.label.strokeWidth,\n      theme.node.label.radius,\n      theme.node.subLabel?.activeColor,\n      theme.node.subLabel?.color,\n      theme.node.subLabel?.stroke,\n      theme.node.label.fontSize,\n      theme.node.label.maxWidth,\n      theme.node.label.ellipsis,\n      theme.node.label.backgroundColor,\n      theme.node.label.borderRadius\n    ]\n  );\n\n  const menuComponent = useMemo(\n    () =>\n      menuVisible &&\n      contextMenu && (\n        <Html prepend={true} center={true}>\n          {contextMenu({\n            data: node,\n            canCollapse,\n            isCollapsed,\n            onCollapse,\n            onClose: () => setMenuVisible(false)\n          })}\n        </Html>\n      ),\n    [menuVisible, contextMenu, node, canCollapse, isCollapsed, onCollapse]\n  );\n\n  return (\n    <a.group\n      renderOrder={1}\n      userData={{ id, type: 'node' }}\n      ref={group}\n      position={nodePosition as any}\n      onPointerOver={pointerOver}\n      onPointerOut={pointerOut}\n      onClick={(event: ThreeEvent<MouseEvent>) => {\n        if (!disabled && !isDraggingCurrent) {\n          onClick?.(\n            node,\n            {\n              canCollapse,\n              isCollapsed\n            },\n            event\n          );\n        }\n      }}\n      onDoubleClick={(event: ThreeEvent<MouseEvent>) => {\n        event.stopPropagation();\n        if (!disabled && !isDraggingCurrent) {\n          onDoubleClick?.(node, event);\n        }\n      }}\n      onContextMenu={() => {\n        if (!disabled) {\n          setMenuVisible(true);\n          onContextMenu?.(node, {\n            canCollapse,\n            isCollapsed,\n            onCollapse\n          });\n        }\n      }}\n      {...(bind() as any)}\n    >\n      {nodeComponent}\n      {menuComponent}\n      {labelComponent}\n    </a.group>\n  );\n};\n","import type Graph from 'graphology';\n\nimport type { InternalGraphEdge, InternalGraphNode } from '../types';\nimport type { LayoutStrategy } from './types';\n\n/**\n * Promise based tick helper.\n */\nexport function tick(layout: LayoutStrategy) {\n  return new Promise((resolve, _reject) => {\n    let stable: boolean | undefined;\n\n    function run() {\n      if (!stable) {\n        stable = layout.step();\n        run();\n      } else {\n        resolve(stable);\n      }\n    }\n\n    run();\n  });\n}\n\n/**\n * Helper function to turn the graph nodes/edges into an array for\n * easier manipulation.\n */\nexport function buildNodeEdges(graph: Graph) {\n  const nodes: InternalGraphNode[] = [];\n  const edges: InternalGraphEdge[] = [];\n\n  graph.forEachNode((id, n: any) => {\n    nodes.push({\n      ...n,\n      id,\n      // This is for the clustering\n      radius: n.size || 1\n    });\n  });\n\n  graph.forEachEdge((id, l: any) => {\n    edges.push({ ...l, id });\n  });\n\n  return { nodes, edges };\n}\n","import circular from 'graphology-layout/circular.js';\n\nimport { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps } from './types';\n\nexport interface CircularLayoutInputs extends LayoutFactoryProps {\n  /**\n   * Radius of the circle.\n   */\n  radius: number;\n}\n\nexport function circular2d({\n  graph,\n  radius,\n  drags,\n  getNodePosition\n}: CircularLayoutInputs) {\n  const layout = circular(graph, {\n    scale: radius\n  });\n\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) {\n          return pos;\n        }\n      }\n\n      if (drags?.[id]?.position) {\n        // If we dragged, we need to use that position\n        return drags?.[id]?.position as any;\n      }\n\n      return layout?.[id];\n    }\n  };\n}\n","import { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps } from './types';\n\nexport interface ConcentricLayoutInputs extends LayoutFactoryProps {\n  /**\n   * Base radius of the innermost circle.\n   */\n  radius: number;\n  /**\n   * Distance between circles.\n   */\n  concentricSpacing?: number;\n}\n\n/**\n * Concentric layout algorithm for 2D graphs.\n * @param graph\n * @param radius\n * @param drags\n * @param getNodePosition\n * @param concentricSpacing\n */\nexport function concentric2d({\n  graph,\n  radius = 40,\n  drags,\n  getNodePosition,\n  concentricSpacing = 100\n}: ConcentricLayoutInputs) {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  const layout: Record<string, { x: number; y: number }> = {};\n\n  const getNodesInLevel = (level: number) => {\n    const circumference = 2 * Math.PI * (radius + level * concentricSpacing);\n    const minNodeSpacing = 40;\n    return Math.floor(circumference / minNodeSpacing);\n  };\n\n  const fixedLevelMap = new Map<number, string[]>();\n  const dynamicNodes: { id: string; metric: number }[] = [];\n\n  // Split nodes: fixed-level and dynamic\n  for (const node of nodes) {\n    const data = graph.getNodeAttribute(node.id, 'data');\n    const level = data?.level;\n\n    if (typeof level === 'number' && level >= 0) {\n      if (!fixedLevelMap.has(level)) {\n        fixedLevelMap.set(level, []);\n      }\n      fixedLevelMap.get(level)!.push(node.id);\n    } else {\n      dynamicNodes.push({ id: node.id, metric: graph.degree(node.id) });\n    }\n  }\n\n  // Sort dynamic nodes by degree\n  dynamicNodes.sort((a, b) => b.metric - a.metric);\n\n  // Fill layout for fixed-level nodes\n  for (const [level, nodeIds] of fixedLevelMap.entries()) {\n    const count = nodeIds.length;\n    const r = radius + level * concentricSpacing;\n\n    for (let i = 0; i < count; i++) {\n      const angle = (2 * Math.PI * i) / count;\n      layout[nodeIds[i]] = {\n        x: r * Math.cos(angle),\n        y: r * Math.sin(angle)\n      };\n    }\n  }\n\n  // Determine which levels are partially used and which are available\n  const occupiedLevels = new Set(fixedLevelMap.keys());\n  let dynamicLevel = 0;\n\n  let i = 0;\n  while (i < dynamicNodes.length) {\n    // Skip occupied levels\n    while (occupiedLevels.has(dynamicLevel)) {\n      dynamicLevel++;\n    }\n\n    const nodesInLevel = getNodesInLevel(dynamicLevel);\n    const r = radius + dynamicLevel * concentricSpacing;\n\n    for (let j = 0; j < nodesInLevel && i < dynamicNodes.length; j++) {\n      const angle = (2 * Math.PI * j) / nodesInLevel;\n      layout[dynamicNodes[i].id] = {\n        x: r * Math.cos(angle),\n        y: r * Math.sin(angle)\n      };\n      i++;\n    }\n\n    dynamicLevel++;\n  }\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) return pos;\n      }\n\n      if (drags?.[id]?.position) {\n        return drags[id].position as any;\n      }\n\n      return layout[id];\n    }\n  };\n}\n","import { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps } from './types';\n\nexport function custom({ graph, drags, getNodePosition }: LayoutFactoryProps) {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      return getNodePosition(id, { graph, drags, nodes, edges });\n    }\n  };\n}\n","import type { InternalGraphEdge, InternalGraphNode } from '../types';\n\nexport interface DepthNode {\n  data: InternalGraphNode;\n  ins: DepthNode[];\n  out: DepthNode[];\n  depth: number;\n}\n\n/**\n * Traverse the graph and get the depth of each node.\n */\nfunction traverseGraph(nodes: DepthNode[], nodeStack: DepthNode[] = []) {\n  const currentDepth = nodeStack.length;\n\n  for (const node of nodes) {\n    const idx = nodeStack.indexOf(node);\n    if (idx > -1) {\n      const loop = [...nodeStack.slice(idx), node].map(d => d.data.id);\n      throw new Error(\n        `Invalid Graph: Circular node path detected: ${loop.join(' -> ')}.`\n      );\n    }\n\n    if (currentDepth > node.depth) {\n      node.depth = currentDepth;\n      traverseGraph(node.out, [...nodeStack, node]);\n    }\n  }\n}\n\n/**\n * Gets the depth of the graph's nodes. Used in the radial layout.\n */\nexport function getNodeDepth(\n  nodes: InternalGraphNode[],\n  links: InternalGraphEdge[]\n) {\n  let invalid = false;\n\n  const graph: { [key: string]: DepthNode } = nodes.reduce(\n    (acc, cur) => ({\n      ...acc,\n      [cur.id]: {\n        data: cur,\n        out: [],\n        depth: -1,\n        ins: []\n      }\n    }),\n    {}\n  );\n\n  try {\n    for (const link of links) {\n      const from = link.source;\n      const to = link.target;\n\n      /* eslint-disable no-prototype-builtins */\n      if (!graph.hasOwnProperty(from)) {\n        throw new Error(`Missing source Node ${from}`);\n      }\n      /* eslint-disable no-prototype-builtins */\n      if (!graph.hasOwnProperty(to)) {\n        throw new Error(`Missing target Node ${to}`);\n      }\n\n      const sourceNode = graph[from];\n      const targetNode = graph[to];\n      targetNode.ins.push(sourceNode);\n      sourceNode.out.push(targetNode);\n    }\n\n    traverseGraph(Object.values(graph));\n  } catch (e) {\n    invalid = true;\n  }\n\n  const allDepths = Object.keys(graph).map(id => graph[id].depth);\n  const maxDepth = Math.max(...allDepths);\n\n  return {\n    invalid,\n    depths: graph,\n    maxDepth: maxDepth || 1\n  };\n}\n","import random from 'graphology-layout/random.js';\nimport forceAtlas2Layout from 'graphology-layout-forceatlas2';\n\nimport type { LayoutFactoryProps } from './types';\n\nexport interface ForceAtlas2LayoutInputs extends LayoutFactoryProps {\n  /**\n   * Should the nodes sizes be taken into account. Default: false.\n   */\n  adjustSizes?: boolean;\n\n  /**\n   * whether to use the Barnes-Hut approximation to compute\n   * repulsion in O(n*log(n)) rather than default O(n^2),\n   * n being the number of nodes. Default: false.\n   */\n  barnesHutOptimize?: boolean;\n\n  /**\n   * Barnes-Hut approximation theta parameter. Default: 0.5.\n   */\n  barnesHutTheta?: number;\n\n  /**\n   * Influence of the edges weights on the layout. To consider edge weight, dont\n   *  forget to pass weighted as true. Default: 1.\n   */\n  edgeWeightInfluence?: number;\n\n  /**\n   * Strength of the layouts gravity. Default: 10.\n   */\n  gravity?: number;\n\n  /**\n   * Whether to use Noacks LinLog model. Default: false.\n   */\n  linLogMode?: boolean;\n\n  /**\n   * Whether to consider edge weights when calculating repulsion. Default: false.\n   */\n  outboundAttractionDistribution?: boolean;\n\n  /**\n   * Scaling ratio for repulsion. Default: 100.\n   */\n  scalingRatio?: number;\n\n  /**\n   * Speed of the slowdown. Default: 1.\n   */\n  slowDown?: number;\n\n  /**\n   * Whether to use the strong gravity mode. Default: false.\n   */\n  strongGravityMode?: boolean;\n\n  /**\n   * Number of iterations to perform. Default: 50.\n   */\n  iterations?: number;\n}\n\nexport function forceAtlas2({\n  graph,\n  drags,\n  iterations,\n  ...rest\n}: ForceAtlas2LayoutInputs) {\n  // Note: We need to assign a random position to each node\n  // in order for the force atlas to work.\n  // Reference: https://graphology.github.io/standard-library/layout-forceatlas2.html#pre-requisites\n  random.assign(graph);\n\n  const layout = forceAtlas2Layout(graph, {\n    iterations,\n    settings: rest\n  });\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      // If we dragged, we need to use that position\n      return (drags?.[id]?.position as any) || layout?.[id];\n    }\n  };\n}\n","import {\n  forceCollide,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  forceX,\n  forceY\n} from 'd3-force-3d';\nimport { hierarchy, treemap } from 'd3-hierarchy';\n\nimport type { ClusterGroup } from '../utils/cluster';\n\n/**\n * Used for calculating clusterings of nodes.\n *\n * Modified version of: https://github.com/john-guerra/forceInABox\n *\n * Changes:\n *  - Improved d3 import for tree shaking\n *  - Fixed node lookup for edges using array\n *  - Updated d3-force to use d3-force-3d\n *  - Removed template logic\n */\nexport function forceInABox() {\n  // d3 style\n  const constant = (_: any) => () => _;\n  const index = (d: any) => d.index;\n\n  // Default values\n  let id = index;\n  let nodes = [];\n  let links = []; // needed for the force version\n  let clusters: Map<string, ClusterGroup>;\n  let tree;\n  let size = [100, 100];\n  let forceNodeSize = constant(1); // The expected node size used for computing the cluster node\n  let forceCharge = constant(-1);\n  let forceLinkDistance = constant(100);\n  let forceLinkStrength = constant(0.1);\n  const foci = {};\n  let linkStrengthIntraCluster = 0.1;\n  let linkStrengthInterCluster = 0.001;\n  let templateNodes = [];\n  let offset = [0, 0];\n  let templateForce;\n  let groupBy = d => d.cluster;\n  let template = 'treemap';\n  let enableGrouping = true;\n  let strength = 0.1;\n\n  function force(alpha) {\n    if (!enableGrouping) {\n      return force;\n    }\n\n    if (template === 'force') {\n      // Do the tick of the template force and get the new focis\n      templateForce.tick();\n      getFocisFromTemplate();\n    }\n\n    for (let i = 0, n = nodes.length, node, k = alpha * strength; i < n; ++i) {\n      node = nodes[i];\n      node.vx += (foci[groupBy(node)].x - node.x) * k;\n      node.vy += (foci[groupBy(node)].y - node.y) * k;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) {\n      return;\n    }\n\n    if (template === 'treemap') {\n      initializeWithTreemap();\n    } else {\n      initializeWithForce();\n    }\n  }\n\n  force.initialize = function (_) {\n    nodes = _;\n    initialize();\n  };\n\n  function getLinkKey(l) {\n    const sourceID = groupBy(l.source),\n      targetID = groupBy(l.target);\n\n    return sourceID <= targetID\n      ? sourceID + '~' + targetID\n      : targetID + '~' + sourceID;\n  }\n\n  function computeClustersNodeCounts(nodes) {\n    let clustersCounts = new Map(),\n      tmpCount: any = {};\n\n    nodes.forEach(function (d) {\n      if (!clustersCounts.has(groupBy(d))) {\n        clustersCounts.set(groupBy(d), { count: 0, sumforceNodeSize: 0 });\n      }\n    });\n\n    nodes.forEach(function (d) {\n      tmpCount = clustersCounts.get(groupBy(d));\n      tmpCount.count = tmpCount.count + 1;\n      tmpCount.sumforceNodeSize =\n        tmpCount.sumforceNodeSize +\n        // @ts-ignore\n        Math.PI * (forceNodeSize(d) * forceNodeSize(d)) * 1.3;\n      clustersCounts.set(groupBy(d), tmpCount);\n    });\n\n    return clustersCounts;\n  }\n\n  //Returns\n  function computeClustersLinkCounts(links) {\n    const dClusterLinks = new Map(),\n      clusterLinks = [];\n\n    links.forEach(function (l) {\n      let key = getLinkKey(l),\n        count;\n      if (dClusterLinks.has(key)) {\n        count = dClusterLinks.get(key);\n      } else {\n        count = 0;\n      }\n      count += 1;\n      dClusterLinks.set(key, count);\n    });\n\n    dClusterLinks.forEach(function (value, key) {\n      let source, target;\n      source = key.split('~')[0];\n      target = key.split('~')[1];\n      if (source !== undefined && target !== undefined) {\n        clusterLinks.push({\n          source: source,\n          target: target,\n          count: value\n        });\n      }\n    });\n\n    return clusterLinks;\n  }\n\n  //Returns the metagraph of the clusters\n  function getGroupsGraph() {\n    const gnodes = [];\n    const glinks = [];\n    const dNodes = new Map();\n    let c;\n    let i;\n    let cc;\n    let clustersCounts;\n    let clustersLinks;\n\n    clustersCounts = computeClustersNodeCounts(nodes);\n    clustersLinks = computeClustersLinkCounts(links);\n\n    for (c of clustersCounts.keys()) {\n      cc = clustersCounts.get(c);\n      gnodes.push({\n        id: c,\n        size: cc.count,\n        r: Math.sqrt(cc.sumforceNodeSize / Math.PI)\n      }); // Uses approx meta-node size\n      dNodes.set(c, i);\n    }\n\n    clustersLinks.forEach(function (l) {\n      const source = dNodes.get(l.source),\n        target = dNodes.get(l.target);\n      if (source !== undefined && target !== undefined) {\n        glinks.push({\n          source: source,\n          target: target,\n          count: l.count\n        });\n      }\n    });\n\n    return { nodes: gnodes, links: glinks };\n  }\n\n  function getGroupsTree() {\n    const children = [];\n    let c;\n    let cc;\n    let clustersCounts;\n\n    // @ts-ignore\n    clustersCounts = computeClustersNodeCounts(force.nodes());\n\n    for (c of clustersCounts.keys()) {\n      cc = clustersCounts.get(c);\n      children.push({ id: c, size: cc.count });\n    }\n    return { id: 'clustersTree', children: children };\n  }\n\n  function getFocisFromTemplate() {\n    //compute foci\n    // @ts-ignore\n    foci.none = { x: 0, y: 0 };\n    templateNodes.forEach(function (d) {\n      if (template === 'treemap') {\n        foci[d.data.id] = {\n          x: d.x0 + (d.x1 - d.x0) / 2 - offset[0],\n          y: d.y0 + (d.y1 - d.y0) / 2 - offset[1]\n        };\n      } else {\n        foci[d.id] = {\n          x: d.x - offset[0],\n          y: d.y - offset[1]\n        };\n      }\n    });\n    return foci;\n  }\n\n  function initializeWithTreemap() {\n    // @ts-ignore\n    const sim = treemap().size(force.size());\n\n    tree = hierarchy(getGroupsTree())\n      .sum((d: any) => d.radius)\n      .sort(function (a, b) {\n        return b.height - a.height || b.value - a.value;\n      });\n\n    templateNodes = sim(tree).leaves();\n    getFocisFromTemplate();\n  }\n\n  function checkLinksAsObjects() {\n    // Check if links come in the format of indexes instead of objects\n    let linkCount = 0;\n    if (nodes.length === 0) return;\n\n    links.forEach(function (link) {\n      let source, target;\n      if (!nodes) {\n        return;\n      }\n\n      source = link.source;\n      target = link.target;\n\n      if (typeof link.source !== 'object') {\n        source = nodes.find(n => n.id === link.source);\n      }\n\n      if (typeof link.target !== 'object') {\n        target = nodes.find(n => n.id === link.target);\n      }\n\n      if (source === undefined || target === undefined) {\n        throw Error(\n          'Error setting links, couldnt find nodes for a link (see it on the console)'\n        );\n      }\n      link.source = source;\n      link.target = target;\n      link.index = linkCount++;\n    });\n  }\n\n  function initializeWithForce() {\n    let net;\n\n    if (!nodes || !nodes.length) {\n      return;\n    }\n\n    checkLinksAsObjects();\n\n    net = getGroupsGraph();\n\n    // Use dragged clusters position if available\n    if (clusters.size > 0) {\n      net.nodes.forEach(n => {\n        // Set fixed X position for cluster\n        n.fx = clusters.get(n.id)?.position?.x;\n        // Set fixed Y position for cluster\n        n.fy = clusters.get(n.id)?.position?.y;\n      });\n    }\n\n    templateForce = forceSimulation(net.nodes)\n      .force('x', forceX(size[0] / 2).strength(0.1))\n      .force('y', forceY(size[1] / 2).strength(0.1))\n      .force('collide', forceCollide(d => d.r).iterations(4))\n      .force('charge', forceManyBody().strength(forceCharge))\n      .force(\n        'links',\n        forceLink(net.nodes.length ? net.links : [])\n          .distance(forceLinkDistance)\n          .strength(forceLinkStrength)\n      );\n\n    templateNodes = templateForce.nodes();\n\n    getFocisFromTemplate();\n  }\n\n  force.template = function (x) {\n    if (!arguments.length) {\n      return template;\n    }\n\n    template = x;\n    initialize();\n    return force;\n  };\n\n  force.groupBy = function (x) {\n    if (!arguments.length) {\n      return groupBy;\n    }\n\n    if (typeof x === 'string') {\n      groupBy = function (d) {\n        return d[x];\n      };\n\n      return force;\n    }\n\n    groupBy = x;\n\n    return force;\n  };\n\n  force.enableGrouping = function (x) {\n    if (!arguments.length) {\n      return enableGrouping;\n    }\n\n    enableGrouping = x;\n\n    return force;\n  };\n\n  force.strength = function (x) {\n    if (!arguments.length) {\n      return strength;\n    }\n\n    strength = x;\n\n    return force as any;\n  };\n\n  force.getLinkStrength = function (e) {\n    if (enableGrouping) {\n      if (groupBy(e.source) === groupBy(e.target)) {\n        if (typeof linkStrengthIntraCluster === 'function') {\n          // @ts-ignore\n          return linkStrengthIntraCluster(e);\n        } else {\n          return linkStrengthIntraCluster;\n        }\n      } else {\n        if (typeof linkStrengthInterCluster === 'function') {\n          // @ts-ignore\n          return linkStrengthInterCluster(e);\n        } else {\n          return linkStrengthInterCluster;\n        }\n      }\n    } else {\n      // Not grouping return the intracluster\n      if (typeof linkStrengthIntraCluster === 'function') {\n        // @ts-ignore\n        return linkStrengthIntraCluster(e);\n      } else {\n        return linkStrengthIntraCluster;\n      }\n    }\n  };\n\n  force.id = function (_) {\n    return arguments.length ? ((id = _), force) : id;\n  };\n\n  force.size = function (_) {\n    return arguments.length ? ((size = _), force) : size;\n  };\n\n  force.linkStrengthInterCluster = function (_) {\n    return arguments.length\n      ? ((linkStrengthInterCluster = _), force)\n      : linkStrengthInterCluster;\n  };\n\n  force.linkStrengthIntraCluster = function (_) {\n    return arguments.length\n      ? ((linkStrengthIntraCluster = _), force)\n      : linkStrengthIntraCluster;\n  };\n\n  force.nodes = function (_) {\n    return arguments.length ? ((nodes = _), force) : nodes;\n  };\n\n  force.links = function (_) {\n    if (!arguments.length) {\n      return links;\n    }\n\n    if (_ === null) {\n      links = [];\n    } else {\n      links = _;\n    }\n\n    initialize();\n\n    return force;\n  };\n\n  force.template = function (x) {\n    if (!arguments.length) {\n      return template;\n    }\n\n    template = x;\n    initialize();\n    return force;\n  };\n\n  force.forceNodeSize = function (_) {\n    return arguments.length\n      ? ((forceNodeSize = typeof _ === 'function' ? _ : constant(+_)),\n        initialize(),\n        force)\n      : forceNodeSize;\n  };\n\n  // Legacy support\n  force.nodeSize = force.forceNodeSize;\n\n  force.forceCharge = function (_) {\n    return arguments.length\n      ? ((forceCharge = typeof _ === 'function' ? _ : constant(+_)),\n        initialize(),\n        force)\n      : forceCharge;\n  };\n\n  force.forceLinkDistance = function (_) {\n    return arguments.length\n      ? ((forceLinkDistance = typeof _ === 'function' ? _ : constant(+_)),\n        initialize(),\n        force)\n      : forceLinkDistance;\n  };\n\n  force.forceLinkStrength = function (_) {\n    return arguments.length\n      ? ((forceLinkStrength = typeof _ === 'function' ? _ : constant(+_)),\n        initialize(),\n        force)\n      : forceLinkStrength;\n  };\n\n  force.offset = function (_) {\n    return arguments.length\n      ? ((offset = typeof _ === 'function' ? _ : constant(+_)), force)\n      : offset;\n  };\n\n  force.getFocis = getFocisFromTemplate;\n\n  // Define the clusters to reuse positions from\n  force.setClusters = function (value: any) {\n    clusters = value;\n\n    return force;\n  };\n\n  return force;\n}\n","import { forceRadial as d3ForceRadial } from 'd3-force-3d';\n\nimport type { InternalGraphEdge, InternalGraphNode } from '../types';\nimport { getNodeDepth } from './depthUtils';\n\nconst RADIALS: DagMode[] = ['radialin', 'radialout'];\n\nexport type DagMode =\n  | 'lr'\n  | 'rl'\n  | 'td'\n  | 'but'\n  | 'zout'\n  | 'zin'\n  | 'radialin'\n  | 'radialout';\n\nexport interface ForceRadialInputs {\n  nodes: InternalGraphNode[];\n  edges: InternalGraphEdge[];\n  mode: DagMode;\n  nodeLevelRatio: number;\n}\n\n/**\n * Radial graph layout using D3 Force 3d.\n * Inspired by: https://github.com/vasturiano/three-forcegraph/blob/master/src/forcegraph-kapsule.js#L970-L1018\n */\nexport function forceRadial({\n  nodes,\n  edges,\n  mode = 'lr',\n  nodeLevelRatio = 2\n}: ForceRadialInputs) {\n  const { depths, maxDepth, invalid } = getNodeDepth(nodes, edges);\n\n  if (invalid) {\n    return null;\n  }\n\n  const modeDistance = RADIALS.includes(mode) ? 1 : 5;\n  const dagLevelDistance =\n    (nodes.length / maxDepth) * nodeLevelRatio * modeDistance;\n\n  if (mode) {\n    const getFFn =\n      (fix: boolean, invert: boolean) => (node: InternalGraphNode) =>\n        !fix\n          ? undefined\n          : (depths[node.id].depth - maxDepth / 2) *\n            dagLevelDistance *\n            (invert ? -1 : 1);\n\n    const fxFn = getFFn(['lr', 'rl'].includes(mode), mode === 'rl');\n    const fyFn = getFFn(['td', 'bu'].includes(mode), mode === 'td');\n    const fzFn = getFFn(['zin', 'zout'].includes(mode), mode === 'zout');\n\n    nodes.forEach(node => {\n      node.fx = fxFn(node);\n      node.fy = fyFn(node);\n      node.fz = fzFn(node);\n    });\n  }\n\n  return RADIALS.includes(mode)\n    ? d3ForceRadial(node => {\n        const nodeDepth = depths[node.id];\n        const depth =\n          mode === 'radialin' ? maxDepth - nodeDepth.depth : nodeDepth.depth;\n        return depth * dagLevelDistance;\n      }).strength(1)\n    : null;\n}\n","import {\n  forceCenter as d3ForceCenter,\n  forceCollide,\n  forceLink as d3ForceLink,\n  forceManyBody as d3ForceManyBody,\n  forceSimulation as d3ForceSimulation,\n  forceX as d3ForceX,\n  forceY as d3ForceY,\n  forceZ as d3ForceZ\n} from 'd3-force-3d';\n\nimport type { ClusterGroup } from '../utils/cluster';\nimport { forceInABox } from './forceInABox';\nimport type { DagMode } from './forceUtils';\nimport { forceRadial } from './forceUtils';\nimport type { FORCE_LAYOUTS } from './layoutProvider';\nimport { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\n\nexport interface ForceDirectedLayoutInputs extends LayoutFactoryProps {\n  /**\n   * Center inertia for the layout. Default: 1.\n   */\n  centerInertia?: number;\n\n  /**\n   * Number of dimensions for the layout. 2d or 3d.\n   */\n  dimensions?: number;\n\n  /**\n   * Mode for the dag layout. Only applicable for dag layouts.\n   */\n  mode?: DagMode;\n\n  /**\n   * Distance between links.\n   */\n  linkDistance?: number;\n\n  /**\n   * Strength of the node repulsion.\n   */\n  nodeStrength?: number;\n\n  /**\n   * Strength of the cluster repulsion.\n   */\n  clusterStrength?: number;\n\n  /**\n   * The clusters dragged position to reuse for the layout.\n   */\n  clusters: Map<string, ClusterGroup>;\n\n  /**\n   * The type of clustering.\n   */\n  clusterType?: 'force' | 'treemap';\n\n  /**\n   * Ratio of the distance between nodes on the same level.\n   */\n  nodeLevelRatio?: number;\n\n  /**\n   * LinkStrength between nodes of different clusters\n   */\n  linkStrengthInterCluster?: number | ((d: any) => number);\n\n  /**\n   * LinkStrength between nodes of the same cluster\n   */\n  linkStrengthIntraCluster?: number | ((d: any) => number);\n\n  /**\n   * Charge between the meta-nodes (Force template only)\n   */\n  forceLinkDistance?: number;\n\n  /**\n   * Used to compute the template force nodes size (Force template only)\n   */\n  forceLinkStrength?: number;\n\n  /**\n   * Used to compute the template force nodes size (Force template only)\n   */\n  forceCharge?: number;\n\n  /**\n   * Used to determine the simulation forceX and forceY values\n   */\n  forceLayout: (typeof FORCE_LAYOUTS)[number];\n}\n\nexport function forceDirected({\n  graph,\n  nodeLevelRatio = 2,\n  mode = null,\n  dimensions = 2,\n  nodeStrength = -250,\n  linkDistance = 100,\n  clusterStrength = 0.5,\n  linkStrengthInterCluster = 0.01,\n  linkStrengthIntraCluster = 0.5,\n  forceLinkDistance = 100,\n  forceLinkStrength = 0.1,\n  clusterType = 'force',\n  forceCharge = -700,\n  getNodePosition,\n  drags,\n  clusters,\n  clusterAttribute,\n  forceLayout\n}: ForceDirectedLayoutInputs): LayoutStrategy {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  // Dynamically adjust node strength based on the number of edges\n  const is2d = dimensions === 2;\n  const nodeStrengthAdjustment =\n    is2d && edges.length > 25 ? nodeStrength * 2 : nodeStrength;\n\n  let forceX;\n  let forceY;\n  if (forceLayout === 'forceDirected2d') {\n    forceX = d3ForceX();\n    forceY = d3ForceY();\n  } else {\n    forceX = d3ForceX(600).strength(0.05);\n    forceY = d3ForceY(600).strength(0.05);\n  }\n\n  // Create the simulation\n  const sim = d3ForceSimulation()\n    .force('center', d3ForceCenter(0, 0))\n    .force('link', d3ForceLink())\n    .force('charge', d3ForceManyBody().strength(nodeStrengthAdjustment))\n    .force('x', forceX)\n    .force('y', forceY)\n    .force('z', d3ForceZ())\n    // Handles nodes not overlapping each other ( most relevant in clustering )\n    .force(\n      'collide',\n      forceCollide(d => d.radius + 10)\n    )\n    .force(\n      'dagRadial',\n      forceRadial({\n        nodes,\n        edges,\n        mode,\n        nodeLevelRatio\n      })\n    )\n    .stop();\n\n  let groupingForce;\n  if (clusterAttribute) {\n    // Dynamically adjust cluster force charge based on the number of nodes\n    let forceChargeAdjustment = forceCharge;\n    if (nodes?.length) {\n      const adjustmentFactor = Math.ceil(nodes.length / 200);\n      forceChargeAdjustment = forceCharge * adjustmentFactor;\n    }\n\n    groupingForce = forceInABox()\n      // The clusters dragged position to reuse for the layout\n      .setClusters(clusters)\n      // Strength to foci\n      .strength(clusterStrength)\n      // Either treemap or force\n      .template(clusterType)\n      // Node attribute to group\n      .groupBy(d => d.data[clusterAttribute])\n      // The graph links. Must be called after setting the grouping attribute\n      .links(edges)\n      // Size of the chart\n      .size([100, 100])\n      // linkStrength between nodes of different clusters\n      .linkStrengthInterCluster(linkStrengthInterCluster)\n      // linkStrength between nodes of the same cluster\n      .linkStrengthIntraCluster(linkStrengthIntraCluster)\n      // linkDistance between meta-nodes on the template (Force template only)\n      .forceLinkDistance(forceLinkDistance)\n      // linkStrength between meta-nodes of the template (Force template only)\n      .forceLinkStrength(forceLinkStrength)\n      // Charge between the meta-nodes (Force template only)\n      .forceCharge(forceChargeAdjustment)\n      // Used to compute the template force nodes size (Force template only)\n      .forceNodeSize(d => d.radius);\n  }\n\n  // Initialize the simulation\n  let layout = sim.numDimensions(dimensions).nodes(nodes);\n\n  if (groupingForce) {\n    layout = layout.force('group', groupingForce);\n  }\n\n  // Run the force on the links\n  if (linkDistance) {\n    let linkForce = layout.force('link');\n    if (linkForce) {\n      linkForce\n        .id(d => d.id)\n        .links(edges)\n        // When no mode passed, its a tree layout\n        // so let's use a larger distance\n        .distance(linkDistance);\n\n      if (groupingForce) {\n        linkForce = linkForce.strength(groupingForce?.getLinkStrength ?? 0.1);\n      }\n    }\n  }\n\n  const nodeMap = new Map(nodes.map(n => [n.id, n]));\n\n  return {\n    step() {\n      // Run the simulation til we get a stable result\n      while (sim.alpha() > 0.01) {\n        sim.tick();\n      }\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) {\n          return pos;\n        }\n      }\n\n      if (drags?.[id]?.position) {\n        // If we dragged, we need to use that position\n        return drags?.[id]?.position as any;\n      }\n\n      return nodeMap.get(id);\n    }\n  };\n}\n","import { hierarchy, stratify, tree } from 'd3-hierarchy';\n\nimport type { InternalGraphNode } from '../types';\nimport type { DepthNode } from './depthUtils';\nimport { getNodeDepth } from './depthUtils';\nimport { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\n\nexport interface HierarchicalLayoutInputs extends LayoutFactoryProps {\n  /**\n   * Direction of the layout. Default 'td'.\n   */\n  mode?: 'td' | 'lr';\n  /**\n   * Factor of distance between nodes. Default 1.\n   */\n  nodeSeparation?: number;\n  /**\n   * Size of each node. Default [50,50]\n   */\n  nodeSize?: [number, number];\n}\n\nconst DIRECTION_MAP = {\n  td: {\n    x: 'x',\n    y: 'y',\n    factor: -1\n  },\n  lr: {\n    x: 'y',\n    y: 'x',\n    factor: 1\n  }\n};\n\nexport function hierarchical({\n  graph,\n  drags,\n  mode = 'td',\n  nodeSeparation = 2,\n  nodeSize = [60, 60],\n  getNodePosition\n}: HierarchicalLayoutInputs): LayoutStrategy {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  // find root node by finding the nodes which have no incoming edges\n  const parentNodes = nodes.filter(n => !edges.find(e => e.target === n.id));\n  console.log('parentNodes', parentNodes);\n\n  // if more than 1 root node, then we have multiple trees\n  // insert a fake root node to connect all root nodes\n  if (parentNodes.length > 1) {\n    const fakeRootNode: InternalGraphNode = {\n      id: 'fakeRoot',\n      label: '',\n      fill: '#fff',\n      activeFill: '#fff',\n      icon: '',\n      data: {\n        id: 'fakeRoot',\n        loaded: true,\n        extra: {\n          id: 'fakeRoot',\n          properties: {},\n          labels: []\n        },\n        className: '',\n        style: {\n          label: ''\n        }\n      },\n      position: {\n        id: '',\n        data: {},\n        links: [],\n        index: 0,\n        x: 0,\n        y: 0,\n        z: 0,\n        vx: 0,\n        vy: 0\n      }\n    };\n\n    // add fake root node to nodes\n    nodes.push(fakeRootNode);\n\n    // add edges from fake root to root nodes\n    parentNodes.forEach(n => {\n      edges.push({\n        id: `fakeRoot-${n.id}`,\n        source: 'fakeRoot',\n        target: n.id,\n        label: '',\n        backgroundColor: '#fff'\n      });\n    });\n  }\n\n  const { depths } = getNodeDepth(nodes, edges);\n  const rootNodes = Object.keys(depths).map(d => depths[d]);\n\n  const root = stratify<DepthNode>()\n    .id(d => d.data.id)\n    .parentId(d => d.ins?.[0]?.data?.id)(rootNodes);\n\n  const treeRoot = tree()\n    .separation(() => nodeSeparation)\n    .nodeSize(nodeSize)(hierarchy(root));\n\n  const treeNodes = treeRoot.descendants();\n  const path = DIRECTION_MAP[mode];\n\n  const mappedNodes = new Map<string, InternalGraphNode>(\n    nodes.map(n => {\n      const { x, y } = treeNodes.find((t: any) => t.data.id === n.id);\n      return [\n        n.id,\n        {\n          ...n,\n          [path.x]: x * path.factor,\n          [path.y]: y * path.factor,\n          z: 0\n        }\n      ];\n    })\n  );\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) {\n          return pos;\n        }\n      }\n\n      if (drags?.[id]?.position) {\n        // If we dragged, we need to use that position\n        return drags?.[id]?.position as any;\n      }\n\n      return mappedNodes.get(id);\n    }\n  };\n}\n","import type { ConcentricLayoutInputs } from 'layout/concentric2d';\nimport { Vector3 } from 'three';\n\nimport { buildNodeEdges } from './layoutUtils';\n\n/**\n * Generates a point on a Fibonacci sphere.\n * @param i\n * @param n\n * @param r\n */\nfunction fibonacciSpherePoint(i: number, n: number, r: number) {\n  const phi = Math.acos(1 - (2 * (i + 0.5)) / n);\n  const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);\n  const x = r * Math.sin(phi) * Math.cos(theta);\n  const y = r * Math.sin(phi) * Math.sin(theta);\n  const z = r * Math.cos(phi);\n\n  return new Vector3(x, y, z);\n}\n\n/**\n * Concentric layout algorithm for 3D graphs.\n * @param graph\n * @param radius\n * @param drags\n * @param getNodePosition\n * @param concentricSpacing\n */\nexport function concentric3d({\n  graph,\n  radius = 40,\n  drags,\n  getNodePosition,\n  concentricSpacing = 100\n}: ConcentricLayoutInputs) {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  const layout: Record<string, { x: number; y: number; z: number }> = {};\n\n  const getNodesInLevel = (level: number) => {\n    const circumference = 2 * Math.PI * (radius + level * concentricSpacing);\n    const minNodeSpacing = 40;\n    return Math.floor(circumference / minNodeSpacing);\n  };\n\n  const fixedLevelMap = new Map<number, string[]>();\n  const dynamicNodes: { id: string; metric: number }[] = [];\n\n  // Split nodes: fixed-level and dynamic\n  for (const node of nodes) {\n    const data = graph.getNodeAttribute(node.id, 'data');\n    const level = data?.level;\n\n    if (typeof level === 'number' && level >= 0) {\n      if (!fixedLevelMap.has(level)) {\n        fixedLevelMap.set(level, []);\n      }\n      fixedLevelMap.get(level)!.push(node.id);\n    } else {\n      dynamicNodes.push({ id: node.id, metric: graph.degree(node.id) });\n    }\n  }\n\n  // Sort dynamic nodes by degree\n  dynamicNodes.sort((a, b) => b.metric - a.metric);\n\n  // Fill layout for fixed-level nodes (3D spherical placement)\n  for (const [level, nodeIds] of fixedLevelMap.entries()) {\n    const count = nodeIds.length;\n    const r = radius + level * concentricSpacing;\n\n    for (const [i, id] of nodeIds.entries()) {\n      const pos = fibonacciSpherePoint(i, count, r);\n      layout[id] = { x: pos.x, y: pos.y, z: pos.z };\n    }\n  }\n\n  // Determine which levels are partially used and which are available\n  const occupiedLevels = new Set(fixedLevelMap.keys());\n  let dynamicLevel = 0;\n\n  let i = 0;\n  while (i < dynamicNodes.length) {\n    // Skip occupied levels\n    while (occupiedLevels.has(dynamicLevel)) {\n      dynamicLevel++;\n    }\n\n    const nodesInLevel = getNodesInLevel(dynamicLevel);\n    const r = radius + dynamicLevel * concentricSpacing;\n\n    for (let j = 0; j < nodesInLevel && i < dynamicNodes.length; j++) {\n      const pos = fibonacciSpherePoint(j, nodesInLevel, r);\n      layout[dynamicNodes[i].id] = { x: pos.x, y: pos.y, z: pos.z };\n      i++;\n    }\n\n    dynamicLevel++;\n  }\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) {\n          return pos;\n        }\n      }\n\n      if (drags?.[id]?.position) {\n        return drags[id].position as any;\n      }\n\n      return layout[id];\n    }\n  };\n}\n","import noverlapLayout from 'graphology-layout-noverlap';\n\nimport { buildNodeEdges } from './layoutUtils';\nimport type { LayoutFactoryProps } from './types';\n\nexport interface NoOverlapLayoutInputs extends LayoutFactoryProps {\n  /**\n   * Grid size. Default 20.\n   */\n  gridSize?: number;\n\n  /**\n   * Ratio of the layout. Default 10.\n   */\n  ratio?: number;\n\n  /**\n   * Maximum number of iterations. Default 50.\n   */\n  maxIterations?: number;\n\n  /**\n   * Margin between nodes. Default 10.\n   */\n  margin?: number;\n}\n\nexport function nooverlap({\n  graph,\n  margin,\n  drags,\n  getNodePosition,\n  ratio,\n  gridSize,\n  maxIterations\n}: NoOverlapLayoutInputs) {\n  const { nodes, edges } = buildNodeEdges(graph);\n\n  const layout = noverlapLayout(graph, {\n    maxIterations,\n    inputReducer: (_key, attr) => ({\n      ...attr,\n      // Have to specify defaults for the engine\n      x: attr.x || 0,\n      y: attr.y || 0\n    }),\n    settings: {\n      ratio,\n      margin,\n      gridSize\n    }\n  });\n\n  return {\n    step() {\n      return true;\n    },\n    getNodePosition(id: string) {\n      if (getNodePosition) {\n        const pos = getNodePosition(id, { graph, drags, nodes, edges });\n        if (pos) {\n          return pos;\n        }\n      }\n\n      if (drags?.[id]?.position) {\n        // If we dragged, we need to use that position\n        return drags?.[id]?.position as any;\n      }\n\n      return layout?.[id];\n    }\n  };\n}\n","import { concentric2d } from 'layout/concentric2d';\nimport { concentric3d } from 'layout/concentric3d';\n\nimport type { CircularLayoutInputs } from './circular2d';\nimport { circular2d } from './circular2d';\nimport type { ConcentricLayoutInputs } from './concentric2d';\nimport { custom } from './custom';\nimport type { ForceAtlas2LayoutInputs } from './forceatlas2';\nimport { forceAtlas2 } from './forceatlas2';\nimport type { ForceDirectedLayoutInputs } from './forceDirected';\nimport { forceDirected } from './forceDirected';\nimport type { HierarchicalLayoutInputs } from './hierarchical';\nimport { hierarchical } from './hierarchical';\nimport type { NoOverlapLayoutInputs } from './nooverlap';\nimport { nooverlap } from './nooverlap';\nimport type { LayoutFactoryProps, LayoutStrategy } from './types';\n\nexport type LayoutOverrides = Partial<\n  | Omit<ForceDirectedLayoutInputs, 'dimensions' | 'mode'>\n  | CircularLayoutInputs\n  | ConcentricLayoutInputs\n  | HierarchicalLayoutInputs\n>;\n\nexport const FORCE_LAYOUTS = [\n  'forceDirected2d',\n  'treeTd2d',\n  'treeLr2d',\n  'radialOut2d',\n  'treeTd3d',\n  'treeLr3d',\n  'radialOut3d',\n  'forceDirected3d'\n];\n\nexport function layoutProvider({\n  type,\n  ...rest\n}: LayoutFactoryProps | LayoutOverrides): LayoutStrategy {\n  if (FORCE_LAYOUTS.includes(type)) {\n    const { nodeStrength, linkDistance, nodeLevelRatio } =\n      rest as ForceDirectedLayoutInputs;\n\n    if (type === 'forceDirected2d') {\n      return forceDirected({\n        ...rest,\n        dimensions: 2,\n        nodeLevelRatio: nodeLevelRatio || 2,\n        nodeStrength: nodeStrength || -250,\n        linkDistance,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'treeTd2d') {\n      return forceDirected({\n        ...rest,\n        mode: 'td',\n        dimensions: 2,\n        nodeLevelRatio: nodeLevelRatio || 5,\n        nodeStrength: nodeStrength || -250,\n        linkDistance: linkDistance || 50,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'treeLr2d') {\n      return forceDirected({\n        ...rest,\n        mode: 'lr',\n        dimensions: 2,\n        nodeLevelRatio: nodeLevelRatio || 5,\n        nodeStrength: nodeStrength || -250,\n        linkDistance: linkDistance || 50,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'radialOut2d') {\n      return forceDirected({\n        ...rest,\n        mode: 'radialout',\n        dimensions: 2,\n        nodeLevelRatio: nodeLevelRatio || 5,\n        nodeStrength: nodeStrength || -500,\n        linkDistance: linkDistance || 100,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'treeTd3d') {\n      return forceDirected({\n        ...rest,\n        mode: 'td',\n        dimensions: 3,\n        nodeLevelRatio: nodeLevelRatio || 2,\n        nodeStrength: nodeStrength || -500,\n        linkDistance: linkDistance || 50\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'treeLr3d') {\n      return forceDirected({\n        ...rest,\n        mode: 'lr',\n        dimensions: 3,\n        nodeLevelRatio: nodeLevelRatio || 2,\n        nodeStrength: nodeStrength || -500,\n        linkDistance: linkDistance || 50,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'radialOut3d') {\n      return forceDirected({\n        ...rest,\n        mode: 'radialout',\n        dimensions: 3,\n        nodeLevelRatio: nodeLevelRatio || 2,\n        nodeStrength: nodeStrength || -500,\n        linkDistance: linkDistance || 100,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    } else if (type === 'forceDirected3d') {\n      return forceDirected({\n        ...rest,\n        dimensions: 3,\n        nodeLevelRatio: nodeLevelRatio || 2,\n        nodeStrength: nodeStrength || -250,\n        linkDistance,\n        forceLayout: type\n      } as ForceDirectedLayoutInputs);\n    }\n  } else if (type === 'circular2d') {\n    const { radius } = rest as CircularLayoutInputs;\n    return circular2d({\n      ...rest,\n      radius: radius || 300\n    } as CircularLayoutInputs);\n  } else if (type === 'concentric2d') {\n    return concentric2d(rest as ConcentricLayoutInputs);\n  } else if (type === 'concentric3d') {\n    return concentric3d(rest as ConcentricLayoutInputs);\n  } else if (type === 'hierarchicalTd') {\n    return hierarchical({ ...rest, mode: 'td' } as HierarchicalLayoutInputs);\n  } else if (type === 'hierarchicalLr') {\n    return hierarchical({ ...rest, mode: 'lr' } as HierarchicalLayoutInputs);\n  } else if (type === 'nooverlap') {\n    const { graph, maxIterations, ratio, margin, gridSize, ...settings } =\n      rest as NoOverlapLayoutInputs;\n\n    return nooverlap({\n      type: 'nooverlap',\n      graph,\n      margin: margin || 10,\n      maxIterations: maxIterations || 50,\n      ratio: ratio || 10,\n      gridSize: gridSize || 20,\n      ...settings\n    });\n  } else if (type === 'forceatlas2') {\n    const { graph, iterations, gravity, scalingRatio, ...settings } =\n      rest as ForceAtlas2LayoutInputs;\n\n    return forceAtlas2({\n      type: 'forceatlas2',\n      graph,\n      ...settings,\n      scalingRatio: scalingRatio || 100,\n      gravity: gravity || 10,\n      iterations: iterations || 50\n    });\n  } else if (type === 'custom') {\n    return custom({\n      type: 'custom',\n      ...rest\n    } as LayoutFactoryProps);\n  }\n\n  throw new Error(`Layout ${type} not found.`);\n}\n","import type { GraphEdge, GraphNode } from '../types';\nimport { getNodeDepth } from './depthUtils';\nimport type { LayoutTypes } from './types';\n\n/**\n * Given a set of nodes and edges, determine the type of layout that\n * is most ideal. This is very beta.\n */\nexport function recommendLayout(\n  nodes: GraphNode[],\n  edges: GraphEdge[]\n): LayoutTypes {\n  const { invalid } = getNodeDepth(nodes as any[], edges as any[]);\n  const nodeCount = nodes.length;\n\n  if (!invalid) {\n    // Large tree layouts\n    if (nodeCount > 100) {\n      return 'radialOut2d';\n    } else {\n      // Smaller tree layouts\n      return 'treeTd2d';\n    }\n  }\n\n  // Circular layouts\n  return 'forceDirected2d';\n}\n","import { useThree } from '@react-three/fiber';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport type { PerspectiveCamera } from 'three';\n\nimport { getVisibleEntities } from './collapse';\nimport type { LayoutOverrides, LayoutStrategy, LayoutTypes } from './layout';\nimport { layoutProvider } from './layout';\nimport { tick } from './layout/layoutUtils';\nimport type { SizingType } from './sizing';\nimport type { DragReferences } from './store';\nimport { useStore } from './store';\nimport type { GraphEdge, GraphNode, InternalGraphNode } from './types';\nimport { calculateClusters } from './utils/cluster';\nimport { buildGraph, transformGraph } from './utils/graph';\nimport type { LabelVisibilityType } from './utils/visibility';\nimport { calcLabelVisibility } from './utils/visibility';\n\nexport interface GraphInputs {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n  collapsedNodeIds?: string[];\n  layoutType?: LayoutTypes;\n  sizingType?: SizingType;\n  labelType?: LabelVisibilityType;\n  sizingAttribute?: string;\n  selections?: string[];\n  actives?: string[];\n  clusterAttribute?: string;\n  defaultNodeSize?: number;\n  minNodeSize?: number;\n  maxNodeSize?: number;\n  constrainDragging?: boolean;\n  layoutOverrides?: LayoutOverrides;\n}\n\nexport const useGraph = ({\n  layoutType,\n  sizingType,\n  labelType,\n  sizingAttribute,\n  clusterAttribute,\n  selections,\n  nodes,\n  edges,\n  actives,\n  collapsedNodeIds,\n  defaultNodeSize,\n  maxNodeSize,\n  minNodeSize,\n  layoutOverrides,\n  constrainDragging\n}: GraphInputs) => {\n  const graph = useStore(state => state.graph);\n  const clusters = useStore(state => state.clusters);\n  const storedNodes = useStore(state => state.nodes);\n  const setClusters = useStore(state => state.setClusters);\n  const stateCollapsedNodeIds = useStore(state => state.collapsedNodeIds);\n  const setEdges = useStore(state => state.setEdges);\n  const stateNodes = useStore(state => state.nodes);\n  const setNodes = useStore(state => state.setNodes);\n  const setSelections = useStore(state => state.setSelections);\n  const setActives = useStore(state => state.setActives);\n  const drags = useStore(state => state.drags);\n  const setDrags = useStore(state => state.setDrags);\n  const setCollapsedNodeIds = useStore(state => state.setCollapsedNodeIds);\n  const layoutMounted = useRef<boolean>(false);\n  const layout = useRef<LayoutStrategy | null>(null);\n  const camera = useThree(state => state.camera) as PerspectiveCamera;\n  const dragRef = useRef<DragReferences>(drags);\n  const clustersRef = useRef<any>([]);\n\n  // When a new node is added, remove the dragged position of the cluster nodes to put new node in the right place\n  useEffect(() => {\n    if (!clusterAttribute) {\n      return;\n    }\n\n    const existedNodesIds = storedNodes.map(n => n.id);\n    const newNode = nodes.find(n => !existedNodesIds.includes(n.id));\n    if (newNode) {\n      const clusterName = newNode.data[clusterAttribute];\n      const cluster = clusters.get(clusterName);\n      const drags = { ...dragRef.current };\n\n      cluster?.nodes?.forEach(node => (drags[node.id] = undefined));\n\n      dragRef.current = drags;\n      setDrags(drags);\n    }\n  }, [storedNodes, nodes, clusterAttribute, clusters, setDrags]);\n\n  // Calculate the visible entities\n  const { visibleEdges, visibleNodes } = useMemo(\n    () =>\n      getVisibleEntities({\n        collapsedIds: stateCollapsedNodeIds,\n        nodes,\n        edges\n      }),\n    [stateCollapsedNodeIds, nodes, edges]\n  );\n\n  // Store node positions inside drags state\n  const updateDrags = useCallback(\n    (nodes: InternalGraphNode[]) => {\n      const drags = { ...dragRef.current };\n      nodes.forEach(node => (drags[node.id] = node));\n      dragRef.current = drags;\n      setDrags(drags);\n    },\n    [setDrags]\n  );\n\n  const updateLayout = useCallback(\n    async (curLayout?: any) => {\n      // Cache the layout provider\n      layout.current =\n        curLayout ||\n        layoutProvider({\n          ...layoutOverrides,\n          type: layoutType,\n          graph,\n          drags: dragRef.current,\n          clusters: clustersRef?.current,\n          clusterAttribute\n        });\n\n      // Run the layout\n      await tick(layout.current);\n\n      // Transform the graph\n      const result = transformGraph({\n        graph,\n        layout: layout.current,\n        sizingType,\n        labelType,\n        sizingAttribute,\n        maxNodeSize,\n        minNodeSize,\n        defaultNodeSize,\n        clusterAttribute\n      });\n\n      // Calculate clusters\n      const newClusters = calculateClusters({\n        nodes: result.nodes,\n        clusterAttribute\n      });\n\n      // Do not decrease the cluster size is the number of nodes is the same\n      if (constrainDragging) {\n        newClusters.forEach(cluster => {\n          const prevCluster = clustersRef.current.get(cluster.label);\n          if (prevCluster?.nodes.length === cluster.nodes.length) {\n            cluster.position =\n              clustersRef.current?.get(cluster.label)?.position ??\n              cluster.position;\n          }\n        });\n      }\n\n      // Set our store outputs\n      setEdges(result.edges);\n      setNodes(result.nodes);\n      setClusters(newClusters);\n      if (clusterAttribute) {\n        // Set drag positions for nodes to prevent them from being moved by the layout update\n        updateDrags(result.nodes);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      layoutOverrides,\n      layoutType,\n      clusterAttribute,\n      sizingType,\n      labelType,\n      sizingAttribute,\n      maxNodeSize,\n      minNodeSize,\n      defaultNodeSize,\n      setEdges,\n      setNodes,\n      setClusters\n    ]\n  );\n\n  // Transient updates\n  useEffect(() => {\n    dragRef.current = drags;\n  }, [drags, clusterAttribute, updateLayout]);\n\n  // Transient cluster state\n  useEffect(() => {\n    clustersRef.current = clusters;\n  }, [clusters]);\n\n  useEffect(() => {\n    // When the camera position/zoom changes, update the label visibility\n    const nodes = stateNodes.map(node => ({\n      ...node,\n      labelVisible: calcLabelVisibility({\n        nodeCount: stateNodes?.length,\n        labelType,\n        camera,\n        nodePosition: node?.position\n      })('node', node?.size)\n    }));\n\n    // Determine if the label visibility has changed\n    const isVisibilityUpdated = nodes.some(\n      (node, i) => node.labelVisible !== stateNodes[i].labelVisible\n    );\n\n    // Update the nodes if the label visibility has changed\n    if (isVisibilityUpdated) {\n      setNodes(nodes);\n    }\n  }, [camera, camera.zoom, camera.position.z, setNodes, stateNodes, labelType]);\n\n  useEffect(() => {\n    // Let's set the store selections so its easier to access\n    if (layoutMounted.current) {\n      setSelections(selections);\n    }\n  }, [selections, setSelections]);\n\n  useEffect(() => {\n    // Let's set the store actives so its easier to access\n    if (layoutMounted.current) {\n      setActives(actives);\n    }\n  }, [actives, setActives]);\n\n  // Create the nggraph graph object\n  useEffect(() => {\n    async function update() {\n      layoutMounted.current = false;\n      buildGraph(graph, visibleNodes, visibleEdges);\n      await updateLayout();\n      // rqf to prevent race condition\n      requestAnimationFrame(() => (layoutMounted.current = true));\n    }\n\n    update();\n    // eslint-disable-next-line\n  }, [visibleNodes, visibleEdges]);\n\n  useEffect(() => {\n    // Let's set the store collapsedNodeIds so its easier to access\n    if (layoutMounted.current) {\n      setCollapsedNodeIds(collapsedNodeIds);\n    }\n  }, [collapsedNodeIds, setCollapsedNodeIds]);\n\n  // Update layout on type changes\n  useEffect(() => {\n    if (layoutMounted.current) {\n      // When a update is changed, discard all the previous drag positions\n      // NOTE: This sets the transient and the state\n      dragRef.current = {};\n      setDrags({});\n\n      // Recalculate the layout\n      updateLayout();\n    }\n  }, [layoutType, updateLayout, setDrags]);\n\n  // Update layout on size, label changes\n  useEffect(() => {\n    if (layoutMounted.current) {\n      updateLayout(layout.current);\n    }\n  }, [sizingType, sizingAttribute, labelType, updateLayout]);\n\n  return {\n    updateLayout\n  };\n};\n","import type Graph from 'graphology';\n\nimport type { InternalGraphEdge } from '../types';\nimport type { LabelVisibilityType } from './visibility';\n\n/**\n * Graphology-native approach using reduceEdges for optimal performance\n * @param graph Graphology graph instance\n * @returns Map with source-target pairs as keys and arrays of edges as values\n */\nexport const groupEdgesBySourceTarget = (\n  graph: Graph\n): Map<string, InternalGraphEdge[]> => {\n  // Use Graphology's native reduceEdges\n  return graph.reduceEdges(\n    (\n      edgeGroups: Map<string, InternalGraphEdge[]>,\n      edgeKey,\n      attributes,\n      source,\n      target\n    ) => {\n      const key = `${source}-${target}`;\n\n      // Construct complete InternalGraphEdge object\n      const edge: InternalGraphEdge = {\n        id: edgeKey,\n        source,\n        target,\n        ...attributes\n      };\n\n      const group = edgeGroups.get(key);\n      if (group) {\n        group.push(edge);\n      } else {\n        edgeGroups.set(key, [edge]);\n      }\n\n      return edgeGroups;\n    },\n    new Map<string, InternalGraphEdge[]>()\n  );\n};\n\n/**\n * Aggregates edges with the same source and target using Graphology's native functions\n * @param graph Graphology graph instance\n * @param labelType Label visibility type to determine if edge labels should be visible\n * @returns Array of aggregated edges\n */\nexport const aggregateEdges = (\n  graph: Graph,\n  labelType?: LabelVisibilityType\n): InternalGraphEdge[] => {\n  if (!graph || graph.size === 0) {\n    return [];\n  }\n\n  // Use Graphology's native reduceEdges to group and aggregate in one pass\n  const edgeGroups = groupEdgesBySourceTarget(graph);\n  const aggregatedEdges: InternalGraphEdge[] = [];\n  // Determine if edge labels should be visible based on labelType\n  const shouldShowEdgeLabels = labelType === 'all' || labelType === 'edges';\n\n  // Process groups efficiently\n  for (const [key, group] of edgeGroups) {\n    const [source, target] = key.split('-');\n    const firstEdge = group[0];\n\n    if (!source || !target || !firstEdge) {\n      continue;\n    }\n\n    // Calculate the aggregated edge size based on the number of edges\n    const baseSize = firstEdge.size || 1; // Default to 1 if no size is specified\n    const aggregatedSize = baseSize + group.length * baseSize * 0.5;\n\n    // Only show aggregation label when actually aggregating multiple edges\n    const aggregated = group.length > 1;\n    const label = aggregated ? `${group.length} edges` : firstEdge.label;\n\n    // Create an aggregated edge that represents the group\n    const aggregatedEdge: InternalGraphEdge = {\n      ...firstEdge,\n      source,\n      target,\n      label,\n      labelVisible: shouldShowEdgeLabels,\n      size: aggregatedSize,\n      // Store the original edges in the data property\n      data: {\n        ...(firstEdge.data || {}),\n        originalEdges: group,\n        count: group.length,\n        isAggregated: aggregated,\n        originalSize: baseSize\n      }\n    };\n\n    aggregatedEdges.push(aggregatedEdge);\n  }\n\n  return aggregatedEdges;\n};\n","import type { ThreeEvent } from '@react-three/fiber';\nimport { useThree } from '@react-three/fiber';\nimport type Graph from 'graphology';\nimport type { ReactNode } from 'react';\nimport React, {\n  forwardRef,\n  Fragment,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo\n} from 'react';\n\nimport type {\n  CenterNodesParams,\n  FitNodesParams\n} from './CameraControls/useCenterGraph';\nimport { useCenterGraph } from './CameraControls/useCenterGraph';\nimport type { LayoutOverrides, LayoutTypes } from './layout';\nimport type { SizingType } from './sizing';\nimport { useStore } from './store';\nimport { Node } from './symbols';\nimport type { ClusterEventArgs } from './symbols/Cluster';\nimport { Cluster } from './symbols/Cluster';\nimport type { EdgeInterpolation, EdgeLabelPosition } from './symbols/Edge';\nimport { Edge } from './symbols/Edge';\nimport { Edges } from './symbols/edges';\nimport type { EdgeArrowPosition } from './symbols/edges/Edge';\nimport type {\n  ClusterRenderer,\n  CollapseProps,\n  ContextMenuEvent,\n  GraphEdge,\n  GraphNode,\n  InternalGraphEdge,\n  InternalGraphNode,\n  NodeContextMenuProps,\n  NodeRenderer\n} from './types';\nimport { useGraph } from './useGraph';\nimport { aggregateEdges as aggregateEdgesUtil } from './utils/aggregateEdges';\nimport type { LabelVisibilityType } from './utils/visibility';\n\nexport interface GraphSceneProps {\n  /**\n   * Type of layout.\n   */\n  layoutType?: LayoutTypes;\n\n  /**\n   * List of ids that are selected.\n   */\n  selections?: string[];\n\n  /**\n   * List of ids that are active.\n   */\n  actives?: string[];\n\n  /**\n   * List of node ids that are collapsed.\n   */\n  collapsedNodeIds?: string[];\n\n  /**\n   * Animate or not the graph positions.\n   */\n  animated?: boolean;\n\n  /**\n   * Nodes to pass to the graph.\n   */\n  nodes: GraphNode[];\n\n  /**\n   * Edges to pass to the graph.\n   */\n  edges: GraphEdge[];\n\n  /**\n   * Context menu element.\n   */\n  contextMenu?: (event: ContextMenuEvent) => ReactNode;\n\n  /**\n   * Type of sizing for nodes.\n   */\n  sizingType?: SizingType;\n\n  /**\n   * Type of visibility for labels.\n   */\n  labelType?: LabelVisibilityType;\n\n  /**\n   * Place of visibility for edge labels.\n   */\n  edgeLabelPosition?: EdgeLabelPosition;\n\n  /**\n   * Placement of edge arrows.\n   */\n  edgeArrowPosition?: EdgeArrowPosition;\n\n  /**\n   * Shape of edge.\n   */\n  edgeInterpolation?: EdgeInterpolation;\n\n  /**\n   * Font of label, same as troika-three-text\n   * The URL of a custom font file to be used. Supported font formats are: * .ttf * .otf * .woff (.woff2 is not supported)\n   * Default: The Roboto font loaded from Google Fonts CDN\n   */\n  labelFontUrl?: string;\n\n  /**\n   * Attribute based sizing property.\n   */\n  sizingAttribute?: string;\n\n  /**\n   * The default size to size nodes to. Default is 7.\n   */\n  defaultNodeSize?: number;\n\n  /**\n   * When using sizing attributes, the min size a node can be.\n   */\n  minNodeSize?: number;\n\n  /**\n   * When using sizing attributes, the max size a node can be.\n   */\n  maxNodeSize?: number;\n\n  /**\n   * Attribute used for clustering.\n   */\n  clusterAttribute?: string;\n\n  /**\n   * Disable interactions or not.\n   */\n  disabled?: boolean;\n\n  /**\n   * Allow dragging of nodes.\n   */\n  draggable?: boolean;\n\n  /**\n   * Constrain dragging to the cluster bounds. Default is `false`.\n   */\n  constrainDragging?: boolean;\n\n  /**\n   * Render a custom node\n   */\n  renderNode?: NodeRenderer;\n\n  /**\n   * Render a custom cluster\n   */\n  onRenderCluster?: ClusterRenderer;\n\n  /**\n   * Advanced overrides for the layout.\n   */\n  layoutOverrides?: LayoutOverrides;\n\n  /**\n   * Whether to aggregate edges with the same source and target.\n   */\n  aggregateEdges?: boolean;\n\n  /**\n   * When a node was clicked.\n   */\n  onNodeClick?: (\n    node: InternalGraphNode,\n    props?: CollapseProps,\n    event?: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * When a node was double clicked.\n   */\n  onNodeDoubleClick?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * When a node context menu happened.\n   */\n  onNodeContextMenu?: (\n    node: InternalGraphNode,\n    props?: NodeContextMenuProps\n  ) => void;\n\n  /**\n   * When node got a pointer over.\n   */\n  onNodePointerOver?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * When node lost pointer over.\n   */\n  onNodePointerOut?: (\n    node: InternalGraphNode,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * Triggered after a node was dragged.\n   */\n  onNodeDragged?: (node: InternalGraphNode) => void;\n\n  /**\n   * Triggered after a cluster was dragged.\n   */\n  onClusterDragged?: (cluster: ClusterEventArgs) => void;\n\n  /**\n   * When a edge context menu happened.\n   */\n  onEdgeContextMenu?: (edge?: InternalGraphEdge) => void;\n\n  /**\n   * When an edge was clicked.\n   */\n  onEdgeClick?: (\n    edge: InternalGraphEdge,\n    event?: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * When edge got a pointer over.\n   */\n  onEdgePointerOver?: (\n    edge: InternalGraphEdge,\n    event?: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * When edge lost pointer over.\n   */\n  onEdgePointerOut?: (\n    edge: InternalGraphEdge,\n    event?: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * When a cluster was clicked.\n   */\n  onClusterClick?: (\n    cluster: ClusterEventArgs,\n    event: ThreeEvent<MouseEvent>\n  ) => void;\n\n  /**\n   * When a cluster receives a pointer over event.\n   */\n  onClusterPointerOver?: (\n    cluster: ClusterEventArgs,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n\n  /**\n   * When cluster receives a pointer leave event.\n   */\n  onClusterPointerOut?: (\n    cluster: ClusterEventArgs,\n    event: ThreeEvent<PointerEvent>\n  ) => void;\n}\n\nexport interface GraphSceneRef {\n  /**\n   * Reference to the graph object.\n   */\n  graph: Graph;\n\n  /**\n   * Centers the graph on a specific node or list of nodes.\n   *\n   * @param nodeIds - An array of node IDs to center the graph on. If this parameter is omitted,\n   * the graph will be centered on all nodes.\n   *\n   * @param opts.centerOnlyIfNodesNotInView - A boolean flag that determines whether the graph should\n   * only be centered if the nodes specified by `ids` are not currently in view. If this\n   * parameter is `true`, the graph will only be re-centered if one or more of the nodes\n   * specified by `ids` are not currently in view. If this parameter is\n   * `false` or omitted, the graph will be re-centered regardless of whether the nodes\n   * are currently in view.\n   */\n  centerGraph: (nodeIds?: string[], opts?: CenterNodesParams) => void;\n\n  /**\n   * Fit all the given nodes into view of the camera.\n   *\n   * @param nodeIds - An array of node IDs to fit the view on. If this parameter is omitted,\n   * the view will fit to all nodes.\n   *\n   * @param opts.fitOnlyIfNodesNotInView - A boolean flag that determines whether the view should\n   * only be fit if the nodes specified by `ids` are not currently in view. If this\n   * parameter is `true`, the view will only be fit if one or more of the nodes\n   * specified by `ids` are not currently visible in the viewport. If this parameter is\n   * `false` or omitted, the view will be fit regardless of whether the nodes\n   * are currently in view.\n   */\n  fitNodesInView: (nodeIds?: string[], opts?: FitNodesParams) => void;\n\n  /**\n   * Calls render scene on the graph. this is useful when you want to manually render the graph\n   * for things like screenshots.\n   */\n  renderScene: () => void;\n}\n\nexport const GraphScene = forwardRef<GraphSceneRef, GraphSceneProps>(\n  (\n    {\n      onNodeClick,\n      onNodeDoubleClick,\n      onNodeContextMenu,\n      onEdgeContextMenu,\n      onEdgeClick,\n      onEdgePointerOver,\n      onEdgePointerOut,\n      onNodePointerOver,\n      onNodePointerOut,\n      onClusterClick,\n      onNodeDragged,\n      onClusterDragged,\n      onClusterPointerOver,\n      onClusterPointerOut,\n      contextMenu,\n      animated,\n      disabled,\n      draggable,\n      constrainDragging = false,\n      edgeLabelPosition,\n      edgeArrowPosition,\n      edgeInterpolation = 'linear',\n      labelFontUrl,\n      renderNode,\n      onRenderCluster,\n      aggregateEdges,\n      ...rest\n    },\n    ref\n  ) => {\n    const { layoutType, clusterAttribute, labelType } = rest;\n\n    // Get the gl/scene/camera for render shortcuts\n    const gl = useThree(state => state.gl);\n    const scene = useThree(state => state.scene);\n    const camera = useThree(state => state.camera);\n\n    // Mount and build the graph\n    const { updateLayout } = useGraph({ ...rest, constrainDragging });\n\n    if (\n      clusterAttribute &&\n      !(layoutType === 'forceDirected2d' || layoutType === 'forceDirected3d')\n    ) {\n      throw new Error(\n        'Clustering is only supported for the force directed layouts.'\n      );\n    }\n\n    // Get the graph and nodes via the store for memo\n    const graph = useStore(state => state.graph);\n    const nodes = useStore(state => state.nodes);\n    const edgesStore = useStore(state => state.edges);\n    const setEdges = useStore(state => state.setEdges);\n    const clusters = useStore(state => [...state.clusters.values()]);\n\n    // Process edges based on aggregation setting and update store\n    const edges = useMemo(() => {\n      if (aggregateEdges) {\n        const aggregatedEdges = aggregateEdgesUtil(graph, labelType);\n        return aggregatedEdges;\n      } else {\n        return edgesStore;\n      }\n    }, [edgesStore, aggregateEdges, graph, labelType]);\n\n    // Update the store if edges were aggregated (moved to useEffect to avoid render cycle error)\n    useEffect(() => {\n      if (aggregateEdges && edgesStore.length !== edges.length) {\n        setEdges(edges);\n      }\n    }, [edges, edgesStore.length, setEdges, aggregateEdges]);\n\n    // Center the graph on the nodes\n    const { centerNodesById, fitNodesInViewById, isCentered } = useCenterGraph({\n      animated,\n      disabled,\n      layoutType\n    });\n\n    // Let's expose some helper methods\n    useImperativeHandle(\n      ref,\n      () => ({\n        centerGraph: centerNodesById,\n        fitNodesInView: fitNodesInViewById,\n        graph,\n        renderScene: () => gl.render(scene, camera)\n      }),\n      [centerNodesById, fitNodesInViewById, graph, gl, scene, camera]\n    );\n\n    const onNodeDraggedHandler = useCallback(\n      (node: InternalGraphNode) => {\n        onNodeDragged?.(node);\n\n        // Update layout to recalculate the cluster positions when a node is dragged\n        if (clusterAttribute) {\n          updateLayout();\n        }\n      },\n      [clusterAttribute, onNodeDragged, updateLayout]\n    );\n\n    const nodeComponents = useMemo(\n      () =>\n        nodes.map(n => (\n          <Node\n            key={n?.id}\n            id={n?.id}\n            labelFontUrl={labelFontUrl}\n            draggable={draggable}\n            constrainDragging={constrainDragging}\n            disabled={disabled}\n            animated={animated}\n            contextMenu={contextMenu}\n            renderNode={renderNode}\n            onClick={onNodeClick}\n            onDoubleClick={onNodeDoubleClick}\n            onContextMenu={onNodeContextMenu}\n            onPointerOver={onNodePointerOver}\n            onPointerOut={onNodePointerOut}\n            onDragged={onNodeDraggedHandler}\n          />\n        )),\n      [\n        constrainDragging,\n        animated,\n        contextMenu,\n        disabled,\n        draggable,\n        labelFontUrl,\n        nodes,\n        onNodeClick,\n        onNodeContextMenu,\n        onNodeDoubleClick,\n        onNodeDraggedHandler,\n        onNodePointerOut,\n        onNodePointerOver,\n        renderNode\n      ]\n    );\n\n    const edgeComponents = useMemo(\n      () =>\n        animated ? (\n          edges.map(e => (\n            <Edge\n              key={e.id}\n              id={e.id}\n              disabled={disabled}\n              animated={animated}\n              labelFontUrl={labelFontUrl}\n              labelPlacement={edgeLabelPosition}\n              arrowPlacement={edgeArrowPosition}\n              interpolation={edgeInterpolation}\n              contextMenu={contextMenu}\n              onClick={onEdgeClick}\n              onContextMenu={onEdgeContextMenu}\n              onPointerOver={onEdgePointerOver}\n              onPointerOut={onEdgePointerOut}\n            />\n          ))\n        ) : (\n          <Edges\n            edges={edges}\n            disabled={disabled}\n            animated={animated}\n            labelFontUrl={labelFontUrl}\n            labelPlacement={edgeLabelPosition}\n            arrowPlacement={edgeArrowPosition}\n            interpolation={edgeInterpolation}\n            contextMenu={contextMenu}\n            onClick={onEdgeClick}\n            onContextMenu={onEdgeContextMenu}\n            onPointerOver={onEdgePointerOver}\n            onPointerOut={onEdgePointerOut}\n          />\n        ),\n      [\n        animated,\n        contextMenu,\n        disabled,\n        edgeArrowPosition,\n        edgeInterpolation,\n        edgeLabelPosition,\n        edges,\n        labelFontUrl,\n        onEdgeClick,\n        onEdgeContextMenu,\n        onEdgePointerOut,\n        onEdgePointerOver\n      ]\n    );\n\n    const clusterComponents = useMemo(\n      () =>\n        clusters.map(c => (\n          <Cluster\n            key={c.label}\n            animated={animated}\n            disabled={disabled}\n            draggable={draggable}\n            labelFontUrl={labelFontUrl}\n            onClick={onClusterClick}\n            onPointerOver={onClusterPointerOver}\n            onPointerOut={onClusterPointerOut}\n            onDragged={onClusterDragged}\n            onRender={onRenderCluster}\n            {...c}\n          />\n        )),\n      [\n        animated,\n        clusters,\n        disabled,\n        draggable,\n        labelFontUrl,\n        onClusterClick,\n        onClusterPointerOut,\n        onClusterPointerOver,\n        onClusterDragged,\n        onRenderCluster\n      ]\n    );\n\n    return (\n      isCentered && (\n        <Fragment>\n          {edgeComponents}\n          {nodeComponents}\n          {clusterComponents}\n        </Fragment>\n      )\n    );\n  }\n);\n","import type Graph from 'graphology';\n\nimport type { Theme } from '../themes';\n\nexport type PathSelectionTypes = 'direct' | 'out' | 'in' | 'all';\n\n/**\n * Given a graph and a list of node ids, return the adjacent nodes and edges.\n *\n * TODO: This method could be improved with the introduction of graphology\n */\nexport function getAdjacents(\n  graph: Graph,\n  nodeIds: string | string[],\n  type: PathSelectionTypes\n) {\n  nodeIds = Array.isArray(nodeIds) ? nodeIds : [nodeIds];\n\n  const nodes: string[] = [];\n  const edges: string[] = [];\n\n  for (const nodeId of nodeIds) {\n    const graphLinks = [\n      ...(graph.inEdgeEntries(nodeId) ?? []),\n      ...(graph.outEdgeEntries(nodeId) ?? [])\n    ];\n\n    if (!graphLinks) {\n      continue;\n    }\n\n    for (const link of graphLinks) {\n      const linkId = link.attributes.id;\n\n      if (type === 'in') {\n        if (link.target === nodeId && !edges.includes(linkId)) {\n          edges.push(linkId);\n        }\n      } else if (type === 'out') {\n        if (link.source === nodeId && !edges.includes(linkId)) {\n          edges.push(linkId);\n        }\n      } else {\n        if (!edges.includes(linkId)) {\n          edges.push(linkId);\n        }\n      }\n\n      if (type === 'out' || type === 'all') {\n        const toId = link.target;\n        if (!nodes.includes(toId as string)) {\n          nodes.push(toId as string);\n        }\n      }\n\n      if (type === 'in' || type === 'all') {\n        if (!nodes.includes(link.source)) {\n          nodes.push(link.source as string);\n        }\n      }\n    }\n  }\n\n  return {\n    nodes,\n    edges\n  };\n}\n\n/**\n * Set the vectors.\n */\nexport function prepareRay(event, vec, size) {\n  const { offsetX, offsetY } = event;\n  const { width, height } = size;\n  vec.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);\n}\n\n/**\n * Create a lasso element.\n */\nexport function createElement(theme: Theme) {\n  const element = document.createElement('div');\n  element.style.pointerEvents = 'none';\n  element.style.border = theme.lasso.border;\n  element.style.backgroundColor = theme.lasso.background;\n  element.style.position = 'fixed';\n  return element;\n}\n","import { useThree } from '@react-three/fiber';\nimport type { FC, PropsWithChildren } from 'react';\nimport React, { useCallback, useEffect, useRef } from 'react';\nimport type { Mesh, TubeGeometry } from 'three';\nimport { Scene, Vector2 } from 'three';\nimport { SelectionBox } from 'three-stdlib';\n\nimport { useCameraControls } from '../CameraControls/useCameraControls';\nimport { useStore } from '../store';\nimport { createElement, prepareRay } from './utils';\n\nexport type LassoType = 'none' | 'all' | 'node' | 'edge';\n\nexport type LassoProps = PropsWithChildren<{\n  /**\n   * Whether the lasso tool is disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * The type of the lasso tool.\n   */\n  type?: LassoType;\n\n  /**\n   * A function that is called when the lasso tool is used to select nodes.\n   * The function receives an array of the ids of the selected nodes.\n   */\n  onLasso?: (selections: string[]) => void;\n\n  /**\n   * A function that is called when the lasso tool is released, ending the selection.\n   * The function receives an array of the ids of the selected nodes.\n   */\n  onLassoEnd?: (selections: string[]) => void;\n}>;\n\nexport const Lasso: FC<LassoProps> = ({\n  children,\n  type = 'none',\n  onLasso,\n  onLassoEnd,\n  disabled\n}) => {\n  const theme = useStore(state => state.theme);\n  const camera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const setEvents = useThree(state => state.setEvents);\n  const size = useThree(state => state.size);\n  const get = useThree(state => state.get);\n  const scene = useThree(state => state.scene);\n\n  const cameraControls = useCameraControls();\n\n  const actives = useStore(state => state.actives);\n  const setActives = useStore(state => state.setActives);\n  const edges = useStore(state => state.edges);\n  const edgeMeshes = useStore(state => state.edgeMeshes);\n\n  const selectionBoxRef = useRef<SelectionBox | null>(null);\n  const edgeMeshSelectionBoxRef = useRef<SelectionBox | null>(null);\n  const elementRef = useRef<HTMLDivElement>(createElement(theme));\n  const vectorsRef = useRef<[Vector2, Vector2, Vector2] | null>(null);\n  const isDownRef = useRef(false);\n  const oldRaycasterEnabledRef = useRef<boolean>(get().events.enabled);\n  const oldControlsEnabledRef = useRef<boolean>(\n    cameraControls.controls?.enabled\n  );\n\n  const onPointerMove = useCallback(\n    event => {\n      if (isDownRef.current) {\n        const [startPoint, pointTopLeft, pointBottomRight] = vectorsRef.current;\n\n        pointBottomRight.x = Math.max(startPoint.x, event.clientX);\n        pointBottomRight.y = Math.max(startPoint.y, event.clientY);\n        pointTopLeft.x = Math.min(startPoint.x, event.clientX);\n        pointTopLeft.y = Math.min(startPoint.y, event.clientY);\n        elementRef.current.style.left = `${pointTopLeft.x}px`;\n        elementRef.current.style.top = `${pointTopLeft.y}px`;\n        elementRef.current.style.width = `${\n          pointBottomRight.x - pointTopLeft.x\n        }px`;\n        elementRef.current.style.height = `${\n          pointBottomRight.y - pointTopLeft.y\n        }px`;\n\n        prepareRay(event, selectionBoxRef.current.endPoint, size);\n        prepareRay(event, edgeMeshSelectionBoxRef.current.endPoint, size);\n\n        const allSelected = [];\n        const edgesSelected = edgeMeshSelectionBoxRef.current\n          .select()\n          .sort(o => (o as any).uuid)\n          .filter(o => o.geometry?.userData?.type === type || type === 'all')\n          .map(\n            edge => edges[edgeMeshes.indexOf(edge as Mesh<TubeGeometry>)].id\n          );\n        allSelected.push(...edgesSelected);\n\n        const selected = selectionBoxRef.current\n          .select()\n          .sort(o => (o as any).uuid)\n          .filter(\n            o =>\n              o.isMesh &&\n              o.userData?.id &&\n              (o.userData?.type === type || type === 'all')\n          )\n          .map(o => o.userData.id);\n        allSelected.push(...selected);\n\n        // Note: This probably isn't the best solution but\n        // it prevents the render thrashing and causing flickering\n        requestAnimationFrame(() => {\n          setActives(allSelected);\n          onLasso?.(allSelected);\n        });\n\n        document.addEventListener('pointermove', onPointerMove, {\n          passive: true,\n          capture: true,\n          once: true\n        });\n      }\n    },\n    [size, edges, edgeMeshes, type, setActives, onLasso]\n  );\n\n  const onPointerUp = useCallback(() => {\n    if (isDownRef.current) {\n      setEvents({ enabled: oldRaycasterEnabledRef.current });\n      isDownRef.current = false;\n      elementRef.current.parentElement?.removeChild(elementRef.current);\n      cameraControls.controls.enabled = oldControlsEnabledRef.current;\n      onLassoEnd?.(actives);\n\n      document.removeEventListener('pointermove', onPointerMove);\n      document.removeEventListener('pointerup', onPointerUp);\n    }\n  }, [setEvents, cameraControls.controls, onLassoEnd, actives, onPointerMove]);\n\n  const onPointerDown = useCallback(\n    event => {\n      if (event.shiftKey) {\n        // Let's capture the old props to restore them later\n        oldRaycasterEnabledRef.current = get().events.enabled;\n        oldControlsEnabledRef.current = cameraControls.controls?.enabled;\n\n        // SelectionBox for all meshes\n        selectionBoxRef.current = new SelectionBox(camera, scene);\n\n        // SelectionBox for all Edge meshes (since they are combined into one geometry for rendering)\n        const edgeScene = new Scene();\n        if (edgeMeshes.length) {\n          edgeScene.add(...edgeMeshes);\n        }\n        edgeMeshSelectionBoxRef.current = new SelectionBox(camera, edgeScene);\n\n        vectorsRef.current = [\n          // start point\n          new Vector2(),\n          // point top left\n          new Vector2(),\n          // point bottom right\n          new Vector2()\n        ];\n\n        const [startPoint] = vectorsRef.current;\n\n        cameraControls.controls.enabled = false;\n        setEvents({ enabled: false });\n        isDownRef.current = true;\n        gl.domElement.parentElement?.appendChild(elementRef.current);\n        elementRef.current.style.left = `${event.clientX}px`;\n        elementRef.current.style.top = `${event.clientY}px`;\n        elementRef.current.style.width = '0px';\n        elementRef.current.style.height = '0px';\n        startPoint.x = event.clientX;\n        startPoint.y = event.clientY;\n\n        prepareRay(event, selectionBoxRef.current.startPoint, size);\n        prepareRay(event, edgeMeshSelectionBoxRef.current.startPoint, size);\n\n        document.addEventListener('pointermove', onPointerMove, {\n          passive: true,\n          capture: true,\n          once: true\n        });\n        document.addEventListener('pointerup', onPointerUp, { passive: true });\n      }\n    },\n    [\n      camera,\n      cameraControls.controls,\n      edgeMeshes,\n      get,\n      gl.domElement.parentElement,\n      onPointerMove,\n      onPointerUp,\n      scene,\n      setEvents,\n      size\n    ]\n  );\n\n  useEffect(() => {\n    if (disabled || type === 'none') {\n      return;\n    }\n\n    if (typeof window !== 'undefined') {\n      document.addEventListener('pointerdown', onPointerDown, {\n        passive: true\n      });\n      document.addEventListener('pointermove', onPointerMove, {\n        passive: true\n      });\n      document.addEventListener('pointerup', onPointerUp, { passive: true });\n    }\n\n    return () => {\n      if (typeof window !== 'undefined') {\n        document.removeEventListener('pointerdown', onPointerDown);\n        document.removeEventListener('pointermove', onPointerMove);\n        document.removeEventListener('pointerup', onPointerUp);\n      }\n    };\n  }, [type, disabled, onPointerDown, onPointerMove, onPointerUp]);\n\n  return <group>{children}</group>;\n};\n","import type { Theme } from './theme';\n\nexport const darkTheme: Theme = {\n  canvas: {\n    background: '#1E2026'\n  },\n  node: {\n    fill: '#7A8C9E',\n    activeFill: '#1DE9AC',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.1,\n    label: {\n      color: '#202020',\n      activeColor: '#000000',\n      fontSize: 6,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#fafafa',\n      borderRadius: 2\n    },\n    subLabel: {\n      stroke: '#1E2026',\n      color: '#ACBAC7',\n      activeColor: '#1DE9AC'\n    }\n  },\n  lasso: {\n    border: '1px solid #55aaff',\n    background: 'rgba(75, 160, 255, 0.1)'\n  },\n  ring: {\n    fill: '#54616D',\n    activeFill: '#1DE9AC'\n  },\n  edge: {\n    fill: '#ffffff',\n    activeFill: '#1DE9AC',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.1,\n    label: {\n      color: '#202020',\n      activeColor: '#000000',\n      fontSize: 4,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#fafafa',\n      borderRadius: 2\n    }\n  },\n  arrow: {\n    fill: '#474B56',\n    activeFill: '#1DE9AC'\n  },\n  cluster: {\n    stroke: '#474B56',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.1,\n    label: {\n      color: '#202020',\n      activeColor: '#000000',\n      fontSize: 4,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#fafafa',\n      borderRadius: 2\n    }\n  }\n};\n","import type { Theme } from './theme';\n\nexport const lightTheme: Theme = {\n  canvas: {\n    background: '#fff'\n  },\n  node: {\n    fill: '#7CA0AB',\n    activeFill: '#1DE9AC',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.2,\n    label: {\n      color: '#2A6475',\n      // stroke: '#fff',\n      activeColor: '#1DE9AC',\n      fontSize: 6,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#1E2026',\n      borderRadius: 2\n    },\n    subLabel: {\n      color: '#ddd',\n      stroke: 'transparent',\n      activeColor: '#1DE9AC'\n    }\n  },\n  lasso: {\n    border: '1px solid #55aaff',\n    background: 'rgba(75, 160, 255, 0.1)'\n  },\n  ring: {\n    fill: '#D8E6EA',\n    activeFill: '#1DE9AC'\n  },\n  edge: {\n    fill: '#474B56',\n    activeFill: '#1DE9AC',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.1,\n    label: {\n      // stroke: '#fff',\n      color: '#2A6475',\n      activeColor: '#1DE9AC',\n      fontSize: 6,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#1E2026',\n      borderRadius: 2\n    }\n  },\n  arrow: {\n    fill: '#D8E6EA',\n    activeFill: '#1DE9AC'\n  },\n  cluster: {\n    stroke: '#D8E6EA',\n    opacity: 1,\n    selectedOpacity: 1,\n    inactiveOpacity: 0.1,\n    label: {\n      stroke: '#1E2026',\n      color: '#ACBAC7',\n      activeColor: '#1DE9AC',\n      fontSize: 6,\n      maxWidth: 100,\n      ellipsis: 100,\n      backgroundColor: '#1E2026',\n      borderRadius: 2\n    }\n  }\n};\n","import { Canvas } from '@react-three/fiber';\nimport type ThreeCameraControls from 'camera-controls';\nimport type Graph from 'graphology';\nimport type { ReactNode, Ref } from 'react';\nimport React, {\n  forwardRef,\n  Suspense,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef\n} from 'react';\n\nimport type { CameraControlsRef, CameraMode } from '../CameraControls';\nimport { CameraControls } from '../CameraControls';\nimport type { GraphSceneProps, GraphSceneRef } from '../GraphScene';\nimport { GraphScene } from '../GraphScene';\nimport type { LassoType } from '../selection/Lasso';\nimport { Lasso } from '../selection/Lasso';\nimport { createStore, Provider } from '../store';\nimport type { Theme } from '../themes';\nimport { lightTheme } from '../themes';\nimport css from './GraphCanvas.module.css';\n\nexport interface GraphCanvasProps extends Omit<GraphSceneProps, 'theme'> {\n  /**\n   * Theme to use for the graph.\n   */\n  theme?: Theme;\n\n  /**\n   * Type of camera interaction.\n   */\n  cameraMode?: CameraMode;\n\n  /**\n   * The maximum distance for the camera. Default is 50000.\n   */\n  maxDistance?: number;\n\n  /**\n   * The minimum distance for the camera. Default is 1000.\n   */\n  minDistance?: number;\n\n  /**\n   * The minimum zoom level for the camera. Default is 1.\n   */\n  minZoom?: number;\n\n  /**\n   * The maximum zoom level for the camera. Default is 100.\n   */\n  maxZoom?: number;\n\n  /**\n   * The type of lasso selection.\n   */\n  lassoType?: LassoType;\n\n  /**\n   * Children to render in the canvas. Useful for things like lights.\n   */\n  children?: ReactNode;\n\n  /**\n   * Ability to extend Cavas gl options. For example { preserveDrawingBuffer: true }\n   */\n  glOptions?: object;\n\n  /**\n   * When the canvas had a lasso selection.\n   */\n  onLasso?: (selections: string[]) => void;\n\n  /**\n   * When the canvas had a lasso selection end.\n   */\n  onLassoEnd?: (selections: string[]) => void;\n\n  /**\n   * When the canvas was clicked but didn't hit a node/edge.\n   */\n  onCanvasClick?: (event: MouseEvent) => void;\n\n  /**\n   * Whether to aggregate edges with the same source and target.\n   */\n  aggregateEdges?: boolean;\n}\n\nexport type GraphCanvasRef = Omit<GraphSceneRef, 'graph' | 'renderScene'> &\n  Omit<CameraControlsRef, 'controls'> & {\n    /**\n     * Get the graph object.\n     */\n    getGraph: () => Graph;\n\n    /**\n     * Get the camera controls.\n     */\n    getControls: () => ThreeCameraControls;\n\n    /**\n     * Export the canvas as a data URL.\n     */\n    exportCanvas: () => string;\n  };\n\nconst GL_DEFAULTS = {\n  alpha: true,\n  antialias: true\n};\n\n// TODO: Fix type\nconst CAMERA_DEFAULTS: any = {\n  position: [0, 0, 1000],\n  near: 5,\n  far: 50000,\n  fov: 10\n};\n\nexport const GraphCanvas = forwardRef<GraphCanvasRef, GraphCanvasProps>(\n  (\n    {\n      cameraMode = 'pan',\n      layoutType = 'forceDirected2d',\n      sizingType = 'default',\n      labelType = 'auto',\n      theme = lightTheme,\n      animated = true,\n      defaultNodeSize = 7,\n      minNodeSize = 5,\n      maxNodeSize = 15,\n      lassoType = 'none',\n      glOptions = {},\n      edges,\n      children,\n      nodes,\n      minDistance,\n      maxDistance,\n      minZoom,\n      maxZoom,\n      onCanvasClick,\n      disabled,\n      onLasso,\n      onLassoEnd,\n      aggregateEdges,\n      ...rest\n    },\n    ref: Ref<GraphCanvasRef>\n  ) => {\n    const rendererRef = useRef<GraphSceneRef | null>(null);\n    const controlsRef = useRef<CameraControlsRef | null>(null);\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n\n    useImperativeHandle(ref, () => ({\n      centerGraph: (nodeIds, opts) =>\n        rendererRef.current?.centerGraph(nodeIds, opts),\n      fitNodesInView: (nodeIds, opts) =>\n        rendererRef.current?.fitNodesInView(nodeIds, opts),\n      zoomIn: () => {\n        const controls = controlsRef.current?.controls;\n        if (!controls) return;\n\n        const currentDistance = controls.distance;\n        const currentZoom = controls.camera.zoom;\n\n        // Calculate what the new zoom would be has to match CameraControls logic\n        const newZoom = currentZoom + currentZoom / 2;\n        const newEffectiveDistance = currentDistance / newZoom;\n\n        // Check if zooming in would violate minDistance constraint\n        if (!minDistance || newEffectiveDistance >= minDistance) {\n          controlsRef.current?.zoomIn();\n        }\n      },\n      zoomOut: () => {\n        const controls = controlsRef.current?.controls;\n        if (!controls) return;\n\n        const currentDistance = controls.distance;\n        const currentZoom = controls.camera.zoom;\n\n        // Calculate what the new zoom would be (matches CameraControls logic)\n        const newZoom = currentZoom - currentZoom / 2;\n        const newEffectiveDistance = currentDistance / newZoom;\n\n        // Check if zooming out would violate maxDistance constraint\n        if (!maxDistance || newEffectiveDistance <= maxDistance) {\n          controlsRef.current?.zoomOut();\n        }\n      },\n      dollyIn: distance => controlsRef.current?.dollyIn(distance),\n      dollyOut: distance => controlsRef.current?.dollyOut(distance),\n      panLeft: () => controlsRef.current?.panLeft(),\n      panRight: () => controlsRef.current?.panRight(),\n      panDown: () => controlsRef.current?.panDown(),\n      panUp: () => controlsRef.current?.panUp(),\n      resetControls: (animated?: boolean) =>\n        controlsRef.current?.resetControls(animated),\n      getControls: () => controlsRef.current?.controls,\n      getGraph: () => rendererRef.current?.graph,\n      exportCanvas: () => {\n        rendererRef.current.renderScene();\n        return canvasRef.current.toDataURL();\n      },\n      freeze: () => controlsRef.current?.freeze(),\n      unFreeze: () => controlsRef.current?.unFreeze()\n    }));\n\n    // Defaults to pass to the store\n    const { selections, actives, collapsedNodeIds } = rest;\n\n    // It's pretty hard to get good animation performance with large n of edges/nodes\n    const finalAnimated = edges.length + nodes.length > 400 ? false : animated;\n\n    const gl = useMemo(() => ({ ...glOptions, ...GL_DEFAULTS }), [glOptions]);\n    // zustand/context migration (https://github.com/pmndrs/zustand/discussions/1180)\n    const store = useRef(\n      createStore({\n        selections,\n        actives,\n        theme,\n        collapsedNodeIds\n      })\n    ).current;\n\n    // Update store theme when theme prop changes\n    useEffect(() => {\n      store.getState().setTheme(theme);\n    }, [theme, store]);\n\n    // NOTE: The legacy/linear/flat flags are for color issues\n    // Reference: https://github.com/protectwise/troika/discussions/213#discussioncomment-3086666\n    return (\n      <div className={css.canvas}>\n        <Canvas\n          orthographic={cameraMode === 'orthographic'}\n          legacy\n          linear\n          ref={canvasRef}\n          flat\n          gl={gl}\n          camera={CAMERA_DEFAULTS}\n          onPointerMissed={onCanvasClick}\n        >\n          <Provider store={store}>\n            {theme.canvas?.background && (\n              <color attach=\"background\" args={[theme.canvas.background]} />\n            )}\n            <ambientLight intensity={1} />\n            {children}\n            {theme.canvas?.fog && (\n              <fog attach=\"fog\" args={[theme.canvas.fog, 4000, 9000]} />\n            )}\n            <CameraControls\n              mode={cameraMode}\n              ref={controlsRef}\n              disabled={disabled}\n              minDistance={minDistance}\n              maxDistance={maxDistance}\n              minZoom={minZoom}\n              maxZoom={maxZoom}\n              animated={animated}\n            >\n              <Lasso\n                disabled={disabled}\n                type={lassoType}\n                onLasso={onLasso}\n                onLassoEnd={onLassoEnd}\n              >\n                <Suspense>\n                  <GraphScene\n                    ref={rendererRef as any}\n                    disabled={disabled}\n                    animated={finalAnimated}\n                    edges={edges}\n                    nodes={nodes}\n                    layoutType={layoutType}\n                    sizingType={sizingType}\n                    labelType={labelType}\n                    defaultNodeSize={defaultNodeSize}\n                    minNodeSize={minNodeSize}\n                    maxNodeSize={maxNodeSize}\n                    aggregateEdges={aggregateEdges}\n                    {...rest}\n                  />\n                </Suspense>\n              </Lasso>\n            </CameraControls>\n          </Provider>\n        </Canvas>\n      </div>\n    );\n  }\n);\n","import classNames from 'classnames';\nimport type { FC, ReactNode } from 'react';\nimport React from 'react';\n\nimport css from './RadialSlice.module.css';\n\nexport interface MenuItem {\n  /**\n   * Label to display on the menu item.\n   */\n  label: string;\n\n  /**\n   * CSS Classname to apply to the slice.\n   */\n  className?: string;\n\n  /**\n   * Optional icon to display on the menu item.\n   */\n  icon?: ReactNode;\n\n  /**\n   * Optional callback to detemine if the menu item is active.\n   */\n  disabled?: boolean;\n\n  /**\n   * Optional callback to handle when the menu item is clicked.\n   */\n  onClick?: (event: React.MouseEvent<HTMLDivElement>) => void;\n}\n\ninterface RadialSliceProps extends MenuItem {\n  /**\n   * The starting angle of the radial slice, in degrees.\n   */\n  startAngle: number;\n\n  /**\n   * The ending angle of the radial slice, in degrees.\n   */\n  endAngle: number;\n\n  /**\n   * The skew of the radial slice.\n   */\n  skew: number;\n\n  /**\n   * Whether the radial slice is polar (true) or not (false).\n   */\n  polar: boolean;\n\n  /**\n   * The central angle of the radial slice, in degrees.\n   */\n  centralAngle: number;\n\n  /**\n   * The radius of the radial slice.\n   */\n  radius: number;\n\n  /**\n   * The inner radius of the radial slice.\n   */\n  innerRadius: number;\n}\n\nexport const RadialSlice: FC<RadialSliceProps> = ({\n  label,\n  centralAngle,\n  startAngle,\n  endAngle,\n  polar,\n  radius,\n  className,\n  icon,\n  innerRadius,\n  skew,\n  disabled,\n  onClick\n}) => (\n  <div\n    role=\"menuitem\"\n    className={classNames(css.container, className, {\n      [css.disabled]: disabled\n    })}\n    style={{\n      width: centralAngle > 90 ? '100%' : '50%',\n      height: centralAngle > 90 ? '100%' : '50%',\n      bottom: centralAngle > 90 ? '50%' : 'initial',\n      right: centralAngle > 90 ? '50%' : 'initial',\n      transform: `rotate(${startAngle + endAngle}deg) skew(${skew}deg)`\n    }}\n    onClick={event => {\n      if (!disabled) {\n        onClick(event);\n      }\n    }}\n  >\n    <div\n      className={css.contentContainer}\n      style={{\n        transform: `skew(${-skew}deg) rotate(${\n          (polar ? 90 : centralAngle) / 2 - 90\n        }deg)`\n      }}\n    >\n      <div\n        className={css.contentInner}\n        style={{\n          top: `calc((((${\n            centralAngle > 90 ? '50% + ' : ''\n          }${radius}px) - ${innerRadius}px) / 2) - 4em)`\n        }}\n      >\n        <div\n          className={css.content}\n          style={{\n            transform: `rotate(${-endAngle}deg)`\n          }}\n          title={label}\n        >\n          {icon}\n          {label}\n        </div>\n      </div>\n    </div>\n  </div>\n);\n","import type { MenuItem } from './RadialSlice';\n\nexport function calculateRadius(items: MenuItem[], startOffsetAngle: number) {\n  const centralAngle = 360 / items.length || 360;\n  const polar = centralAngle % 180 === 0;\n  const deltaAngle = 90 - centralAngle;\n  const startAngle = polar\n    ? 45\n    : startOffsetAngle + deltaAngle + centralAngle / 2;\n\n  return { centralAngle, polar, startAngle, deltaAngle };\n}\n","import classNames from 'classnames';\nimport type { FC } from 'react';\nimport React, { useLayoutEffect, useMemo, useRef } from 'react';\n\nimport css from './RadialMenu.module.css';\nimport type { MenuItem } from './RadialSlice';\nimport { RadialSlice } from './RadialSlice';\nimport { calculateRadius } from './utils';\n\ninterface RadialMenuProps {\n  /**\n   * An array of menu items to be displayed in the radial menu.\n   */\n  items: MenuItem[];\n\n  /**\n   * The radius of the radial menu.\n   */\n  radius?: number;\n\n  /**\n   * The inner radius of the radial menu.\n   */\n  innerRadius?: number;\n\n  /**\n   * The starting offset angle for the first menu item.\n   */\n  startOffsetAngle?: number;\n\n  /**\n   * The CSS class name for the radial menu.\n   */\n  className?: string;\n\n  /**\n   * A function that is called when the radial menu is closed.\n   * The function receives the mouse event that triggered the closure.\n   */\n  onClose?: (event: React.MouseEvent<HTMLDivElement>) => void;\n}\n\nexport const RadialMenu: FC<RadialMenuProps> = ({\n  items,\n  radius = 175,\n  className,\n  innerRadius = 25,\n  startOffsetAngle = 0,\n  onClose\n}) => {\n  const { centralAngle, polar, startAngle, deltaAngle } = useMemo(\n    () => calculateRadius(items, startOffsetAngle),\n    [items, startOffsetAngle]\n  );\n  const timeout = useRef<any | null>(null);\n\n  useLayoutEffect(() => {\n    const timer = timeout.current;\n    return () => clearTimeout(timer);\n  }, []);\n\n  if (items.length === 0) {\n    return null;\n  }\n\n  return (\n    <div\n      role=\"menu\"\n      className={classNames(css.container, className)}\n      onPointerEnter={() => clearTimeout(timeout.current)}\n      onPointerLeave={event => {\n        clearTimeout(timeout.current);\n        timeout.current = setTimeout(() => onClose?.(event), 500);\n      }}\n    >\n      {items.map((slice, index) => (\n        <RadialSlice\n          key={index}\n          {...slice}\n          radius={radius}\n          innerRadius={innerRadius}\n          startAngle={startAngle}\n          endAngle={centralAngle * index}\n          skew={polar ? 0 : deltaAngle}\n          polar={polar}\n          centralAngle={centralAngle}\n          onClick={event => {\n            slice?.onClick(event);\n            onClose?.(event);\n          }}\n        />\n      ))}\n    </div>\n  );\n};\n","import type { RefObject } from 'react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport type { GraphCanvasRef } from '../GraphCanvas';\nimport type { GraphEdge, GraphNode } from '../types';\nimport { isNotEditableElement } from '../utils/dom';\nimport { findPath } from '../utils/paths';\nimport type { PathSelectionTypes } from './utils';\nimport { getAdjacents } from './utils';\n\nexport type HotkeyTypes = 'selectAll' | 'deselect' | 'delete';\n\nexport type SelectionTypes = 'single' | 'multi' | 'multiModifier';\n\nexport interface SelectionProps {\n  /**\n   * Required ref for the graph.\n   */\n  ref: RefObject<GraphCanvasRef | null>;\n\n  /**\n   * Current selections.\n   *\n   * Contains both nodes and edges ids.\n   */\n  selections?: string[];\n\n  /**\n   * Default active selections.\n   */\n  actives?: string[];\n\n  /**\n   * Node datas.\n   */\n  nodes?: GraphNode[];\n\n  /**\n   * Edge datas.\n   */\n  edges?: GraphEdge[];\n\n  /**\n   * Disabled or not.\n   */\n  disabled?: boolean;\n\n  /**\n   * Whether to focus on select or not.\n   */\n  focusOnSelect?: boolean | 'singleOnly';\n\n  /**\n   * Type of selection.\n   */\n  type?: SelectionTypes;\n\n  /**\n   * Type of selection.\n   */\n  pathSelectionType?: PathSelectionTypes;\n\n  /**\n   * Whether it should active on hover or not.\n   */\n  pathHoverType?: PathSelectionTypes;\n\n  /**\n   * On selection change.\n   */\n  onSelection?: (selectionIds: string[]) => void;\n}\n\nexport interface SelectionResult {\n  /**\n   * Selections id array (of nodes and edges).\n   */\n  selections: string[];\n\n  /**\n   * The nodes/edges around the selections to highlight.\n   */\n  actives: string[];\n\n  /**\n   * Clear selections method.\n   */\n  clearSelections: (value?: string[]) => void;\n\n  /**\n   * A selection method.\n   */\n  addSelection: (value: string) => void;\n\n  /**\n   * Get the paths between two nodes.\n   */\n  selectNodePaths: (source: string, target: string) => void;\n\n  /**\n   * Remove selection method.\n   */\n  removeSelection: (value: string) => void;\n\n  /**\n   * Toggle existing selection on/off method.\n   */\n  toggleSelection: (value: string) => void;\n\n  /**\n   * Set internal selections.\n   */\n  setSelections: (value: string[]) => void;\n\n  /**\n   * On click event pass through.\n   */\n  onNodeClick?: (data: GraphNode) => void;\n\n  /**\n   * On canvas click event pass through.\n   */\n  onCanvasClick?: (event: MouseEvent) => void;\n\n  /**\n   * When the lasso happened.\n   */\n  onLasso?: (selections: string[]) => void;\n\n  /**\n   * When the lasso ended.\n   */\n  onLassoEnd?: (selections: string[]) => void;\n\n  /**\n   * When node got a pointer over.\n   */\n  onNodePointerOver?: (node: GraphNode) => void;\n\n  /**\n   * When node lost pointer over.\n   */\n  onNodePointerOut?: (node: GraphNode) => void;\n}\n\nexport const useSelection = ({\n  selections = [],\n  nodes = [],\n  actives = [],\n  focusOnSelect = true,\n  type = 'single',\n  pathHoverType = 'out',\n  pathSelectionType = 'direct',\n  ref,\n  disabled,\n  onSelection\n}: SelectionProps): SelectionResult => {\n  const [internalHovers, setInternalHovers] = useState<string[]>([]);\n  const [internalActives, setInternalActives] = useState<string[]>(actives);\n  const [internalSelections, setInternalSelections] =\n    useState<string[]>(selections);\n  const [metaKeyDown, setMetaKeyDown] = useState<boolean>(false);\n  const isMulti = type === 'multi' || type === 'multiModifier';\n\n  const addSelection = useCallback(\n    (items: string | string[]) => {\n      if (!disabled && items) {\n        items = Array.isArray(items) ? items : [items];\n\n        const filtered = items.filter(\n          item => !internalSelections.includes(item)\n        );\n        if (filtered.length) {\n          const next = [...internalSelections, ...filtered];\n          onSelection?.(next);\n          setInternalSelections(next);\n        }\n      }\n    },\n    [disabled, internalSelections, onSelection]\n  );\n\n  const removeSelection = useCallback(\n    (items: string | string[]) => {\n      if (!disabled && items) {\n        items = Array.isArray(items) ? items : [items];\n\n        const next = internalSelections.filter(i => !items.includes(i));\n        onSelection?.(next);\n        setInternalSelections(next);\n      }\n    },\n    [disabled, internalSelections, onSelection]\n  );\n\n  const clearSelections = useCallback(\n    (next: string | string[] = []) => {\n      if (!disabled) {\n        next = Array.isArray(next) ? next : [next];\n        setInternalActives([]);\n        setInternalSelections(next);\n        onSelection?.(next);\n      }\n    },\n    [disabled, onSelection]\n  );\n\n  const toggleSelection = useCallback(\n    (item: string) => {\n      const has = internalSelections.includes(item);\n      if (has) {\n        removeSelection(item);\n      } else {\n        if (!isMulti) {\n          clearSelections(item);\n        } else {\n          addSelection(item);\n        }\n      }\n    },\n    [\n      addSelection,\n      clearSelections,\n      internalSelections,\n      isMulti,\n      removeSelection\n    ]\n  );\n\n  const onNodeClick = useCallback(\n    (data: GraphNode) => {\n      if (isMulti) {\n        if (type === 'multiModifier') {\n          if (metaKeyDown) {\n            addSelection(data.id);\n          } else {\n            clearSelections(data.id);\n          }\n        } else {\n          addSelection(data.id);\n        }\n      } else {\n        clearSelections(data.id);\n      }\n\n      if (\n        focusOnSelect === true ||\n        (focusOnSelect === 'singleOnly' && !metaKeyDown)\n      ) {\n        if (!ref.current) {\n          throw new Error('No ref found for the graph canvas.');\n        }\n\n        const graph = ref.current.getGraph();\n        const { nodes: adjacents } = getAdjacents(\n          graph,\n          [data.id],\n          pathSelectionType\n        );\n\n        ref.current.fitNodesInView([data.id, ...adjacents], {\n          fitOnlyIfNodesNotInView: true\n        });\n      }\n    },\n    [\n      addSelection,\n      clearSelections,\n      focusOnSelect,\n      isMulti,\n      metaKeyDown,\n      pathSelectionType,\n      ref,\n      type\n    ]\n  );\n\n  const selectNodePaths = useCallback(\n    (source: string, target: string) => {\n      const graph = ref.current.getGraph();\n      if (!graph) {\n        throw new Error('Graph is not initialized');\n      }\n\n      const path = findPath(graph, source, target);\n      clearSelections([source, target]);\n\n      const result = [];\n      for (let i = 0; i < path.length - 1; i++) {\n        const from = path[i];\n        const to = path[i + 1];\n        const edge = graph.getEdgeAttributes(from, to);\n        if (edge) {\n          result.push(edge.id);\n        }\n      }\n\n      setInternalActives([...path.map(p => p as string), ...result]);\n    },\n    [clearSelections, ref]\n  );\n\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\n    const element = event.target as HTMLElement;\n    const isSafe = isNotEditableElement(element);\n    const isMeta = event.metaKey || event.ctrlKey;\n\n    if (isSafe && isMeta) {\n      setMetaKeyDown(true);\n    }\n  }, []);\n\n  const onKeyUp = useCallback((event: KeyboardEvent) => {\n    const element = event.target as HTMLElement;\n    const isSafe = isNotEditableElement(element);\n    const isMeta = ['Meta', 'Control'].includes(event.key);\n\n    if (isSafe && isMeta) {\n      setMetaKeyDown(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('keydown', onKeyDown);\n      window.addEventListener('keyup', onKeyUp);\n    }\n\n    return () => {\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('keydown', onKeyDown);\n        window.removeEventListener('keyup', onKeyUp);\n      }\n    };\n  }, [onKeyDown, onKeyUp]);\n\n  const onCanvasClick = useCallback(\n    (event: MouseEvent) => {\n      if (\n        event.button !== 2 &&\n        (internalSelections.length || internalActives.length)\n      ) {\n        clearSelections();\n        setMetaKeyDown(false);\n\n        // Only re-center if we have a single selection\n        if (focusOnSelect && internalSelections.length === 1) {\n          if (!ref.current) {\n            throw new Error('No ref found for the graph canvas.');\n          }\n\n          ref.current.fitNodesInView([], { fitOnlyIfNodesNotInView: true });\n        }\n      }\n    },\n    [\n      clearSelections,\n      focusOnSelect,\n      internalActives.length,\n      internalSelections.length,\n      ref\n    ]\n  );\n\n  const onLasso = useCallback((selections: string[]) => {\n    setInternalActives(selections);\n  }, []);\n\n  const onLassoEnd = useCallback(\n    (selections: string[]) => {\n      clearSelections(selections);\n    },\n    [clearSelections]\n  );\n\n  const onNodePointerOver = useCallback(\n    (data: GraphNode) => {\n      if (pathHoverType) {\n        const graph = ref.current.getGraph();\n        if (!graph) {\n          throw new Error('No ref found for the graph canvas.');\n        }\n\n        const { nodes, edges } = getAdjacents(graph, [data.id], pathHoverType);\n        setInternalHovers([...nodes, ...edges]);\n      }\n    },\n    [pathHoverType, ref]\n  );\n\n  const onNodePointerOut = useCallback(() => {\n    if (pathHoverType) {\n      setInternalHovers([]);\n    }\n  }, [pathHoverType]);\n\n  useEffect(() => {\n    if (pathSelectionType !== 'direct' && internalSelections.length > 0) {\n      const graph = ref.current?.getGraph();\n      if (graph) {\n        const { nodes, edges } = getAdjacents(\n          graph,\n          internalSelections,\n          pathSelectionType\n        );\n        setInternalActives([...nodes, ...edges]);\n      }\n    }\n  }, [internalSelections, pathSelectionType, ref]);\n\n  const joinedActives = useMemo(\n    () => [...internalActives, ...internalHovers],\n    [internalActives, internalHovers]\n  );\n\n  return {\n    actives: joinedActives,\n    onNodeClick,\n    onNodePointerOver,\n    onNodePointerOut,\n    onLasso,\n    onLassoEnd,\n    selectNodePaths,\n    onCanvasClick,\n    selections: internalSelections,\n    clearSelections,\n    addSelection,\n    removeSelection,\n    toggleSelection,\n    setSelections: setInternalSelections\n  };\n};\n"],"names":["nodes","n","canvas","theme","actives","selections","id","node","useZustandStore","Sphere","disabled","ref","animated","Ring","curve","Edge","arrowPosition","arrowRotation","active","inactive","draggingActive","draggingInactive","edgeMeshes","DreiSvg","a","i","tree","links","d3ForceRadial","forceX","forceY","d3ForceX","d3ForceY","d3ForceSimulation","d3ForceCenter","d3ForceLink","d3ForceManyBody","d3ForceZ","drags","aggregateEdges","aggregateEdgesUtil","Fragment","css"],"mappings":"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"}